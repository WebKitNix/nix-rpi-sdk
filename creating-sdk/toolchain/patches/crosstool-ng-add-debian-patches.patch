diff -Nru a/patches/binutils/2.22/000-branch-updates.patch b/patches/binutils/2.22/000-branch-updates.patch
--- a/patches/binutils/2.22/000-branch-updates.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/000-branch-updates.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,6396 @@
+# DP: updates from the binutils-2.22 branch
+
+# git diff 10968a312d8c536be9993ed06bc88fbe0860d95d 20328dadc04ae46c8ca4b334c8d1d4c9aec9c5b7
+# exclude bfd/{configure{,.ac},Makefile.{am,in}}
+
+diff --git a/bfd/ChangeLog b/bfd/ChangeLog
+index 65db027..a568f1b 100644
+--- a/bfd/ChangeLog
++++ b/bfd/ChangeLog
+@@ -1,3 +1,206 @@
++2012-05-11  Ralf Cors√©pius  <ralf.corsepius@rtems.org>
++
++	Backport from mainline:
++
++	2012-04-24  Alan Modra  <amodra@gmail.com>
++	PR ld/13991
++	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
++	_bfd_generic_link_just_syms.
++	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
++	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.
++
++	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
++	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
++	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
++	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
++	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
++	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
++	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
++	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
++	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
++	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
++	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
++	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
++	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
++	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
++	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
++	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
++	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
++	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
++	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
++	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
++	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
++	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
++	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
++	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
++	* bfd/reloc.c: Update all references.
++	* bfd/bfd-in2.h: Regenerate.
++
++2012-04-20  Nick Clifton  <nickc@redhat.com>
++
++	Import this patch from the mainline:
++	2012-03-21  Eliot Dresselhaus  <eliot@sonic.net>
++
++	* elf32-tic6x.c (elf32_tic6x_merge_private_bfd_data): Return TRUE
++	for non-C6X objects.
++
++2012-02-01  Nick Clifton  <nickc@redhat.com>
++
++	Import this patch from the mainline:
++	2012-01-05  Nick Clifton  <nickc@redhat.com>
++
++	PR ld/12161
++	* elf32-avr.c (elf32_avr_relax_delete_bytes): Read in relocs if
++	necessary.
++
++2012-01-27  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
++
++	Backport from mainline:
++	2011-12-11  John Davis Anglin  <dave.anglin@nrc-cnrc.gc.ca>
++
++	PR binutils/13476
++	* elf32-hppa.c (final_link_relocate): Convert R_PARISC_TLS_GD21L,
++	R_PARISC_TLS_LDM21L and R_PARISC_TLS_IE21L relocations to
++	R_PARISC_DPREL21L when not doing a shared link.  Likewise convert
++	R_PARISC_TLS_GD14R, R_PARISC_TLS_LDM14R and R_PARISC_TLS_IE14R to
++	R_PARISC_DPREL14R.  Handle R_PARISC_TLS_GD21L, R_PARISC_TLS_LDM21L
++	and R_PARISC_TLS_IE21L with R_PARISC_DLTIND21L.
++
++	Backport from mainline:
++	2011-11-06  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
++
++	PR ld/13387
++	* elf32-hppa.c (elf32_hppa_hide_symbol): Make STT_GNU_IFUNC symbol
++	go through PLT.  Reset plt field with init_plt_offset.
++	(elf32_hppa_adjust_dynamic_symbol): Ensure that a PLT slot is
++	allocated for symbols referenced by a plabel.
++
++2012-01-10  H.J. Lu  <hongjiu.lu@intel.com>
++
++	Backport from mainline:
++	PR ld/13581
++	* elf64-x86-64.c (elf_x86_64_relocate_section): Remove ABI_64_P
++	check on R_X86_64_PCXX.
++
++2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	Backport from mainline:
++
++	2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	* reloc.c (BFD_RELOC_MIPS16_TLS_GD,BFD_RELOC_MIPS16_TLS_LDM,
++	BFD_RELOC_MIPS16_TLS_DTPREL_HI16,BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
++	BFD_RELOC_MIPS16_TLS_GOTTPREL,BFD_RELOC_MIPS16_TLS_TPREL_HI16,
++	BFD_RELOC_MIPS16_TLS_TPREL_LO16): New relocations for MIPS16 TLS.
++	* bfd-in2.h (bfd_reloc_code_real): Regenerate.
++	* libbfd.h (bfd_reloc_code_real_names): Regenerate.
++	* elf32-mips.c (elf_mips16_howto_table_rel): Add R_MIPS16_TLS_*
++	entries.
++	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
++	mappings.
++	* elfn32-mips.c (elf_mips16_howto_table_rel,
++	elf_mips16_howto_table_rela): Add R_MIPS16_TLS_* entries.
++	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
++	mappings.
++	* elf64-mips.c (mips16_elf64_howto_table_rel,
++	mips16_elf64_howto_table_rela): Add R_MIPS16_TLS_* entries.
++	(mips16_reloc_map): Add BFD_RELOC_MIPS16_TLS_* to R_MIPS16_TLS_*
++	mappings.
++	* elfxx-mips.c (TLS_RELOC_P,mips16_reloc_p,
++	_bfd_mips_elf_check_relocs): Add cases for R_MIPS16_TLS_* relocations.
++	(tls_gd_reloc_p): Add R_MIPS16_TLS_GD case.
++	(tls_ldm_reloc_p): Add R_MIPS16_TLS_LDM case.
++	(tls_gottprel_reloc_p): Add R_MIPS16_TLS_GOTTPREL case.
++	(mips_elf_calculate_relocation): Add cases for R_MIPS16_TLS_*,
++	R_MIPS_TLS_DTPREL32/64, and R_MIPS_TLS_TPREL32/64 relocations.
++
++2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	Backport from mainline:
++
++	2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++		    Catherine Moore  <clm@codesourcery.com>
++		    Sandra Loosemore  <sandra@codesourcery.com>
++		    Richard Sandiford  <rdsandiford@googlemail.com>
++
++	* elfxx-mips.c (mips_elf_local_pic_function_p): Return true when
++	H is a MIPS16 function with a kept 32-bit stub. Update comments.
++	(mips_elf_get_la25_target): New function.
++	(mips_elf_add_la25_intro): Change to use mips_elf_get_la25_target().
++	(mips_elf_add_la25_stub): Move compute of use_trampoline_p down,
++	change to use mips_elf_get_la25_target().
++	(mips_elf_relocation_needs_la25_stub): Add target_is_16_bit_code_p
++	parameter, add switch case for R_MIPS16_26.
++	(mips_elf_calculate_relocation): Redirect relocation to point to the
++	LA25 stub if it exists, instead of the MIPS16 stub. Update arguments
++	of call to mips_elf_relocation_needs_la25_stub(), don't use la25 stub
++	for mips16->mips16 calls.
++	(_bfd_mips_elf_check_relocs): Update arguments of call to
++	mips_elf_relocation_needs_la25_stub().
++	(mips_elf_create_la25_stub): Change to use mips_elf_get_la25_target().
++
++2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	Backport from mainline:
++
++	2011-12-13  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	* elfxx-mips.c (mips_elf_calculate_relocation): Correct
++	R_MIPS16_HI16/R_MIPS16_LO16 handling of two cleared lower bits,
++	update comments.
++
++2011-12-10  David Daney  <david.daney@cavium.com>
++
++	Backport from mainline:
++
++	2011-12-10  David Daney  <david.daney@cavium.com>
++
++	* elfxx-mips.c (mips_elf_link_hash_table.rld_value): Remove.
++	(mips_elf_link_hash_table.rld_symbol): New field;
++	(MIPS_ELF_RLD_MAP_SIZE): New macro.
++	(_bfd_mips_elf_add_symbol_hook): Remember __rld_obj_head symbol
++	in rld_symbol.
++	(_bfd_mips_elf_create_dynamic_sections): Remember __rld_map symbol
++	in rld_symbol.
++	(_bfd_mips_elf_size_dynamic_sections): Set correct size for .rld_map.
++	(_bfd_mips_elf_finish_dynamic_symbol): Remove .rld_map handling.
++	(_bfd_mips_elf_finish_dynamic_sections): Use rld_symbol to
++	calculate DT_MIPS_RLD_MAP value.
++	(_bfd_mips_elf_link_hash_table_create): Initialize rld_symbol,
++	quit initializing rld_value.
++
++2011-12-03  Alan Modra  <amodra@gmail.com>
++
++	PR ld/13468
++	* elflink.c (bfd_elf_final_link): Don't segfault when checking
++	for DT_TEXTREL and .dynamic does not exist.
++
++2011-12-03  Alan Modra  <amodra@gmail.com>
++
++	PR ld/13470
++	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
++	change in 2011-07-01 commit.  Comment.
++	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
++
++2011-12-01  Mikael Pettersson  <mikpe@it.uu.se>
++
++	Apply mainline patches
++	* elf32-m68k.c (elf_m68k_check_relocs) <R_68K_8, R68K_16, R_68K_32>: For
++	non-SEC_ALLOC sections break before GOT and PLT accounting.
++
++2011-12-01  Hans-Peter Nilsson  <hp@axis.com>
++
++	Apply mainline patches
++	* elf32-cris.c (cris_elf_check_relocs) <plt accounting for
++	R_CRIS_8, R_CRIS_16, and R_CRIS_32>: Move early break for
++	non-SEC_ALLOC sections before GOT and PLT accounting.
++
++2011-11-21  Tristan Gingold  <gingold@adacore.com>
++
++	* configure.in: Bump version to 2.22.0
++	* Makefile.am (RELEASE): Unset.
++	* configure, Makefile.in: Regenerate.
++
+ 2011-11-21  Tristan Gingold  <gingold@adacore.com>
+ 
+ 	* configure.in: Bump version to 2.22
+diff --git a/bfd/bfd-in.h b/bfd/bfd-in.h
+index a477b49..7c5298a 100644
+--- a/bfd/bfd-in.h
++++ b/bfd/bfd-in.h
+@@ -295,11 +295,11 @@ typedef struct bfd_section *sec_ptr;
+     ? (sec)->rawsize : (sec)->size) / bfd_octets_per_byte (bfd))
+ 
+ /* Return TRUE if input section SEC has been discarded.  */
+-#define elf_discarded_section(sec)				\
++#define discarded_section(sec)					\
+   (!bfd_is_abs_section (sec)					\
+    && bfd_is_abs_section ((sec)->output_section)		\
+-   && (sec)->sec_info_type != ELF_INFO_TYPE_MERGE		\
+-   && (sec)->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
++   && (sec)->sec_info_type != SEC_INFO_TYPE_MERGE		\
++   && (sec)->sec_info_type != SEC_INFO_TYPE_JUST_SYMS)
+ 
+ /* Forward define.  */
+ struct stat;
+diff --git a/bfd/bfd-in2.h b/bfd/bfd-in2.h
+index 22fcdf6..34f9628 100644
+--- a/bfd/bfd-in2.h
++++ b/bfd/bfd-in2.h
+@@ -302,11 +302,11 @@ typedef struct bfd_section *sec_ptr;
+     ? (sec)->rawsize : (sec)->size) / bfd_octets_per_byte (bfd))
+ 
+ /* Return TRUE if input section SEC has been discarded.  */
+-#define elf_discarded_section(sec)				\
++#define discarded_section(sec)					\
+   (!bfd_is_abs_section (sec)					\
+    && bfd_is_abs_section ((sec)->output_section)		\
+-   && (sec)->sec_info_type != ELF_INFO_TYPE_MERGE		\
+-   && (sec)->sec_info_type != ELF_INFO_TYPE_JUST_SYMS)
++   && (sec)->sec_info_type != SEC_INFO_TYPE_MERGE		\
++   && (sec)->sec_info_type != SEC_INFO_TYPE_JUST_SYMS)
+ 
+ /* Forward define.  */
+ struct stat;
+@@ -1384,11 +1384,11 @@ typedef struct bfd_section
+ 
+   /* Type of sec_info information.  */
+   unsigned int sec_info_type:3;
+-#define ELF_INFO_TYPE_NONE      0
+-#define ELF_INFO_TYPE_STABS     1
+-#define ELF_INFO_TYPE_MERGE     2
+-#define ELF_INFO_TYPE_EH_FRAME  3
+-#define ELF_INFO_TYPE_JUST_SYMS 4
++#define SEC_INFO_TYPE_NONE      0
++#define SEC_INFO_TYPE_STABS     1
++#define SEC_INFO_TYPE_MERGE     2
++#define SEC_INFO_TYPE_EH_FRAME  3
++#define SEC_INFO_TYPE_JUST_SYMS 4
+ 
+   /* Nonzero if this section uses RELA relocations, rather than REL.  */
+   unsigned int use_rela_p:1;
+@@ -2780,6 +2780,15 @@ to compensate for the borrow when the low bits are added.  */
+ /* MIPS16 low 16 bits.  */
+   BFD_RELOC_MIPS16_LO16,
+ 
++/* MIPS16 TLS relocations  */
++  BFD_RELOC_MIPS16_TLS_GD,
++  BFD_RELOC_MIPS16_TLS_LDM,
++  BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
++  BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
++  BFD_RELOC_MIPS16_TLS_GOTTPREL,
++  BFD_RELOC_MIPS16_TLS_TPREL_HI16,
++  BFD_RELOC_MIPS16_TLS_TPREL_LO16,
++
+ /* Relocation against a MIPS literal section.  */
+   BFD_RELOC_MIPS_LITERAL,
+   BFD_RELOC_MICROMIPS_LITERAL,
+diff --git a/bfd/elf-bfd.h b/bfd/elf-bfd.h
+index d6e2ab2..2cfe2ba 100644
+--- a/bfd/elf-bfd.h
++++ b/bfd/elf-bfd.h
+@@ -1807,8 +1807,7 @@ extern void bfd_elf_set_group_contents
+   (bfd *, asection *, void *);
+ extern asection *_bfd_elf_check_kept_section
+   (asection *, struct bfd_link_info *);
+-extern void _bfd_elf_link_just_syms
+-  (asection *, struct bfd_link_info *);
++#define _bfd_elf_link_just_syms _bfd_generic_link_just_syms
+ extern void _bfd_elf_copy_link_hash_symbol_type
+   (bfd *, struct bfd_link_hash_entry *, struct bfd_link_hash_entry *);
+ extern bfd_boolean _bfd_elf_size_group_sections
+diff --git a/bfd/elf-eh-frame.c b/bfd/elf-eh-frame.c
+index 54142b2..7b5cf7a 100644
+--- a/bfd/elf-eh-frame.c
++++ b/bfd/elf-eh-frame.c
+@@ -491,7 +491,7 @@ _bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
+     return;
+ 
+   if (sec->size == 0
+-      || sec->sec_info_type != ELF_INFO_TYPE_NONE)
++      || sec->sec_info_type != SEC_INFO_TYPE_NONE)
+     {
+       /* This file does not contain .eh_frame information.  */
+       return;
+@@ -904,7 +904,7 @@ _bfd_elf_parse_eh_frame (bfd *abfd, struct bfd_link_info *info,
+   BFD_ASSERT (cie_count == num_cies);
+ 
+   elf_section_data (sec)->sec_info = sec_info;
+-  sec->sec_info_type = ELF_INFO_TYPE_EH_FRAME;
++  sec->sec_info_type = SEC_INFO_TYPE_EH_FRAME;
+   if (hdr_info->merge_cies)
+     {
+       sec_info->cies = local_cies;
+@@ -1137,7 +1137,7 @@ _bfd_elf_discard_section_eh_frame
+   struct eh_frame_hdr_info *hdr_info;
+   unsigned int ptr_size, offset;
+ 
+-  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
++  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
+     return FALSE;
+ 
+   sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
+@@ -1307,7 +1307,7 @@ _bfd_elf_eh_frame_section_offset (bfd *output_bfd ATTRIBUTE_UNUSED,
+   struct eh_frame_sec_info *sec_info;
+   unsigned int lo, hi, mid;
+ 
+-  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
++  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
+     return offset;
+   sec_info = (struct eh_frame_sec_info *) elf_section_data (sec)->sec_info;
+ 
+@@ -1395,7 +1395,7 @@ _bfd_elf_write_section_eh_frame (bfd *abfd,
+   unsigned int ptr_size;
+   struct eh_cie_fde *ent;
+ 
+-  if (sec->sec_info_type != ELF_INFO_TYPE_EH_FRAME)
++  if (sec->sec_info_type != SEC_INFO_TYPE_EH_FRAME)
+     /* FIXME: octets_per_byte.  */
+     return bfd_set_section_contents (abfd, sec->output_section, contents,
+ 				     sec->output_offset, sec->size);
+diff --git a/bfd/elf-m10200.c b/bfd/elf-m10200.c
+index a38f4db..d58c75c 100644
+--- a/bfd/elf-m10200.c
++++ b/bfd/elf-m10200.c
+@@ -401,7 +401,7 @@ mn10200_elf_relocate_section (output_bfd, info, input_bfd, input_section,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf-m10300.c b/bfd/elf-m10300.c
+index 8276a2f..876ff4a 100644
+--- a/bfd/elf-m10300.c
++++ b/bfd/elf-m10300.c
+@@ -1509,7 +1509,7 @@ mn10300_elf_relocate_section (bfd *output_bfd,
+ 	       h->root.root.root.string);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -2763,7 +2763,7 @@ mn10300_elf_relax_section (bfd *abfd,
+ 						      isym->st_name);
+ 
+ 	  if ((sym_sec->flags & SEC_MERGE)
+-	      && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
++	      && sym_sec->sec_info_type == SEC_INFO_TYPE_MERGE)
+ 	    {
+ 	      symval = isym->st_value;
+ 
+diff --git a/bfd/elf.c b/bfd/elf.c
+index aa40c33..9e23bee 100644
+--- a/bfd/elf.c
++++ b/bfd/elf.c
+@@ -3071,7 +3071,7 @@ assign_section_numbers (bfd *abfd, struct bfd_link_info *link_info)
+ 	      if (link_info != NULL)
+ 		{
+ 		  /* Check discarded linkonce section.  */
+-		  if (elf_discarded_section (s))
++		  if (discarded_section (s))
+ 		    {
+ 		      asection *kept;
+ 		      (*_bfd_error_handler)
+@@ -9390,7 +9390,7 @@ _bfd_elf_rela_local_sym (bfd *abfd,
+ 		+ sym->st_value);
+   if ((sec->flags & SEC_MERGE)
+       && ELF_ST_TYPE (sym->st_info) == STT_SECTION
+-      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
++      && sec->sec_info_type == SEC_INFO_TYPE_MERGE)
+     {
+       rel->r_addend =
+ 	_bfd_merged_section_offset (abfd, psec,
+@@ -9421,7 +9421,7 @@ _bfd_elf_rel_local_sym (bfd *abfd,
+ {
+   asection *sec = *psec;
+ 
+-  if (sec->sec_info_type != ELF_INFO_TYPE_MERGE)
++  if (sec->sec_info_type != SEC_INFO_TYPE_MERGE)
+     return sym->st_value + addend;
+ 
+   return _bfd_merged_section_offset (abfd, psec,
+@@ -9437,10 +9437,10 @@ _bfd_elf_section_offset (bfd *abfd,
+ {
+   switch (sec->sec_info_type)
+     {
+-    case ELF_INFO_TYPE_STABS:
++    case SEC_INFO_TYPE_STABS:
+       return _bfd_stab_section_offset (sec, elf_section_data (sec)->sec_info,
+ 				       offset);
+-    case ELF_INFO_TYPE_EH_FRAME:
++    case SEC_INFO_TYPE_EH_FRAME:
+       return _bfd_elf_eh_frame_section_offset (abfd, info, sec, offset);
+     default:
+       if ((sec->flags & SEC_ELF_REVERSE_COPY) != 0)
+diff --git a/bfd/elf32-arm.c b/bfd/elf32-arm.c
+index 1f6c1a0..9355f66 100644
+--- a/bfd/elf32-arm.c
++++ b/bfd/elf32-arm.c
+@@ -4485,7 +4485,7 @@ cortex_a8_erratum_scan (bfd *input_bfd,
+       if (elf_section_type (section) != SHT_PROGBITS
+           || (elf_section_flags (section) & SHF_EXECINSTR) == 0
+           || (section->flags & SEC_EXCLUDE) != 0
+-          || (section->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
++          || (section->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
+           || (section->output_section == bfd_abs_section_ptr))
+         continue;
+ 
+@@ -6556,7 +6556,7 @@ bfd_elf32_arm_vfp11_erratum_scan (bfd *abfd, struct bfd_link_info *link_info)
+       if (elf_section_type (sec) != SHT_PROGBITS
+           || (elf_section_flags (sec) & SHF_EXECINSTR) == 0
+           || (sec->flags & SEC_EXCLUDE) != 0
+-	  || sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS
++	  || sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
+ 	  || sec->output_section == bfd_abs_section_ptr
+           || strcmp (sec->name, VFP11_ERRATUM_VENEER_SECTION_NAME) == 0)
+         continue;
+@@ -10305,7 +10305,7 @@ elf32_arm_relocate_section (bfd *                  output_bfd,
+ 	  sym_type = h->type;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-avr.c b/bfd/elf32-avr.c
+index 6d20aef..97dc268 100644
+--- a/bfd/elf32-avr.c
++++ b/bfd/elf32-avr.c
+@@ -1189,7 +1189,7 @@ elf32_avr_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -1503,11 +1503,18 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
+        bfd_vma symval;
+        bfd_vma shrinked_insn_address;
+ 
++       if (isec->reloc_count == 0)
++	 continue;
++
+        shrinked_insn_address = (sec->output_section->vma
+                                 + sec->output_offset + addr - count);
+ 
+-       irelend = elf_section_data (isec)->relocs + isec->reloc_count;
+-       for (irel = elf_section_data (isec)->relocs;
++       irel = elf_section_data (isec)->relocs;
++       /* PR 12161: Read in the relocs for this section if necessary.  */
++       if (irel == NULL)
++	 irel = _bfd_elf_link_read_relocs (abfd, isec, NULL, NULL, FALSE);
++
++       for (irelend = irel + isec->reloc_count;
+             irel < irelend;
+             irel++)
+          {
+@@ -1564,6 +1571,9 @@ elf32_avr_relax_delete_bytes (bfd *abfd,
+ 	   /* else...Reference symbol is extern.  No need for adjusting
+ 	      the addend.  */
+ 	 }
++
++       if (elf_section_data (isec)->relocs == NULL)
++	 free (irelend - isec->reloc_count);
+      }
+   }
+ 
+diff --git a/bfd/elf32-bfin.c b/bfd/elf32-bfin.c
+index b112dfc..4941f40 100644
+--- a/bfd/elf32-bfin.c
++++ b/bfd/elf32-bfin.c
+@@ -1444,7 +1444,7 @@ bfin_relocate_section (bfd * output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -2663,7 +2663,7 @@ bfinfdpic_relocate_section (bfd * output_bfd,
+ 	  osec = sec;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -4429,7 +4429,7 @@ bfinfdpic_elf_discard_info (bfd *ibfd,
+ 
+   /* Account for relaxation of .eh_frame section.  */
+   for (s = ibfd->sections; s; s = s->next)
+-    if (s->sec_info_type == ELF_INFO_TYPE_EH_FRAME)
++    if (s->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
+       {
+ 	if (!_bfinfdpic_check_discarded_relocs (ibfd, s, info, &changed))
+ 	  return FALSE;
+diff --git a/bfd/elf32-cr16.c b/bfd/elf32-cr16.c
+index 0118131..38af05f 100644
+--- a/bfd/elf32-cr16.c
++++ b/bfd/elf32-cr16.c
+@@ -1431,7 +1431,7 @@ elf32_cr16_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+                                    unresolved_reloc, warned);
+         }
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-cr16c.c b/bfd/elf32-cr16c.c
+index ca2d7cb..109936b 100644
+--- a/bfd/elf32-cr16c.c
++++ b/bfd/elf32-cr16c.c
+@@ -723,7 +723,7 @@ elf32_cr16c_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-cris.c b/bfd/elf32-cris.c
+index 243a8ec..ec23f03 100644
+--- a/bfd/elf32-cris.c
++++ b/bfd/elf32-cris.c
+@@ -1180,7 +1180,7 @@ cris_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -3579,6 +3579,12 @@ cris_elf_check_relocs (bfd *abfd,
+ 		 sec,
+ 		 cris_elf_howto_table[r_type].name);
+ 	    }
++
++	  /* We don't need to handle relocs into sections not going into
++	     the "real" output.  */
++	  if ((sec->flags & SEC_ALLOC) == 0)
++	    break;
++
+ 	  if (h != NULL)
+ 	    {
+ 	      h->non_got_ref = 1;
+@@ -3608,11 +3614,6 @@ cris_elf_check_relocs (bfd *abfd,
+ 	  if (! info->shared)
+ 	    break;
+ 
+-	  /* We don't need to handle relocs into sections not going into
+-	     the "real" output.  */
+-	  if ((sec->flags & SEC_ALLOC) == 0)
+-	    break;
+-
+ 	  /* We may need to create a reloc section in the dynobj and made room
+ 	     for this reloc.  */
+ 	  if (sreloc == NULL)
+diff --git a/bfd/elf32-crx.c b/bfd/elf32-crx.c
+index d48932d..fd13447 100644
+--- a/bfd/elf32-crx.c
++++ b/bfd/elf32-crx.c
+@@ -873,7 +873,7 @@ elf32_crx_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-d10v.c b/bfd/elf32-d10v.c
+index 7d65395..e39a9b5 100644
+--- a/bfd/elf32-d10v.c
++++ b/bfd/elf32-d10v.c
+@@ -463,7 +463,7 @@ elf32_d10v_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-fr30.c b/bfd/elf32-fr30.c
+index 97b0d29..57be6ae 100644
+--- a/bfd/elf32-fr30.c
++++ b/bfd/elf32-fr30.c
+@@ -577,7 +577,7 @@ fr30_elf_relocate_section (output_bfd, info, input_bfd, input_section,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-frv.c b/bfd/elf32-frv.c
+index 7f3c4dd..513f811 100644
+--- a/bfd/elf32-frv.c
++++ b/bfd/elf32-frv.c
+@@ -2812,7 +2812,7 @@ elf32_frv_relocate_section (output_bfd, info, input_bfd, input_section,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -5678,7 +5678,7 @@ frvfdpic_elf_discard_info (bfd *ibfd,
+ 
+   /* Account for relaxation of .eh_frame section.  */
+   for (s = ibfd->sections; s; s = s->next)
+-    if (s->sec_info_type == ELF_INFO_TYPE_EH_FRAME)
++    if (s->sec_info_type == SEC_INFO_TYPE_EH_FRAME)
+       {
+ 	if (!_frvfdpic_check_discarded_relocs (ibfd, s, info, &changed))
+ 	  return FALSE;
+diff --git a/bfd/elf32-h8300.c b/bfd/elf32-h8300.c
+index 95d3983..ff1ee70 100644
+--- a/bfd/elf32-h8300.c
++++ b/bfd/elf32-h8300.c
+@@ -460,7 +460,7 @@ elf32_h8_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-hppa.c b/bfd/elf32-hppa.c
+index 7f0f2cb..044b6fa 100644
+--- a/bfd/elf32-hppa.c
++++ b/bfd/elf32-hppa.c
+@@ -1789,10 +1789,12 @@ elf32_hppa_hide_symbol (struct bfd_link_info *info,
+ 	}
+     }
+ 
+-  if (! hppa_elf_hash_entry (eh)->plabel)
++  /* STT_GNU_IFUNC symbol must go through PLT.  */
++  if (! hppa_elf_hash_entry (eh)->plabel
++      && eh->type != STT_GNU_IFUNC)
+     {
+       eh->needs_plt = 0;
+-      eh->plt = elf_hash_table (info)->init_plt_refcount;
++      eh->plt = elf_hash_table (info)->init_plt_offset;
+     }
+ }
+ 
+@@ -1814,6 +1816,13 @@ elf32_hppa_adjust_dynamic_symbol (struct bfd_link_info *info,
+   if (eh->type == STT_FUNC
+       || eh->needs_plt)
+     {
++      /* If the symbol is used by a plabel, we must allocate a PLT slot.
++	 The refcounts are not reliable when it has been hidden since
++	 hide_symbol can be called before the plabel flag is set.  */
++      if (hppa_elf_hash_entry (eh)->plabel
++	  && eh->plt.refcount <= 0)
++	eh->plt.refcount = 1;
++
+       if (eh->plt.refcount <= 0
+ 	  || (eh->def_regular
+ 	      && eh->root.type != bfd_link_hash_defweak
+@@ -3340,10 +3349,16 @@ final_link_relocate (asection *input_section,
+       switch (r_type)
+ 	{
+ 	  case R_PARISC_DLTIND21L:
++	  case R_PARISC_TLS_GD21L:
++	  case R_PARISC_TLS_LDM21L:
++	  case R_PARISC_TLS_IE21L:
+ 	    r_type = R_PARISC_DPREL21L;
+ 	    break;
+ 
+ 	  case R_PARISC_DLTIND14R:
++	  case R_PARISC_TLS_GD14R:
++	  case R_PARISC_TLS_LDM14R:
++	  case R_PARISC_TLS_IE14R:
+ 	    r_type = R_PARISC_DPREL14R;
+ 	    break;
+ 
+@@ -3409,53 +3424,48 @@ final_link_relocate (asection *input_section,
+     case R_PARISC_DPREL21L:
+     case R_PARISC_DPREL14R:
+     case R_PARISC_DPREL14F:
+-    case R_PARISC_TLS_GD21L:
+-    case R_PARISC_TLS_LDM21L:
+-    case R_PARISC_TLS_IE21L:
+       /* Convert instructions that use the linkage table pointer (r19) to
+ 	 instructions that use the global data pointer (dp).  This is the
+ 	 most efficient way of using PIC code in an incomplete executable,
+ 	 but the user must follow the standard runtime conventions for
+ 	 accessing data for this to work.  */
+-      if (orig_r_type == R_PARISC_DLTIND21L
+-	  || (!info->shared
+-	      && (r_type == R_PARISC_TLS_GD21L
+-		  || r_type == R_PARISC_TLS_LDM21L
+-		  || r_type == R_PARISC_TLS_IE21L)))
++      if (orig_r_type != r_type)
+ 	{
+-	  /* Convert addil instructions if the original reloc was a
+-	     DLTIND21L.  GCC sometimes uses a register other than r19 for
+-	     the operation, so we must convert any addil instruction
+-	     that uses this relocation.  */
+-	  if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
+-	    insn = ADDIL_DP;
+-	  else
+-	    /* We must have a ldil instruction.  It's too hard to find
+-	       and convert the associated add instruction, so issue an
+-	       error.  */
+-	    (*_bfd_error_handler)
+-	      (_("%B(%A+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
+-	       input_bfd,
+-	       input_section,
+-	       (long) offset,
+-	       howto->name,
+-	       insn);
+-	}
+-      else if (orig_r_type == R_PARISC_DLTIND14F)
+-	{
+-	  /* This must be a format 1 load/store.  Change the base
+-	     register to dp.  */
+-	  insn = (insn & 0xfc1ffff) | (27 << 21);
++	  if (r_type == R_PARISC_DPREL21L)
++	    {
++	      /* GCC sometimes uses a register other than r19 for the
++		 operation, so we must convert any addil instruction
++		 that uses this relocation.  */
++	      if ((insn & 0xfc000000) == ((int) OP_ADDIL << 26))
++		insn = ADDIL_DP;
++	      else
++		/* We must have a ldil instruction.  It's too hard to find
++		   and convert the associated add instruction, so issue an
++		   error.  */
++		(*_bfd_error_handler)
++		  (_("%B(%A+0x%lx): %s fixup for insn 0x%x is not supported in a non-shared link"),
++		   input_bfd,
++		   input_section,
++		   (long) offset,
++		   howto->name,
++		   insn);
++	    }
++	  else if (r_type == R_PARISC_DPREL14F)
++	    {
++	      /* This must be a format 1 load/store.  Change the base
++		 register to dp.  */
++	      insn = (insn & 0xfc1ffff) | (27 << 21);
++	    }
+ 	}
+ 
+-    /* For all the DP relative relocations, we need to examine the symbol's
+-       section.  If it has no section or if it's a code section, then
+-       "data pointer relative" makes no sense.  In that case we don't
+-       adjust the "value", and for 21 bit addil instructions, we change the
+-       source addend register from %dp to %r0.  This situation commonly
+-       arises for undefined weak symbols and when a variable's "constness"
+-       is declared differently from the way the variable is defined.  For
+-       instance: "extern int foo" with foo defined as "const int foo".  */
++      /* For all the DP relative relocations, we need to examine the symbol's
++	 section.  If it has no section or if it's a code section, then
++	 "data pointer relative" makes no sense.  In that case we don't
++	 adjust the "value", and for 21 bit addil instructions, we change the
++	 source addend register from %dp to %r0.  This situation commonly
++	 arises for undefined weak symbols and when a variable's "constness"
++	 is declared differently from the way the variable is defined.  For
++	 instance: "extern int foo" with foo defined as "const int foo".  */
+       if (sym_sec == NULL || (sym_sec->flags & SEC_CODE) != 0)
+ 	{
+ 	  if ((insn & ((0x3f << 26) | (0x1f << 21)))
+@@ -3472,6 +3482,9 @@ final_link_relocate (asection *input_section,
+     case R_PARISC_DLTIND21L:
+     case R_PARISC_DLTIND14R:
+     case R_PARISC_DLTIND14F:
++    case R_PARISC_TLS_GD21L:
++    case R_PARISC_TLS_LDM21L:
++    case R_PARISC_TLS_IE21L:
+     case R_PARISC_TLS_GD14R:
+     case R_PARISC_TLS_LDM14R:
+     case R_PARISC_TLS_IE14R:
+@@ -3728,7 +3741,7 @@ elf32_hppa_relocate_section (bfd *output_bfd,
+ 	  hh = hppa_elf_hash_entry (eh);
+ 	}
+ 
+-      if (sym_sec != NULL && elf_discarded_section (sym_sec))
++      if (sym_sec != NULL && discarded_section (sym_sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rela, relend,
+ 					 elf_hppa_howto_table + r_type,
+diff --git a/bfd/elf32-i370.c b/bfd/elf32-i370.c
+index 8082927..516511f 100644
+--- a/bfd/elf32-i370.c
++++ b/bfd/elf32-i370.c
+@@ -1138,7 +1138,7 @@ i370_elf_relocate_section (bfd *output_bfd,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
+index d518d01..b925ca6 100644
+--- a/bfd/elf32-i386.c
++++ b/bfd/elf32-i386.c
+@@ -3178,7 +3178,7 @@ elf_i386_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -4846,7 +4846,7 @@ elf_i386_finish_dynamic_sections (bfd *output_bfd,
+ 			     + PLT_FDE_START_OFFSET);
+ 	}
+       if (htab->plt_eh_frame->sec_info_type
+-	  == ELF_INFO_TYPE_EH_FRAME)
++	  == SEC_INFO_TYPE_EH_FRAME)
+ 	{
+ 	  if (! _bfd_elf_write_section_eh_frame (output_bfd, info,
+ 						 htab->plt_eh_frame,
+diff --git a/bfd/elf32-i860.c b/bfd/elf32-i860.c
+index 00c8ca7..88f4265 100644
+--- a/bfd/elf32-i860.c
++++ b/bfd/elf32-i860.c
+@@ -1128,7 +1128,7 @@ elf32_i860_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-ip2k.c b/bfd/elf32-ip2k.c
+index 0a251b8..43c7b1c 100644
+--- a/bfd/elf32-ip2k.c
++++ b/bfd/elf32-ip2k.c
+@@ -1436,7 +1436,7 @@ ip2k_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-iq2000.c b/bfd/elf32-iq2000.c
+index 63ef3dc..3954616 100644
+--- a/bfd/elf32-iq2000.c
++++ b/bfd/elf32-iq2000.c
+@@ -633,7 +633,7 @@ iq2000_elf_relocate_section (bfd *		     output_bfd ATTRIBUTE_UNUSED,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-lm32.c b/bfd/elf32-lm32.c
+index 07add20..a2b1003 100644
+--- a/bfd/elf32-lm32.c
++++ b/bfd/elf32-lm32.c
+@@ -893,7 +893,7 @@ lm32_elf_relocate_section (bfd *output_bfd,
+ 	  name = h->root.root.string;
+         }
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -2372,7 +2372,7 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,
+                           /* Don't generate entries for weak symbols.  */
+                           if (!h || (h && h->root.type != bfd_link_hash_undefweak))
+                             {
+-                              if (!elf_discarded_section (s) && !((bfd_get_section_flags (ibfd, s) & SEC_ALLOC) == 0))
++                              if (!discarded_section (s) && !((bfd_get_section_flags (ibfd, s) & SEC_ALLOC) == 0))
+                                 {
+                                   switch (ELF32_R_TYPE (internal_relocs->r_info))
+                                     {
+@@ -2394,7 +2394,7 @@ lm32_elf_size_dynamic_sections (bfd *output_bfd,
+                                   if (!strcmp (current->name, h->root.root.string))
+                                     break;
+                                 }
+-                              if (!current && !elf_discarded_section (s) && (bfd_get_section_flags (ibfd, s) & SEC_ALLOC))
++                              if (!current && !discarded_section (s) && (bfd_get_section_flags (ibfd, s) & SEC_ALLOC))
+                                 {
+                                   /* Will this have an entry in the GOT.  */
+                                   if (ELF32_R_TYPE (internal_relocs->r_info) == R_LM32_16_GOT)
+diff --git a/bfd/elf32-m32c.c b/bfd/elf32-m32c.c
+index cf7ad99..bcdb55d 100644
+--- a/bfd/elf32-m32c.c
++++ b/bfd/elf32-m32c.c
+@@ -434,7 +434,7 @@ m32c_elf_relocate_section
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-m32r.c b/bfd/elf32-m32r.c
+index 51ef61e..b151a8a 100644
+--- a/bfd/elf32-m32r.c
++++ b/bfd/elf32-m32r.c
+@@ -2616,7 +2616,7 @@ m32r_elf_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-m68hc1x.c b/bfd/elf32-m68hc1x.c
+index 961dce4..4b9a1c0 100644
+--- a/bfd/elf32-m68hc1x.c
++++ b/bfd/elf32-m68hc1x.c
+@@ -970,7 +970,7 @@ elf32_m68hc11_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	  is_far = (h && (h->other & STO_M68HC12_FAR));
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-m68k.c b/bfd/elf32-m68k.c
+index 612525c..518a41a 100644
+--- a/bfd/elf32-m68k.c
++++ b/bfd/elf32-m68k.c
+@@ -2816,6 +2816,11 @@ elf_m68k_check_relocs (abfd, info, sec, relocs)
+ 	case R_68K_8:
+ 	case R_68K_16:
+ 	case R_68K_32:
++	  /* We don't need to handle relocs into sections not going into
++	     the "real" output.  */
++	  if ((sec->flags & SEC_ALLOC) == 0)
++	      break;
++
+ 	  if (h != NULL)
+ 	    {
+ 	      /* Make sure a plt entry is created for this symbol if it
+@@ -2829,8 +2834,7 @@ elf_m68k_check_relocs (abfd, info, sec, relocs)
+ 
+ 	  /* If we are creating a shared library, we need to copy the
+ 	     reloc into the shared library.  */
+-	  if (info->shared
+-	      && (sec->flags & SEC_ALLOC) != 0)
++	  if (info->shared)
+ 	    {
+ 	      /* When creating a shared object, we must copy these
+ 		 reloc types into the output file.  We create a reloc
+@@ -3713,7 +3717,7 @@ elf_m68k_relocate_section (output_bfd, info, input_bfd, input_section,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-mcore.c b/bfd/elf32-mcore.c
+index 31cc095..02aef53 100644
+--- a/bfd/elf32-mcore.c
++++ b/bfd/elf32-mcore.c
+@@ -466,7 +466,7 @@ mcore_elf_relocate_section (bfd * output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-mep.c b/bfd/elf32-mep.c
+index 6fecb25..e5104b3 100644
+--- a/bfd/elf32-mep.c
++++ b/bfd/elf32-mep.c
+@@ -500,7 +500,7 @@ mep_elf_relocate_section
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-mips.c b/bfd/elf32-mips.c
+index fd3d4ba..61e8b45 100644
+--- a/bfd/elf32-mips.c
++++ b/bfd/elf32-mips.c
+@@ -830,6 +830,111 @@ static reloc_howto_type elf_mips16_howto_table_rel[] =
+ 	 0x0000ffff,		/* src_mask */
+ 	 0x0000ffff,	        /* dst_mask */
+ 	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS general dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_GD,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GD",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_LDM,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_LDM",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GOTTPREL",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_HI16", /* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_LO16", /* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
+ };
+ 
+ static reloc_howto_type elf_micromips_howto_table_rel[] =
+@@ -1796,6 +1901,15 @@ static const struct elf_reloc_map mips16_reloc_map[] =
+   { BFD_RELOC_MIPS16_CALL16, R_MIPS16_CALL16 - R_MIPS16_min },
+   { BFD_RELOC_MIPS16_HI16_S, R_MIPS16_HI16 - R_MIPS16_min },
+   { BFD_RELOC_MIPS16_LO16, R_MIPS16_LO16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
++    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
++    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
+ };
+ 
+ static const struct elf_reloc_map micromips_reloc_map[] =
+diff --git a/bfd/elf32-moxie.c b/bfd/elf32-moxie.c
+index 8463599..c340826 100644
+--- a/bfd/elf32-moxie.c
++++ b/bfd/elf32-moxie.c
+@@ -250,7 +250,7 @@ moxie_elf_relocate_section (bfd *output_bfd,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-msp430.c b/bfd/elf32-msp430.c
+index 9a5fb2a..2fa70d9 100644
+--- a/bfd/elf32-msp430.c
++++ b/bfd/elf32-msp430.c
+@@ -454,7 +454,7 @@ elf32_msp430_relocate_section (bfd * output_bfd ATTRIBUTE_UNUSED,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-mt.c b/bfd/elf32-mt.c
+index 1be5d00..b87995e 100644
+--- a/bfd/elf32-mt.c
++++ b/bfd/elf32-mt.c
+@@ -354,7 +354,7 @@ mt_elf_relocate_section
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-openrisc.c b/bfd/elf32-openrisc.c
+index ada738e..e441f4d 100644
+--- a/bfd/elf32-openrisc.c
++++ b/bfd/elf32-openrisc.c
+@@ -373,7 +373,7 @@ openrisc_elf_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-ppc.c b/bfd/elf32-ppc.c
+index 0c25c3e..d3925af 100644
+--- a/bfd/elf32-ppc.c
++++ b/bfd/elf32-ppc.c
+@@ -2987,10 +2987,6 @@ ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,
+   edir->elf.needs_plt |= eind->elf.needs_plt;
+   edir->elf.pointer_equality_needed |= eind->elf.pointer_equality_needed;
+ 
+-  /* If we were called to copy over info for a weak sym, that's all.  */
+-  if (eind->elf.root.type != bfd_link_hash_indirect)
+-    return;
+-
+   if (eind->dyn_relocs != NULL)
+     {
+       if (edir->dyn_relocs != NULL)
+@@ -3022,6 +3018,16 @@ ppc_elf_copy_indirect_symbol (struct bfd_link_info *info,
+       eind->dyn_relocs = NULL;
+     }
+ 
++  /* If we were called to copy over info for a weak sym, that's all.
++     You might think dyn_relocs need not be copied over;  After all,
++     both syms will be dynamic or both non-dynamic so we're just
++     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
++     code in ppc_elf_adjust_dynamic_symbol needs to check for
++     dyn_relocs in read-only sections, and it does so on what is the
++     DIR sym here.  */
++  if (eind->elf.root.type != bfd_link_hash_indirect)
++    return;
++
+   /* Copy over the GOT refcount entries that we may have already seen to
+      the symbol which just became indirect.  */
+   edir->elf.got.refcount += eind->elf.got.refcount;
+@@ -6225,7 +6231,7 @@ ppc_elf_relax_section (bfd *abfd,
+ 	 attribute for a code section, and we are only looking at
+ 	 branches.  However, implement it correctly here as a
+ 	 reference for other target relax_section functions.  */
+-      if (0 && tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
++      if (0 && tsec->sec_info_type == SEC_INFO_TYPE_MERGE)
+ 	{
+ 	  /* At this stage in linking, no SEC_MERGE symbol has been
+ 	     adjusted, so all references to such symbols need to be
+@@ -6880,7 +6886,7 @@ ppc_elf_relocate_section (bfd *output_bfd,
+ 	  sym_name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	{
+ 	  /* For relocs against symbols from removed linkonce sections,
+ 	     or sections discarded by a linker script, we just want the
+@@ -9048,7 +9054,7 @@ ppc_elf_finish_dynamic_sections (bfd *output_bfd,
+       BFD_ASSERT ((bfd_vma) ((p + 3 - htab->glink_eh_frame->contents) & -4)
+ 		  == htab->glink_eh_frame->size);
+ 
+-      if (htab->glink_eh_frame->sec_info_type == ELF_INFO_TYPE_EH_FRAME
++      if (htab->glink_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME
+ 	  && !_bfd_elf_write_section_eh_frame (output_bfd, info,
+ 					       htab->glink_eh_frame,
+ 					       htab->glink_eh_frame->contents))
+diff --git a/bfd/elf32-rx.c b/bfd/elf32-rx.c
+index f049f6e..32820b4 100644
+--- a/bfd/elf32-rx.c
++++ b/bfd/elf32-rx.c
+@@ -510,7 +510,7 @@ rx_elf_relocate_section
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -1588,7 +1588,7 @@ rx_offset_for_reloc (bfd *                    abfd,
+ 	  if (ssec)
+ 	    {
+ 	      if ((ssec->flags & SEC_MERGE)
+-		  && ssec->sec_info_type == ELF_INFO_TYPE_MERGE)
++		  && ssec->sec_info_type == SEC_INFO_TYPE_MERGE)
+ 		symval = _bfd_merged_section_offset (abfd, & ssec,
+ 						     elf_section_data (ssec)->sec_info,
+ 						     symval);
+diff --git a/bfd/elf32-s390.c b/bfd/elf32-s390.c
+index 98437d0..11fb072 100644
+--- a/bfd/elf32-s390.c
++++ b/bfd/elf32-s390.c
+@@ -2282,7 +2282,7 @@ elf_s390_relocate_section (output_bfd, info, input_bfd, input_section,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-score.c b/bfd/elf32-score.c
+index b437624..ef849aa 100644
+--- a/bfd/elf32-score.c
++++ b/bfd/elf32-score.c
+@@ -2672,7 +2672,7 @@ s3_bfd_score_elf_relocate_section (bfd *output_bfd,
+             }
+         }
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-score7.c b/bfd/elf32-score7.c
+index 3e98bfc..3d228f3 100644
+--- a/bfd/elf32-score7.c
++++ b/bfd/elf32-score7.c
+@@ -2443,7 +2443,7 @@ s7_bfd_score_elf_relocate_section (bfd *output_bfd,
+             }
+         }
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-sh.c b/bfd/elf32-sh.c
+index ca2c4af..e56c3b5 100644
+--- a/bfd/elf32-sh.c
++++ b/bfd/elf32-sh.c
+@@ -4048,7 +4048,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	      _("Unexpected STO_SH5_ISA32 on local symbol is not handled"),
+ 	      input_bfd, input_section, rel->r_offset));
+ 
+-	  if (sec != NULL && elf_discarded_section (sec))
++	  if (sec != NULL && discarded_section (sec))
+ 	    /* Handled below.  */
+ 	    ;
+ 	  else if (info->relocatable)
+@@ -4236,7 +4236,7 @@ sh_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-spu.c b/bfd/elf32-spu.c
+index ae3ed10..40a9da2 100644
+--- a/bfd/elf32-spu.c
++++ b/bfd/elf32-spu.c
+@@ -4895,7 +4895,7 @@ spu_elf_relocate_section (bfd *output_bfd,
+ 	  sym_name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-tic6x.c b/bfd/elf32-tic6x.c
+index 19287fe..a879d3c 100644
+--- a/bfd/elf32-tic6x.c
++++ b/bfd/elf32-tic6x.c
+@@ -2334,7 +2334,7 @@ elf32_tic6x_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -4018,6 +4018,9 @@ elf32_tic6x_merge_private_bfd_data (bfd *ibfd, bfd *obfd)
+   if (!_bfd_generic_verify_endian_match (ibfd, obfd))
+     return FALSE;
+ 
++  if (! is_tic6x_elf (ibfd) || ! is_tic6x_elf (obfd))
++    return TRUE;
++
+   if (!elf32_tic6x_merge_attributes (ibfd, obfd))
+     return FALSE;
+ 
+diff --git a/bfd/elf32-tilepro.c b/bfd/elf32-tilepro.c
+index f2aed9c..a4e565d 100644
+--- a/bfd/elf32-tilepro.c
++++ b/bfd/elf32-tilepro.c
+@@ -2594,7 +2594,7 @@ tilepro_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-v850.c b/bfd/elf32-v850.c
+index 9e6f77d..0fbe080 100644
+--- a/bfd/elf32-v850.c
++++ b/bfd/elf32-v850.c
+@@ -2093,7 +2093,7 @@ v850_elf_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-vax.c b/bfd/elf32-vax.c
+index 643381c..fc3cb7c 100644
+--- a/bfd/elf32-vax.c
++++ b/bfd/elf32-vax.c
+@@ -1450,7 +1450,7 @@ elf_vax_relocate_section (bfd *output_bfd,
+ 	    relocation = 0;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-xc16x.c b/bfd/elf32-xc16x.c
+index 11d9840..00c7841 100644
+--- a/bfd/elf32-xc16x.c
++++ b/bfd/elf32-xc16x.c
+@@ -381,7 +381,7 @@ elf32_xc16x_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	{
+ 	  /* For relocs against symbols from removed linkonce sections,
+ 	     or sections discarded by a linker script, we just want the
+diff --git a/bfd/elf32-xstormy16.c b/bfd/elf32-xstormy16.c
+index 6141783..86e1d5b 100644
+--- a/bfd/elf32-xstormy16.c
++++ b/bfd/elf32-xstormy16.c
+@@ -825,7 +825,7 @@ xstormy16_elf_relocate_section (bfd *                   output_bfd ATTRIBUTE_UNU
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf32-xtensa.c b/bfd/elf32-xtensa.c
+index c6e4fb4..5a51eae 100644
+--- a/bfd/elf32-xtensa.c
++++ b/bfd/elf32-xtensa.c
+@@ -1712,7 +1712,7 @@ elf_xtensa_size_dynamic_sections (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	    continue;
+ 	  for (s = abfd->sections; s != NULL; s = s->next)
+ 	    {
+-	      if (! elf_discarded_section (s)
++	      if (! discarded_section (s)
+ 		  && xtensa_is_littable_section (s)
+ 		  && s != spltlittbl)
+ 		sgotloc->size += s->size;
+@@ -2656,7 +2656,7 @@ elf_xtensa_relocate_section (bfd *output_bfd,
+ 	  sym_type = h->type;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -8960,9 +8960,9 @@ relax_section (bfd *abfd, asection *sec, struct bfd_link_info *link_info)
+ 	     that here and adjust things accordingly.  */
+ 	  if (! elf_xtensa_ignore_discarded_relocs (sec)
+ 	      && elf_xtensa_action_discarded (sec) == PRETEND
+-	      && sec->sec_info_type != ELF_INFO_TYPE_STABS
++	      && sec->sec_info_type != SEC_INFO_TYPE_STABS
+ 	      && target_sec != NULL
+-	      && elf_discarded_section (target_sec))
++	      && discarded_section (target_sec))
+ 	    {
+ 	      /* It would be natural to call _bfd_elf_check_kept_section
+ 		 here, but it's not exported from elflink.c.  It's also a
+diff --git a/bfd/elf64-alpha.c b/bfd/elf64-alpha.c
+index 6076709..ddb1cd7 100644
+--- a/bfd/elf64-alpha.c
++++ b/bfd/elf64-alpha.c
+@@ -4106,7 +4106,7 @@ elf64_alpha_relocate_section_r (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	  sec = h->root.u.def.section;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend,
+ 					 elf64_alpha_howto_table + r_type,
+@@ -4263,7 +4263,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	     unless it has been done already.  */
+ 	  if ((sec->flags & SEC_MERGE)
+ 	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
+-	      && sec->sec_info_type == ELF_INFO_TYPE_MERGE
++	      && sec->sec_info_type == SEC_INFO_TYPE_MERGE
+ 	      && gotent
+ 	      && !gotent->reloc_xlated)
+ 	    {
+@@ -4315,7 +4315,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	  gotent = h->got_entries;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -4717,7 +4717,7 @@ elf64_alpha_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 
+ 	    if (r_symndx < symtab_hdr->sh_info
+ 		&& sec != NULL && howto->pc_relative
+-		&& elf_discarded_section (sec))
++		&& discarded_section (sec))
+ 	      break;
+ 
+ 	    if (h != NULL)
+diff --git a/bfd/elf64-hppa.c b/bfd/elf64-hppa.c
+index 057a92d..9d2dfcf 100644
+--- a/bfd/elf64-hppa.c
++++ b/bfd/elf64-hppa.c
+@@ -3919,7 +3919,7 @@ elf64_hppa_relocate_section (bfd *output_bfd,
+             }
+ 	}
+ 
+-      if (sym_sec != NULL && elf_discarded_section (sym_sec))
++      if (sym_sec != NULL && discarded_section (sym_sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf64-mips.c b/bfd/elf64-mips.c
+index 3feb1bb..bdd0c19 100644
+--- a/bfd/elf64-mips.c
++++ b/bfd/elf64-mips.c
+@@ -1590,6 +1590,111 @@ static reloc_howto_type mips16_elf64_howto_table_rel[] =
+ 	 0x0000ffff,		/* src_mask */
+ 	 0x0000ffff,		/* dst_mask */
+ 	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS general dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_GD,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GD",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_LDM,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_LDM",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GOTTPREL",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_HI16", /* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_LO16", /* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
+ };
+ 
+ static reloc_howto_type mips16_elf64_howto_table_rela[] =
+@@ -1686,6 +1791,111 @@ static reloc_howto_type mips16_elf64_howto_table_rela[] =
+ 	 0x0000ffff,		/* src_mask */
+ 	 0x0000ffff,		/* dst_mask */
+ 	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS general dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_GD,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GD",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_LDM,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_LDM",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GOTTPREL",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_HI16", /* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_LO16", /* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
+ };
+ 
+ static reloc_howto_type micromips_elf64_howto_table_rel[] =
+@@ -2908,6 +3118,15 @@ static const struct elf_reloc_map mips16_reloc_map[] =
+   { BFD_RELOC_MIPS16_CALL16, R_MIPS16_CALL16 - R_MIPS16_min },
+   { BFD_RELOC_MIPS16_HI16_S, R_MIPS16_HI16 - R_MIPS16_min },
+   { BFD_RELOC_MIPS16_LO16, R_MIPS16_LO16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
++    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
++    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
+ };
+ 
+ static const struct elf_reloc_map micromips_reloc_map[] =
+diff --git a/bfd/elf64-mmix.c b/bfd/elf64-mmix.c
+index ecc9ad0..9cc407f 100644
+--- a/bfd/elf64-mmix.c
++++ b/bfd/elf64-mmix.c
+@@ -1475,7 +1475,7 @@ mmix_elf_relocate_section (output_bfd, info, input_bfd, input_section,
+ 	  name = h->root.root.string;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf64-ppc.c b/bfd/elf64-ppc.c
+index 93d1314..52e9ce9 100644
+--- a/bfd/elf64-ppc.c
++++ b/bfd/elf64-ppc.c
+@@ -4435,10 +4435,6 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,
+   edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
+   edir->elf.needs_plt |= eind->elf.needs_plt;
+ 
+-  /* If we were called to copy over info for a weak sym, that's all.  */
+-  if (eind->elf.root.type != bfd_link_hash_indirect)
+-    return;
+-
+   /* Copy over any dynamic relocs we may have on the indirect sym.  */
+   if (eind->dyn_relocs != NULL)
+     {
+@@ -4471,6 +4467,16 @@ ppc64_elf_copy_indirect_symbol (struct bfd_link_info *info,
+       eind->dyn_relocs = NULL;
+     }
+ 
++  /* If we were called to copy over info for a weak sym, that's all.
++     You might think dyn_relocs need not be copied over;  After all,
++     both syms will be dynamic or both non-dynamic so we're just
++     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
++     code in ppc64_elf_adjust_dynamic_symbol needs to check for
++     dyn_relocs in read-only sections, and it does so on what is the
++     DIR sym here.  */
++  if (eind->elf.root.type != bfd_link_hash_indirect)
++    return;
++
+   /* Copy over got entries that we may have already seen to the
+      symbol which just became indirect.  */
+   if (eind->elf.got.glist != NULL)
+@@ -6846,7 +6852,7 @@ adjust_opd_syms (struct elf_link_hash_entry *h, void *inf ATTRIBUTE_UNUSED)
+ 	  if (dsec == NULL)
+ 	    {
+ 	      for (dsec = sym_sec->owner->sections; dsec; dsec = dsec->next)
+-		if (elf_discarded_section (dsec))
++		if (discarded_section (dsec))
+ 		  {
+ 		    ppc64_elf_tdata (sym_sec->owner)->deleted_section = dsec;
+ 		    break;
+@@ -7027,7 +7033,7 @@ ppc64_elf_edit_opd (struct bfd_link_info *info, bfd_boolean non_overlapping)
+       if (sec == NULL || sec->size == 0)
+ 	continue;
+ 
+-      if (sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
++      if (sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
+ 	continue;
+ 
+       if (sec->output_section == bfd_abs_section_ptr)
+@@ -8071,8 +8077,8 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
+       toc = bfd_get_section_by_name (ibfd, ".toc");
+       if (toc == NULL
+ 	  || toc->size == 0
+-	  || toc->sec_info_type == ELF_INFO_TYPE_JUST_SYMS
+-	  || elf_discarded_section (toc))
++	  || toc->sec_info_type == SEC_INFO_TYPE_JUST_SYMS
++	  || discarded_section (toc))
+ 	continue;
+ 
+       toc_relocs = NULL;
+@@ -8085,7 +8091,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
+       for (sec = ibfd->sections; sec != NULL; sec = sec->next)
+ 	{
+ 	  if (sec->reloc_count == 0
+-	      || !elf_discarded_section (sec)
++	      || !discarded_section (sec)
+ 	      || get_opd_info (sec)
+ 	      || (sec->flags & SEC_ALLOC) == 0
+ 	      || (sec->flags & SEC_DEBUGGING) != 0)
+@@ -8195,7 +8201,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
+ 		goto error_ret;
+ 
+ 	      if (sym_sec == NULL
+-		  || elf_discarded_section (sym_sec))
++		  || discarded_section (sym_sec))
+ 		continue;
+ 
+ 	      if (!SYMBOL_CALLS_LOCAL (info, h))
+@@ -8275,7 +8281,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
+ 	  int repeat;
+ 
+ 	  if (sec->reloc_count == 0
+-	      || elf_discarded_section (sec)
++	      || discarded_section (sec)
+ 	      || get_opd_info (sec)
+ 	      || (sec->flags & SEC_ALLOC) == 0
+ 	      || (sec->flags & SEC_DEBUGGING) != 0)
+@@ -8497,7 +8503,7 @@ ppc64_elf_edit_toc (struct bfd_link_info *info)
+ 	  for (sec = ibfd->sections; sec != NULL; sec = sec->next)
+ 	    {
+ 	      if (sec->reloc_count == 0
+-		  || elf_discarded_section (sec))
++		  || discarded_section (sec))
+ 		continue;
+ 
+ 	      relstart = _bfd_elf_link_read_relocs (ibfd, sec, NULL, NULL,
+@@ -12030,7 +12036,7 @@ ppc64_elf_relocate_section (bfd *output_bfd,
+ 	}
+       h = (struct ppc_link_hash_entry *) h_elf;
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend,
+ 					 ppc64_elf_howto_table[r_type],
+@@ -13859,7 +13865,7 @@ ppc64_elf_finish_dynamic_sections (bfd *output_bfd,
+ 
+ 
+   if (htab->glink_eh_frame != NULL
+-      && htab->glink_eh_frame->sec_info_type == ELF_INFO_TYPE_EH_FRAME
++      && htab->glink_eh_frame->sec_info_type == SEC_INFO_TYPE_EH_FRAME
+       && !_bfd_elf_write_section_eh_frame (output_bfd, info,
+ 					   htab->glink_eh_frame,
+ 					   htab->glink_eh_frame->contents))
+diff --git a/bfd/elf64-s390.c b/bfd/elf64-s390.c
+index 9884da0..e9138a6 100644
+--- a/bfd/elf64-s390.c
++++ b/bfd/elf64-s390.c
+@@ -2270,7 +2270,7 @@ elf_s390_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf64-sh64.c b/bfd/elf64-sh64.c
+index bbef2a2..d8f2120 100644
+--- a/bfd/elf64-sh64.c
++++ b/bfd/elf64-sh64.c
+@@ -1514,7 +1514,7 @@ sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	      _("Unexpected STO_SH5_ISA32 on local symbol is not handled"),
+ 	      input_bfd, input_section, rel->r_offset));
+ 
+-	  if (sec != NULL && elf_discarded_section (sec))
++	  if (sec != NULL && discarded_section (sec))
+ 	    /* Handled below.  */
+ 	    ;
+ 	  else if (info->relocatable)
+@@ -1657,7 +1657,7 @@ sh_elf64_relocate_section (bfd *output_bfd ATTRIBUTE_UNUSED,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
+index 3a2444b..9d826e7 100644
+--- a/bfd/elf64-x86-64.c
++++ b/bfd/elf64-x86-64.c
+@@ -3062,7 +3062,7 @@ elf_x86_64_relocate_section (bfd *output_bfd,
+ 				   unresolved_reloc, warned);
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -3460,7 +3460,6 @@ elf_x86_64_relocate_section (bfd *output_bfd,
+ 	case R_X86_64_PC16:
+ 	case R_X86_64_PC32:
+ 	  if (info->shared
+-	      && ABI_64_P (output_bfd)
+ 	      && (input_section->flags & SEC_ALLOC) != 0
+ 	      && (input_section->flags & SEC_READONLY) != 0
+ 	      && h != NULL)
+@@ -4626,7 +4625,7 @@ elf_x86_64_finish_dynamic_sections (bfd *output_bfd,
+ 			     + PLT_FDE_START_OFFSET);
+ 	}
+       if (htab->plt_eh_frame->sec_info_type
+-	  == ELF_INFO_TYPE_EH_FRAME)
++	  == SEC_INFO_TYPE_EH_FRAME)
+ 	{
+ 	  if (! _bfd_elf_write_section_eh_frame (output_bfd, info,
+ 						 htab->plt_eh_frame,
+diff --git a/bfd/elflink.c b/bfd/elflink.c
+index fc4266b..da6be48 100644
+--- a/bfd/elflink.c
++++ b/bfd/elflink.c
+@@ -1,6 +1,6 @@
+ /* ELF linking support for BFD.
+    Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
+-   2005, 2006, 2007, 2008, 2009, 2010, 2011
++   2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
+    Free Software Foundation, Inc.
+ 
+    This file is part of BFD, the Binary File Descriptor library.
+@@ -937,7 +937,7 @@ _bfd_elf_merge_symbol (bfd *abfd,
+   /* Silently discard TLS symbols from --just-syms.  There's no way to
+      combine a static TLS block with a new TLS block for this executable.  */
+   if (ELF_ST_TYPE (sym->st_info) == STT_TLS
+-      && sec->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
++      && sec->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
+     {
+       *skip = TRUE;
+       return TRUE;
+@@ -2708,7 +2708,7 @@ _bfd_elf_link_sec_merge_syms (struct elf_link_hash_entry *h, void *data)
+   if ((h->root.type == bfd_link_hash_defined
+        || h->root.type == bfd_link_hash_defweak)
+       && ((sec = h->root.u.def.section)->flags & SEC_MERGE)
+-      && sec->sec_info_type == ELF_INFO_TYPE_MERGE)
++      && sec->sec_info_type == SEC_INFO_TYPE_MERGE)
+     {
+       bfd *output_bfd = (bfd *) data;
+ 
+@@ -3499,7 +3499,7 @@ elf_link_add_object_symbols (bfd *abfd, struct bfd_link_info *info)
+       /* ld --just-symbols and dynamic objects don't mix very well.
+ 	 ld shouldn't allow it.  */
+       if ((s = abfd->sections) != NULL
+-	  && s->sec_info_type == ELF_INFO_TYPE_JUST_SYMS)
++	  && s->sec_info_type == SEC_INFO_TYPE_JUST_SYMS)
+ 	abort ();
+ 
+       /* If this dynamic lib was specified on the command line with
+@@ -3896,7 +3896,7 @@ error_free_dyn:
+ 	  sec = bfd_section_from_elf_index (abfd, isym->st_shndx);
+ 	  if (sec == NULL)
+ 	    sec = bfd_abs_section_ptr;
+-	  else if (elf_discarded_section (sec))
++	  else if (discarded_section (sec))
+ 	    {
+ 	      /* Symbols from discarded section are undefined.  We keep
+ 		 its visibility.  */
+@@ -4861,7 +4861,7 @@ error_free_dyn:
+ 					       &string_offset))
+ 		  goto error_return;
+ 		if (secdata->sec_info)
+-		  stab->sec_info_type = ELF_INFO_TYPE_STABS;
++		  stab->sec_info_type = SEC_INFO_TYPE_STABS;
+ 	    }
+ 	}
+     }
+@@ -6644,25 +6644,14 @@ bfd_elf_size_dynsym_hash_dynstr (bfd *output_bfd, struct bfd_link_info *info)
+   return TRUE;
+ }
+ 
+-/* Indicate that we are only retrieving symbol values from this
+-   section.  */
+-
+-void
+-_bfd_elf_link_just_syms (asection *sec, struct bfd_link_info *info)
+-{
+-  if (is_elf_hash_table (info->hash))
+-    sec->sec_info_type = ELF_INFO_TYPE_JUST_SYMS;
+-  _bfd_generic_link_just_syms (sec, info);
+-}
+-
+ /* Make sure sec_info_type is cleared if sec_info is cleared too.  */
+ 
+ static void
+ merge_sections_remove_hook (bfd *abfd ATTRIBUTE_UNUSED,
+ 			    asection *sec)
+ {
+-  BFD_ASSERT (sec->sec_info_type == ELF_INFO_TYPE_MERGE);
+-  sec->sec_info_type = ELF_INFO_TYPE_NONE;
++  BFD_ASSERT (sec->sec_info_type == SEC_INFO_TYPE_MERGE);
++  sec->sec_info_type = SEC_INFO_TYPE_NONE;
+ }
+ 
+ /* Finish SHF_MERGE section merging.  */
+@@ -6690,7 +6679,7 @@ _bfd_elf_merge_sections (bfd *abfd, struct bfd_link_info *info)
+ 					  sec, &secdata->sec_info))
+ 	      return FALSE;
+ 	    else if (secdata->sec_info)
+-	      sec->sec_info_type = ELF_INFO_TYPE_MERGE;
++	      sec->sec_info_type = SEC_INFO_TYPE_MERGE;
+ 	  }
+ 
+   if (elf_hash_table (info)->merge_info != NULL)
+@@ -8708,7 +8697,7 @@ elf_link_output_extsym (struct bfd_hash_entry *bh, void *data)
+   else if ((h->root.type == bfd_link_hash_defined
+ 	    || h->root.type == bfd_link_hash_defweak)
+ 	   && ((finfo->info->strip_discarded
+-		&& elf_discarded_section (h->root.u.def.section))
++		&& discarded_section (h->root.u.def.section))
+ 	       || (h->root.u.def.section->owner != NULL
+ 		   && (h->root.u.def.section->owner->flags & BFD_PLUGIN) != 0)))
+     strip = TRUE;
+@@ -9007,8 +8996,8 @@ elf_section_ignore_discarded_relocs (asection *sec)
+ 
+   switch (sec->sec_info_type)
+     {
+-    case ELF_INFO_TYPE_STABS:
+-    case ELF_INFO_TYPE_EH_FRAME:
++    case SEC_INFO_TYPE_STABS:
++    case SEC_INFO_TYPE_EH_FRAME:
+       return TRUE;
+     default:
+       break;
+@@ -9193,7 +9182,7 @@ elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
+ 	      *ppsection = NULL;
+ 	      continue;
+ 	    }
+-	  else if (isec->sec_info_type == ELF_INFO_TYPE_MERGE
++	  else if (isec->sec_info_type == SEC_INFO_TYPE_MERGE
+ 		   && ELF_ST_TYPE (isym->st_info) != STT_SECTION)
+ 	    isym->st_value =
+ 	      _bfd_merged_section_offset (output_bfd, &isec,
+@@ -9537,7 +9526,7 @@ elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
+ 		{
+ 		  /* Complain if the definition comes from a
+ 		     discarded section.  */
+-		  if ((sec = *ps) != NULL && elf_discarded_section (sec))
++		  if ((sec = *ps) != NULL && discarded_section (sec))
+ 		    {
+ 		      BFD_ASSERT (r_symndx != STN_UNDEF);
+ 		      if (action_discarded & COMPLAIN)
+@@ -9874,19 +9863,19 @@ elf_link_input_bfd (struct elf_final_link_info *finfo, bfd *input_bfd)
+ 	}
+       else switch (o->sec_info_type)
+ 	{
+-	case ELF_INFO_TYPE_STABS:
++	case SEC_INFO_TYPE_STABS:
+ 	  if (! (_bfd_write_section_stabs
+ 		 (output_bfd,
+ 		  &elf_hash_table (finfo->info)->stab_info,
+ 		  o, &elf_section_data (o)->sec_info, contents)))
+ 	    return FALSE;
+ 	  break;
+-	case ELF_INFO_TYPE_MERGE:
++	case SEC_INFO_TYPE_MERGE:
+ 	  if (! _bfd_write_merged_section (output_bfd, o,
+ 					   elf_section_data (o)->sec_info))
+ 	    return FALSE;
+ 	  break;
+-	case ELF_INFO_TYPE_EH_FRAME:
++	case SEC_INFO_TYPE_EH_FRAME:
+ 	  {
+ 	    if (! _bfd_elf_write_section_eh_frame (output_bfd, finfo->info,
+ 						   o, contents))
+@@ -11188,15 +11177,12 @@ bfd_elf_final_link (bfd *abfd, struct bfd_link_info *info)
+ 	goto error_return;
+ 
+       /* Check for DT_TEXTREL (late, in case the backend removes it).  */
+-      if ((info->warn_shared_textrel && info->shared)
+-	  || info->error_textrel)
++      if (((info->warn_shared_textrel && info->shared)
++	   || info->error_textrel)
++	  && (o = bfd_get_section_by_name (dynobj, ".dynamic")) != NULL)
+ 	{
+ 	  bfd_byte *dyncon, *dynconend;
+ 
+-	  /* Fix up .dynamic entries.  */
+-	  o = bfd_get_section_by_name (dynobj, ".dynamic");
+-	  BFD_ASSERT (o != NULL);
+-
+ 	  dyncon = o->contents;
+ 	  dynconend = o->contents + o->size;
+ 	  for (; dyncon < dynconend; dyncon += bed->s->sizeof_dyn)
+@@ -12418,7 +12404,7 @@ bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
+ 
+ 	  if ((h->root.type == bfd_link_hash_defined
+ 	       || h->root.type == bfd_link_hash_defweak)
+-	      && elf_discarded_section (h->root.u.def.section))
++	      && discarded_section (h->root.u.def.section))
+ 	    return TRUE;
+ 	  else
+ 	    return FALSE;
+@@ -12434,7 +12420,7 @@ bfd_elf_reloc_symbol_deleted_p (bfd_vma offset, void *cookie)
+ 	  /* Need to: get the symbol; get the section.  */
+ 	  isym = &rcookie->locsyms[r_symndx];
+ 	  isec = bfd_section_from_elf_index (rcookie->abfd, isym->st_shndx);
+-	  if (isec != NULL && elf_discarded_section (isec))
++	  if (isec != NULL && discarded_section (isec))
+ 	    return TRUE;
+ 	}
+       return FALSE;
+@@ -12485,7 +12471,7 @@ bfd_elf_discard_info (bfd *output_bfd, struct bfd_link_info *info)
+       if (stab != NULL
+ 	  && (stab->size == 0
+ 	      || bfd_is_abs_section (stab->output_section)
+-	      || stab->sec_info_type != ELF_INFO_TYPE_STABS))
++	      || stab->sec_info_type != SEC_INFO_TYPE_STABS))
+ 	stab = NULL;
+ 
+       if (stab == NULL
+diff --git a/bfd/elfn32-mips.c b/bfd/elfn32-mips.c
+index 00ec8b0..2189566 100644
+--- a/bfd/elfn32-mips.c
++++ b/bfd/elfn32-mips.c
+@@ -1555,6 +1555,111 @@ static reloc_howto_type elf_mips16_howto_table_rel[] =
+ 	 0x0000ffff,		/* src_mask */
+ 	 0x0000ffff,		/* dst_mask */
+ 	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS general dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_GD,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GD",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_LDM,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_LDM",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GOTTPREL",	/* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_HI16", /* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_LO16", /* name */
++	 TRUE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
+ };
+ 
+ static reloc_howto_type elf_mips16_howto_table_rela[] =
+@@ -1651,6 +1756,111 @@ static reloc_howto_type elf_mips16_howto_table_rela[] =
+ 	 0x0000ffff,		/* src_mask */
+ 	 0x0000ffff,		/* dst_mask */
+ 	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS general dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_GD,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GD",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic variable reference.  */
++  HOWTO (R_MIPS16_TLS_LDM,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_LDM",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_HI16",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS local dynamic offset.  */
++  HOWTO (R_MIPS16_TLS_DTPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_DTPREL_LO16",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_GOTTPREL,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_GOTTPREL",	/* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_HI16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_HI16", /* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
++
++  /* MIPS16 TLS thread pointer offset.  */
++  HOWTO (R_MIPS16_TLS_TPREL_LO16,	/* type */
++	 0,			/* rightshift */
++	 2,			/* size (0 = byte, 1 = short, 2 = long) */
++	 16,			/* bitsize */
++	 FALSE,			/* pc_relative */
++	 0,			/* bitpos */
++	 complain_overflow_signed, /* complain_on_overflow */
++	 _bfd_mips_elf_generic_reloc, /* special_function */
++	 "R_MIPS16_TLS_TPREL_LO16", /* name */
++	 FALSE,			/* partial_inplace */
++	 0x0000ffff,		/* src_mask */
++	 0x0000ffff,		/* dst_mask */
++	 FALSE),		/* pcrel_offset */
+ };
+ 
+ static reloc_howto_type elf_micromips_howto_table_rel[] =
+@@ -2724,6 +2934,15 @@ static const struct elf_reloc_map mips16_reloc_map[] =
+   { BFD_RELOC_MIPS16_CALL16, R_MIPS16_CALL16 - R_MIPS16_min },
+   { BFD_RELOC_MIPS16_HI16_S, R_MIPS16_HI16 - R_MIPS16_min },
+   { BFD_RELOC_MIPS16_LO16, R_MIPS16_LO16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_GD, R_MIPS16_TLS_GD - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_LDM, R_MIPS16_TLS_LDM - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_DTPREL_HI16,
++    R_MIPS16_TLS_DTPREL_HI16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_DTPREL_LO16,
++    R_MIPS16_TLS_DTPREL_LO16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_GOTTPREL, R_MIPS16_TLS_GOTTPREL - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_TPREL_HI16, R_MIPS16_TLS_TPREL_HI16 - R_MIPS16_min },
++  { BFD_RELOC_MIPS16_TLS_TPREL_LO16, R_MIPS16_TLS_TPREL_LO16 - R_MIPS16_min }
+ };
+ 
+ static const struct elf_reloc_map micromips_reloc_map[] =
+diff --git a/bfd/elfnn-ia64.c b/bfd/elfnn-ia64.c
+index 3e2ee0b..0f6b720 100644
+--- a/bfd/elfnn-ia64.c
++++ b/bfd/elfnn-ia64.c
+@@ -530,7 +530,7 @@ elfNN_ia64_relax_section (bfd *abfd, asection *sec,
+ 	  symtype = h->type;
+ 	}
+ 
+-      if (tsec->sec_info_type == ELF_INFO_TYPE_MERGE)
++      if (tsec->sec_info_type == SEC_INFO_TYPE_MERGE)
+ 	{
+ 	  /* At this stage in linking, no SEC_MERGE symbol has been
+ 	     adjusted, so all references to such symbols need to be
+@@ -3861,7 +3861,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
+ 	  if (!info->relocatable
+ 	      && (sym_sec->flags & SEC_MERGE) != 0
+ 	      && ELF_ST_TYPE (sym->st_info) == STT_SECTION
+-	      && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
++	      && sym_sec->sec_info_type == SEC_INFO_TYPE_MERGE)
+ 	    {
+ 	      struct elfNN_ia64_local_hash_entry *loc_h;
+ 
+@@ -3919,7 +3919,7 @@ elfNN_ia64_relocate_section (bfd *output_bfd,
+ 	    continue;
+ 	}
+ 
+-      if (sym_sec != NULL && elf_discarded_section (sym_sec))
++      if (sym_sec != NULL && discarded_section (sym_sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elfxx-mips.c b/bfd/elfxx-mips.c
+index 33a454d..7911050 100644
+--- a/bfd/elfxx-mips.c
++++ b/bfd/elfxx-mips.c
+@@ -436,8 +436,8 @@ struct mips_elf_link_hash_table
+      entry is set to the address of __rld_obj_head as in IRIX5.  */
+   bfd_boolean use_rld_obj_head;
+ 
+-  /* This is the value of the __rld_map or __rld_obj_head symbol.  */
+-  bfd_vma rld_value;
++  /* The  __rld_map or __rld_obj_head symbol. */
++  struct elf_link_hash_entry *rld_symbol;
+ 
+   /* This is set if we see any mips16 stub sections.  */
+   bfd_boolean mips16_stubs_seen;
+@@ -529,6 +529,13 @@ struct mips_htab_traverse_info
+    || r_type == R_MIPS_TLS_TPREL64		\
+    || r_type == R_MIPS_TLS_TPREL_HI16		\
+    || r_type == R_MIPS_TLS_TPREL_LO16		\
++   || r_type == R_MIPS16_TLS_GD			\
++   || r_type == R_MIPS16_TLS_LDM		\
++   || r_type == R_MIPS16_TLS_DTPREL_HI16	\
++   || r_type == R_MIPS16_TLS_DTPREL_LO16	\
++   || r_type == R_MIPS16_TLS_GOTTPREL		\
++   || r_type == R_MIPS16_TLS_TPREL_HI16		\
++   || r_type == R_MIPS16_TLS_TPREL_LO16		\
+    || r_type == R_MICROMIPS_TLS_GD		\
+    || r_type == R_MICROMIPS_TLS_LDM		\
+    || r_type == R_MICROMIPS_TLS_DTPREL_HI16	\
+@@ -768,6 +775,10 @@ static bfd *reldyn_sorting_bfd;
+ #define MIPS_ELF_GOT_SIZE(abfd) \
+   (get_elf_backend_data (abfd)->s->arch_size / 8)
+ 
++/* The size of the .rld_map section. */
++#define MIPS_ELF_RLD_MAP_SIZE(abfd) \
++  (get_elf_backend_data (abfd)->s->arch_size / 8)
++
+ /* The size of a symbol-table entry.  */
+ #define MIPS_ELF_SYM_SIZE(abfd) \
+   (get_elf_backend_data (abfd)->s->sizeof_sym)
+@@ -1571,9 +1582,10 @@ _bfd_mips_elf_init_stubs (struct bfd_link_info *info,
+ }
+ 
+ /* Return true if H is a locally-defined PIC function, in the sense
+-   that it might need $25 to be valid on entry.  Note that MIPS16
+-   functions never need $25 to be valid on entry; they set up $gp
+-   using PC-relative instructions instead.  */
++   that it or its fn_stub might need $25 to be valid on entry.
++   Note that MIPS16 functions set up $gp using PC-relative instructions,
++   so they themselves never need $25 to be valid.  Only non-MIPS16
++   entry points are of interest here.  */
+ 
+ static bfd_boolean
+ mips_elf_local_pic_function_p (struct mips_elf_link_hash_entry *h)
+@@ -1582,11 +1594,32 @@ mips_elf_local_pic_function_p (struct mips_elf_link_hash_entry *h)
+ 	   || h->root.root.type == bfd_link_hash_defweak)
+ 	  && h->root.def_regular
+ 	  && !bfd_is_abs_section (h->root.root.u.def.section)
+-	  && !ELF_ST_IS_MIPS16 (h->root.other)
++	  && (!ELF_ST_IS_MIPS16 (h->root.other)
++	      || (h->fn_stub && h->need_fn_stub))
+ 	  && (PIC_OBJECT_P (h->root.root.u.def.section->owner)
+ 	      || ELF_ST_IS_MIPS_PIC (h->root.other)));
+ }
+ 
++/* Set *SEC to the input section that contains the target of STUB.
++   Return the offset of the target from the start of that section.  */
++
++static bfd_vma
++mips_elf_get_la25_target (struct mips_elf_la25_stub *stub,
++			  asection **sec)
++{
++  if (ELF_ST_IS_MIPS16 (stub->h->root.other))
++    {
++      BFD_ASSERT (stub->h->need_fn_stub);
++      *sec = stub->h->fn_stub;
++      return 0;
++    }
++  else
++    {
++      *sec = stub->h->root.root.u.def.section;
++      return stub->h->root.root.u.def.value;
++    }
++}
++
+ /* STUB describes an la25 stub that we have decided to implement
+    by inserting an LUI/ADDIU pair before the target function.
+    Create the section and redirect the function symbol to it.  */
+@@ -1611,7 +1644,7 @@ mips_elf_add_la25_intro (struct mips_elf_la25_stub *stub,
+   sprintf (name, ".text.stub.%d", (int) htab_elements (htab->la25_stubs));
+ 
+   /* Create the section.  */
+-  input_section = stub->h->root.root.u.def.section;
++  mips_elf_get_la25_target (stub, &input_section);
+   s = htab->add_stub_section (name, input_section,
+ 			      input_section->output_section);
+   if (s == NULL)
+@@ -1685,12 +1718,6 @@ mips_elf_add_la25_stub (struct bfd_link_info *info,
+   bfd_vma value;
+   void **slot;
+ 
+-  /* Prefer to use LUI/ADDIU stubs if the function is at the beginning
+-     of the section and if we would need no more than 2 nops.  */
+-  s = h->root.root.u.def.section;
+-  value = h->root.root.u.def.value;
+-  use_trampoline_p = (value != 0 || s->alignment_power > 4);
+-
+   /* Describe the stub we want.  */
+   search.stub_section = NULL;
+   search.offset = 0;
+@@ -1720,6 +1747,11 @@ mips_elf_add_la25_stub (struct bfd_link_info *info,
+   *stub = search;
+   *slot = stub;
+ 
++  /* Prefer to use LUI/ADDIU stubs if the function is at the beginning
++     of the section and if we would need no more than 2 nops.  */
++  value = mips_elf_get_la25_target (stub, &s);
++  use_trampoline_p = (value != 0 || s->alignment_power > 4);
++
+   h->la25_stub = stub;
+   return (use_trampoline_p
+ 	  ? mips_elf_add_la25_trampoline (stub, info)
+@@ -1860,6 +1892,13 @@ mips16_reloc_p (int r_type)
+     case R_MIPS16_CALL16:
+     case R_MIPS16_HI16:
+     case R_MIPS16_LO16:
++    case R_MIPS16_TLS_GD:
++    case R_MIPS16_TLS_LDM:
++    case R_MIPS16_TLS_DTPREL_HI16:
++    case R_MIPS16_TLS_DTPREL_LO16:
++    case R_MIPS16_TLS_GOTTPREL:
++    case R_MIPS16_TLS_TPREL_HI16:
++    case R_MIPS16_TLS_TPREL_LO16:
+       return TRUE;
+ 
+     default:
+@@ -1987,19 +2026,25 @@ micromips_branch_reloc_p (int r_type)
+ static inline bfd_boolean
+ tls_gd_reloc_p (unsigned int r_type)
+ {
+-  return r_type == R_MIPS_TLS_GD || r_type == R_MICROMIPS_TLS_GD;
++  return (r_type == R_MIPS_TLS_GD
++	  || r_type == R_MIPS16_TLS_GD
++	  || r_type == R_MICROMIPS_TLS_GD);
+ }
+ 
+ static inline bfd_boolean
+ tls_ldm_reloc_p (unsigned int r_type)
+ {
+-  return r_type == R_MIPS_TLS_LDM || r_type == R_MICROMIPS_TLS_LDM;
++  return (r_type == R_MIPS_TLS_LDM
++	  || r_type == R_MIPS16_TLS_LDM
++	  || r_type == R_MICROMIPS_TLS_LDM);
+ }
+ 
+ static inline bfd_boolean
+ tls_gottprel_reloc_p (unsigned int r_type)
+ {
+-  return r_type == R_MIPS_TLS_GOTTPREL || r_type == R_MICROMIPS_TLS_GOTTPREL;
++  return (r_type == R_MIPS_TLS_GOTTPREL
++	  || r_type == R_MIPS16_TLS_GOTTPREL
++	  || r_type == R_MICROMIPS_TLS_GOTTPREL);
+ }
+ 
+ void
+@@ -4907,7 +4952,8 @@ is_gott_symbol (struct bfd_link_info *info, struct elf_link_hash_entry *h)
+    stub.  */
+ 
+ static bfd_boolean
+-mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type)
++mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type,
++				     bfd_boolean target_is_16_bit_code_p)
+ {
+   /* We specifically ignore branches and jumps from EF_PIC objects,
+      where the onus is on the compiler or programmer to perform any
+@@ -4921,7 +4967,6 @@ mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type)
+     {
+     case R_MIPS_26:
+     case R_MIPS_PC16:
+-    case R_MIPS16_26:
+     case R_MICROMIPS_26_S1:
+     case R_MICROMIPS_PC7_S1:
+     case R_MICROMIPS_PC10_S1:
+@@ -4929,6 +4974,9 @@ mips_elf_relocation_needs_la25_stub (bfd *input_bfd, int r_type)
+     case R_MICROMIPS_PC23_S2:
+       return TRUE;
+ 
++    case R_MIPS16_26:
++      return !target_is_16_bit_code_p;
++
+     default:
+       return FALSE;
+     }
+@@ -5189,14 +5237,28 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+ 	 have already noticed that we were going to need the
+ 	 stub.  */
+       if (local_p)
+-	sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
++	{
++	  sec = elf_tdata (input_bfd)->local_stubs[r_symndx];
++	  value = 0;
++	}
+       else
+ 	{
+ 	  BFD_ASSERT (h->need_fn_stub);
+-	  sec = h->fn_stub;
++	  if (h->la25_stub)
++	    {
++	      /* If a LA25 header for the stub itself exists, point to the
++		 prepended LUI/ADDIU sequence.  */
++	      sec = h->la25_stub->stub_section;
++	      value = h->la25_stub->offset;
++	    }
++	  else
++	    {
++	      sec = h->fn_stub;
++	      value = 0;
++	    }
+ 	}
+ 
+-      symbol = sec->output_section->vma + sec->output_offset;
++      symbol = sec->output_section->vma + sec->output_offset + value;
+       /* The target is 16-bit, but the stub isn't.  */
+       target_is_16_bit_code_p = FALSE;
+     }
+@@ -5246,7 +5308,8 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+   /* If this is a direct call to a PIC function, redirect to the
+      non-PIC stub.  */
+   else if (h != NULL && h->la25_stub
+-	   && mips_elf_relocation_needs_la25_stub (input_bfd, r_type))
++	   && mips_elf_relocation_needs_la25_stub (input_bfd, r_type,
++						   target_is_16_bit_code_p))
+     symbol = (h->la25_stub->stub_section->output_section->vma
+ 	      + h->la25_stub->stub_section->output_offset
+ 	      + h->la25_stub->offset);
+@@ -5318,6 +5381,9 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+     case R_MIPS_TLS_GD:
+     case R_MIPS_TLS_GOTTPREL:
+     case R_MIPS_TLS_LDM:
++    case R_MIPS16_TLS_GD:
++    case R_MIPS16_TLS_GOTTPREL:
++    case R_MIPS16_TLS_LDM:
+     case R_MICROMIPS_TLS_GD:
+     case R_MICROMIPS_TLS_GOTTPREL:
+     case R_MICROMIPS_TLS_LDM:
+@@ -5487,6 +5553,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+       break;
+ 
+     case R_MIPS_TLS_DTPREL_HI16:
++    case R_MIPS16_TLS_DTPREL_HI16:
+     case R_MICROMIPS_TLS_DTPREL_HI16:
+       value = (mips_elf_high (addend + symbol - dtprel_base (info))
+ 	       & howto->dst_mask);
+@@ -5495,17 +5562,22 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+     case R_MIPS_TLS_DTPREL_LO16:
+     case R_MIPS_TLS_DTPREL32:
+     case R_MIPS_TLS_DTPREL64:
++    case R_MIPS16_TLS_DTPREL_LO16:
+     case R_MICROMIPS_TLS_DTPREL_LO16:
+       value = (symbol + addend - dtprel_base (info)) & howto->dst_mask;
+       break;
+ 
+     case R_MIPS_TLS_TPREL_HI16:
++    case R_MIPS16_TLS_TPREL_HI16:
+     case R_MICROMIPS_TLS_TPREL_HI16:
+       value = (mips_elf_high (addend + symbol - tprel_base (info))
+ 	       & howto->dst_mask);
+       break;
+ 
+     case R_MIPS_TLS_TPREL_LO16:
++    case R_MIPS_TLS_TPREL32:
++    case R_MIPS_TLS_TPREL64:
++    case R_MIPS16_TLS_TPREL_LO16:
+     case R_MICROMIPS_TLS_TPREL_LO16:
+       value = (symbol + addend - tprel_base (info)) & howto->dst_mask;
+       break;
+@@ -5527,10 +5599,11 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+ 	       12: addu    $v0,$v1
+ 	       14: move    $gp,$v0
+ 	     So the offsets of hi and lo relocs are the same, but the
+-	     $pc is four higher than $t9 would be, so reduce
+-	     both reloc addends by 4. */
++	     base $pc is that used by the ADDIUPC instruction at $t9 + 4.
++	     ADDIUPC clears the low two bits of the instruction address,
++	     so the base is ($t9 + 4) & ~3.  */
+ 	  if (r_type == R_MIPS16_HI16)
+-	    value = mips_elf_high (addend + gp - p - 4);
++	    value = mips_elf_high (addend + gp - ((p + 4) & ~(bfd_vma) 0x3));
+ 	  /* The microMIPS .cpload sequence uses the same assembly
+ 	     instructions as the traditional psABI version, but the
+ 	     incoming $t9 has the low bit set.  */
+@@ -5553,7 +5626,7 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+ 	  /* See the comment for R_MIPS16_HI16 above for the reason
+ 	     for this conditional.  */
+ 	  if (r_type == R_MIPS16_LO16)
+-	    value = addend + gp - p;
++	    value = addend + gp - (p & ~(bfd_vma) 0x3);
+ 	  else if (r_type == R_MICROMIPS_LO16
+ 		   || r_type == R_MICROMIPS_HI0_LO16)
+ 	    value = addend + gp - p + 3;
+@@ -5637,6 +5710,9 @@ mips_elf_calculate_relocation (bfd *abfd, bfd *input_bfd,
+     case R_MIPS_TLS_GOTTPREL:
+     case R_MIPS_TLS_LDM:
+     case R_MIPS_GOT_DISP:
++    case R_MIPS16_TLS_GD:
++    case R_MIPS16_TLS_GOTTPREL:
++    case R_MIPS16_TLS_LDM:
+     case R_MICROMIPS_TLS_GD:
+     case R_MICROMIPS_TLS_GOTTPREL:
+     case R_MICROMIPS_TLS_LDM:
+@@ -7081,6 +7157,7 @@ _bfd_mips_elf_add_symbol_hook (bfd *abfd, struct bfd_link_info *info,
+ 	return FALSE;
+ 
+       mips_elf_hash_table (info)->use_rld_obj_head = TRUE;
++      mips_elf_hash_table (info)->rld_symbol = h;
+     }
+ 
+   /* If this is a mips16 text symbol, add 1 to the value to make it
+@@ -7266,6 +7343,7 @@ _bfd_mips_elf_create_dynamic_sections (bfd *abfd, struct bfd_link_info *info)
+ 
+ 	  if (! bfd_elf_link_record_dynamic_symbol (info, h))
+ 	    return FALSE;
++	  mips_elf_hash_table (info)->rld_symbol = h;
+ 	}
+     }
+ 
+@@ -7767,8 +7845,6 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+       can_make_dynamic_p = FALSE;
+       switch (r_type)
+ 	{
+-	case R_MIPS16_GOT16:
+-	case R_MIPS16_CALL16:
+ 	case R_MIPS_GOT16:
+ 	case R_MIPS_CALL16:
+ 	case R_MIPS_CALL_HI16:
+@@ -7781,6 +7857,11 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+ 	case R_MIPS_TLS_GOTTPREL:
+ 	case R_MIPS_TLS_GD:
+ 	case R_MIPS_TLS_LDM:
++	case R_MIPS16_GOT16:
++	case R_MIPS16_CALL16:
++	case R_MIPS16_TLS_GOTTPREL:
++	case R_MIPS16_TLS_GD:
++	case R_MIPS16_TLS_LDM:
+ 	case R_MICROMIPS_GOT16:
+ 	case R_MICROMIPS_CALL16:
+ 	case R_MICROMIPS_CALL_HI16:
+@@ -7918,7 +7999,9 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+ 	    return FALSE;
+ 	}
+ 
+-      if (h != NULL && mips_elf_relocation_needs_la25_stub (abfd, r_type))
++      if (h != NULL
++	  && mips_elf_relocation_needs_la25_stub (abfd, r_type,
++						  ELF_ST_IS_MIPS16 (h->other)))
+ 	((struct mips_elf_link_hash_entry *) h)->has_nonpic_branches = TRUE;
+ 
+       switch (r_type)
+@@ -8015,12 +8098,14 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+ 	  break;
+ 
+ 	case R_MIPS_TLS_GOTTPREL:
++	case R_MIPS16_TLS_GOTTPREL:
+ 	case R_MICROMIPS_TLS_GOTTPREL:
+ 	  if (info->shared)
+ 	    info->flags |= DF_STATIC_TLS;
+ 	  /* Fall through */
+ 
+ 	case R_MIPS_TLS_LDM:
++	case R_MIPS16_TLS_LDM:
+ 	case R_MICROMIPS_TLS_LDM:
+ 	  if (tls_ldm_reloc_p (r_type))
+ 	    {
+@@ -8030,6 +8115,7 @@ _bfd_mips_elf_check_relocs (bfd *abfd, struct bfd_link_info *info,
+ 	  /* Fall through */
+ 
+ 	case R_MIPS_TLS_GD:
++	case R_MIPS16_TLS_GD:
+ 	case R_MICROMIPS_TLS_GD:
+ 	  /* This symbol requires a global offset table entry, or two
+ 	     for TLS GD relocations.  */
+@@ -9027,7 +9113,7 @@ _bfd_mips_elf_size_dynamic_sections (bfd *output_bfd,
+ 	{
+ 	  /* We add a room for __rld_map.  It will be filled in by the
+ 	     rtld to contain a pointer to the _r_debug structure.  */
+-	  s->size += 4;
++	  s->size += MIPS_ELF_RLD_MAP_SIZE (output_bfd);
+ 	}
+       else if (SGI_COMPAT (output_bfd)
+ 	       && CONST_STRNEQ (name, ".compact_rel"))
+@@ -9299,7 +9385,7 @@ _bfd_mips_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	    sec = h->root.u.def.section;
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+@@ -9615,9 +9701,9 @@ mips_elf_create_la25_stub (void **slot, void *data)
+   offset = stub->offset;
+ 
+   /* Work out the target address.  */
+-  target = (stub->h->root.root.u.def.section->output_section->vma
+-	    + stub->h->root.root.u.def.section->output_offset
+-	    + stub->h->root.root.u.def.value);
++  target = mips_elf_get_la25_target (stub, &s);
++  target += s->output_section->vma + s->output_offset;
++
+   target_high = ((target + 0x8000) >> 16) & 0xffff;
+   target_low = (target & 0xffff);
+ 
+@@ -10030,31 +10116,6 @@ _bfd_mips_elf_finish_dynamic_symbol (bfd *output_bfd,
+   if (IRIX_COMPAT (output_bfd) == ict_irix6)
+     mips_elf_irix6_finish_dynamic_symbol (output_bfd, name, sym);
+ 
+-  if (! info->shared)
+-    {
+-      if (! mips_elf_hash_table (info)->use_rld_obj_head
+-	  && (strcmp (name, "__rld_map") == 0
+-	      || strcmp (name, "__RLD_MAP") == 0))
+-	{
+-	  asection *s = bfd_get_section_by_name (dynobj, ".rld_map");
+-	  BFD_ASSERT (s != NULL);
+-	  sym->st_value = s->output_section->vma + s->output_offset;
+-	  bfd_put_32 (output_bfd, 0, s->contents);
+-	  if (mips_elf_hash_table (info)->rld_value == 0)
+-	    mips_elf_hash_table (info)->rld_value = sym->st_value;
+-	}
+-      else if (mips_elf_hash_table (info)->use_rld_obj_head
+-	       && strcmp (name, "__rld_obj_head") == 0)
+-	{
+-	  /* IRIX6 does not use a .rld_map section.  */
+-	  if (IRIX_COMPAT (output_bfd) == ict_irix5
+-              || IRIX_COMPAT (output_bfd) == ict_none)
+-	    BFD_ASSERT (bfd_get_section_by_name (dynobj, ".rld_map")
+-			!= NULL);
+-	  mips_elf_hash_table (info)->rld_value = sym->st_value;
+-	}
+-    }
+-
+   /* Keep dynamic MIPS16 symbols odd.  This allows the dynamic linker to
+      treat MIPS16 symbols like any other.  */
+   if (ELF_ST_IS_MIPS16 (sym->st_other))
+@@ -10517,7 +10578,19 @@ _bfd_mips_elf_finish_dynamic_sections (bfd *output_bfd,
+ 	      break;
+ 
+ 	    case DT_MIPS_RLD_MAP:
+-	      dyn.d_un.d_ptr = mips_elf_hash_table (info)->rld_value;
++	      {
++		struct elf_link_hash_entry *h;
++		h = mips_elf_hash_table (info)->rld_symbol;
++		if (!h)
++		  {
++		    dyn_to_skip = MIPS_ELF_DYN_SIZE (dynobj);
++		    swap_out_p = FALSE;
++		    break;
++		  }
++		s = h->root.u.def.section;
++		dyn.d_un.d_ptr = (s->output_section->vma + s->output_offset
++				  + h->root.u.def.value);
++	      }
+ 	      break;
+ 
+ 	    case DT_MIPS_OPTIONS:
+@@ -12794,7 +12867,7 @@ _bfd_mips_elf_link_hash_table_create (bfd *abfd)
+   ret->procedure_count = 0;
+   ret->compact_rel_size = 0;
+   ret->use_rld_obj_head = FALSE;
+-  ret->rld_value = 0;
++  ret->rld_symbol = NULL;
+   ret->mips16_stubs_seen = FALSE;
+   ret->use_plts_and_copy_relocs = FALSE;
+   ret->is_vxworks = FALSE;
+diff --git a/bfd/elfxx-sparc.c b/bfd/elfxx-sparc.c
+index 9a15124..f3c631e 100644
+--- a/bfd/elfxx-sparc.c
++++ b/bfd/elfxx-sparc.c
+@@ -2970,7 +2970,7 @@ _bfd_sparc_elf_relocate_section (bfd *output_bfd,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/elfxx-tilegx.c b/bfd/elfxx-tilegx.c
+index c484562..e1c8946 100644
+--- a/bfd/elfxx-tilegx.c
++++ b/bfd/elfxx-tilegx.c
+@@ -2908,7 +2908,7 @@ tilegx_elf_relocate_section (bfd *output_bfd, struct bfd_link_info *info,
+ 	    }
+ 	}
+ 
+-      if (sec != NULL && elf_discarded_section (sec))
++      if (sec != NULL && discarded_section (sec))
+ 	RELOC_AGAINST_DISCARDED_SECTION (info, input_bfd, input_section,
+ 					 rel, relend, howto, contents);
+ 
+diff --git a/bfd/libbfd.h b/bfd/libbfd.h
+index 200a6fa..0395ec2 100644
+--- a/bfd/libbfd.h
++++ b/bfd/libbfd.h
+@@ -1086,6 +1086,13 @@ static const char *const bfd_reloc_code_real_names[] = { "@@uninitialized@@",
+   "BFD_RELOC_MIPS16_HI16",
+   "BFD_RELOC_MIPS16_HI16_S",
+   "BFD_RELOC_MIPS16_LO16",
++  "BFD_RELOC_MIPS16_TLS_GD",
++  "BFD_RELOC_MIPS16_TLS_LDM",
++  "BFD_RELOC_MIPS16_TLS_DTPREL_HI16",
++  "BFD_RELOC_MIPS16_TLS_DTPREL_LO16",
++  "BFD_RELOC_MIPS16_TLS_GOTTPREL",
++  "BFD_RELOC_MIPS16_TLS_TPREL_HI16",
++  "BFD_RELOC_MIPS16_TLS_TPREL_LO16",
+   "BFD_RELOC_MIPS_LITERAL",
+   "BFD_RELOC_MICROMIPS_LITERAL",
+   "BFD_RELOC_MICROMIPS_7_PCREL_S1",
+diff --git a/bfd/linker.c b/bfd/linker.c
+index 7a01e11..e5d20b2 100644
+--- a/bfd/linker.c
++++ b/bfd/linker.c
+@@ -1,6 +1,6 @@
+ /* linker.c -- BFD linker routines
+    Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+-   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
++   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
+    Free Software Foundation, Inc.
+    Written by Steve Chamberlain and Ian Lance Taylor, Cygnus Support
+ 
+@@ -810,6 +810,7 @@ void
+ _bfd_generic_link_just_syms (asection *sec,
+ 			     struct bfd_link_info *info ATTRIBUTE_UNUSED)
+ {
++  sec->sec_info_type = SEC_INFO_TYPE_JUST_SYMS;
+   sec->output_section = bfd_abs_section_ptr;
+   sec->output_offset = sec->vma;
+ }
+diff --git a/bfd/reloc.c b/bfd/reloc.c
+index 6ac7148..e3f0343 100644
+--- a/bfd/reloc.c
++++ b/bfd/reloc.c
+@@ -2247,6 +2247,23 @@ ENUMDOC
+   MIPS16 low 16 bits.
+ 
+ ENUM
++  BFD_RELOC_MIPS16_TLS_GD
++ENUMX
++  BFD_RELOC_MIPS16_TLS_LDM
++ENUMX
++  BFD_RELOC_MIPS16_TLS_DTPREL_HI16
++ENUMX
++  BFD_RELOC_MIPS16_TLS_DTPREL_LO16
++ENUMX
++  BFD_RELOC_MIPS16_TLS_GOTTPREL
++ENUMX
++  BFD_RELOC_MIPS16_TLS_TPREL_HI16
++ENUMX
++  BFD_RELOC_MIPS16_TLS_TPREL_LO16
++ENUMDOC
++  MIPS16 TLS relocations
++
++ENUM
+   BFD_RELOC_MIPS_LITERAL
+ ENUMX
+   BFD_RELOC_MICROMIPS_LITERAL
+@@ -6218,7 +6235,7 @@ bfd_generic_get_relocated_section_contents (bfd *abfd,
+ 	  bfd_reloc_status_type r;
+ 
+ 	  symbol = *(*parent)->sym_ptr_ptr;
+-	  if (symbol->section && elf_discarded_section (symbol->section))
++	  if (symbol->section && discarded_section (symbol->section))
+ 	    {
+ 	      bfd_byte *p;
+ 	      static reloc_howto_type none_howto
+diff --git a/bfd/section.c b/bfd/section.c
+index 7c1f750..e60f247 100644
+--- a/bfd/section.c
++++ b/bfd/section.c
+@@ -382,11 +382,11 @@ CODE_FRAGMENT
+ .
+ .  {* Type of sec_info information.  *}
+ .  unsigned int sec_info_type:3;
+-.#define ELF_INFO_TYPE_NONE      0
+-.#define ELF_INFO_TYPE_STABS     1
+-.#define ELF_INFO_TYPE_MERGE     2
+-.#define ELF_INFO_TYPE_EH_FRAME  3
+-.#define ELF_INFO_TYPE_JUST_SYMS 4
++.#define SEC_INFO_TYPE_NONE      0
++.#define SEC_INFO_TYPE_STABS     1
++.#define SEC_INFO_TYPE_MERGE     2
++.#define SEC_INFO_TYPE_EH_FRAME  3
++.#define SEC_INFO_TYPE_JUST_SYMS 4
+ .
+ .  {* Nonzero if this section uses RELA relocations, rather than REL.  *}
+ .  unsigned int use_rela_p:1;
+diff --git a/bfd/version.h b/bfd/version.h
+index c6800ec..8784380 100644
+--- a/bfd/version.h
++++ b/bfd/version.h
+@@ -1,4 +1,4 @@
+-#define BFD_VERSION_DATE 20111121
++#define BFD_VERSION_DATE 20120704
+ #define BFD_VERSION @bfd_version@
+ #define BFD_VERSION_STRING  @bfd_version_package@ @bfd_version_string@
+ #define REPORT_BUGS_TO @report_bugs_to@
+diff --git a/binutils/ChangeLog b/binutils/ChangeLog
+index 2f5af61..30101e5 100644
+--- a/binutils/ChangeLog
++++ b/binutils/ChangeLog
+@@ -1,3 +1,10 @@
++2012-01-26  Nick Clifton  <nickc@redhat.com>
++
++	PR binutils/13622
++	* readelf.c (process_section_groups): If there are no section
++	headers do not scan for section groups.
++	(process_note_sections): Likewise for note sections.
++
+ 2011-10-25  Alan Modra  <amodra@gmail.com>
+ 
+ 	Apply mainline patches
+diff --git a/binutils/readelf.c b/binutils/readelf.c
+index 9e13190..bf053d9 100644
+--- a/binutils/readelf.c
++++ b/binutils/readelf.c
+@@ -4937,7 +4937,8 @@ process_section_groups (FILE * file)
+   if (section_headers == NULL)
+     {
+       error (_("Section headers are not available!\n"));
+-      abort ();
++      /* PR 13622: This can happen with a corrupt ELF header.  */
++      return 0;
+     }
+ 
+   section_headers_groups = (struct group **) calloc (elf_header.e_shnum,
+@@ -12942,7 +12943,7 @@ process_note_sections (FILE * file)
+   int res = 1;
+ 
+   for (i = 0, section = section_headers;
+-       i < elf_header.e_shnum;
++       i < elf_header.e_shnum && section != NULL;
+        i++, section++)
+     if (section->sh_type == SHT_NOTE)
+       res &= process_corefile_note_segment (file,
+diff --git a/gas/ChangeLog b/gas/ChangeLog
+index b29f95f..df24933 100644
+--- a/gas/ChangeLog
++++ b/gas/ChangeLog
+@@ -1,3 +1,23 @@
++2012-01-08  Richard Sandiford  <rdsandiford@googlemail.com>
++
++	* config/tc-mips.c (s_tls_rel_directive): Call mips_clear_insn_labels.
++
++2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	Backport from mainline:
++
++	2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	* config/tc-mips.c (mips_pseudo_table): Add tprelword/tpreldword
++	entries.
++	(mips16_percent_op): Add MIPS16 TLS relocation ops.
++	(md_apply_fix): Add BFD_RELOC_MIPS16_TLS_* switch cases.
++	(s_tls_rel_directive): Rename from s_dtprel_internal(). Abstract out
++	directive string and reloc type as function parameters. Update
++	comments.
++	(s_dtprelword,s_dtpreldword): Change to use s_tls_rel_directive().
++	(s_tprelword,s_tpreldword): New functions.
++
+ 2011-11-15  Maciej W. Rozycki  <macro@codesourcery.com>
+ 
+ 	Apply mainline patches
+diff --git a/gas/config/tc-mips.c b/gas/config/tc-mips.c
+index 0e4c66e..5324450 100644
+--- a/gas/config/tc-mips.c
++++ b/gas/config/tc-mips.c
+@@ -1352,6 +1352,8 @@ static void s_cprestore (int);
+ static void s_cpreturn (int);
+ static void s_dtprelword (int);
+ static void s_dtpreldword (int);
++static void s_tprelword (int);
++static void s_tpreldword (int);
+ static void s_gpvalue (int);
+ static void s_gpword (int);
+ static void s_gpdword (int);
+@@ -1431,6 +1433,8 @@ static const pseudo_typeS mips_pseudo_table[] =
+   {"cpreturn", s_cpreturn, 0},
+   {"dtprelword", s_dtprelword, 0},
+   {"dtpreldword", s_dtpreldword, 0},
++  {"tprelword", s_tprelword, 0},
++  {"tpreldword", s_tpreldword, 0},
+   {"gpvalue", s_gpvalue, 0},
+   {"gpword", s_gpword, 0},
+   {"gpdword", s_gpdword, 0},
+@@ -14040,7 +14044,14 @@ static const struct percent_op_match mips16_percent_op[] =
+   {"%gprel", BFD_RELOC_MIPS16_GPREL},
+   {"%got", BFD_RELOC_MIPS16_GOT16},
+   {"%call16", BFD_RELOC_MIPS16_CALL16},
+-  {"%hi", BFD_RELOC_MIPS16_HI16_S}
++  {"%hi", BFD_RELOC_MIPS16_HI16_S},
++  {"%tlsgd", BFD_RELOC_MIPS16_TLS_GD},
++  {"%tlsldm", BFD_RELOC_MIPS16_TLS_LDM},
++  {"%dtprel_hi", BFD_RELOC_MIPS16_TLS_DTPREL_HI16},
++  {"%dtprel_lo", BFD_RELOC_MIPS16_TLS_DTPREL_LO16},
++  {"%tprel_hi", BFD_RELOC_MIPS16_TLS_TPREL_HI16},
++  {"%tprel_lo", BFD_RELOC_MIPS16_TLS_TPREL_LO16},
++  {"%gottprel", BFD_RELOC_MIPS16_TLS_GOTTPREL}
+ };
+ 
+ 
+@@ -15369,6 +15380,8 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
+     case BFD_RELOC_MIPS_TLS_DTPREL_HI16:
+     case BFD_RELOC_MIPS_TLS_DTPREL_LO16:
+     case BFD_RELOC_MIPS_TLS_GOTTPREL:
++    case BFD_RELOC_MIPS_TLS_TPREL32:
++    case BFD_RELOC_MIPS_TLS_TPREL64:
+     case BFD_RELOC_MIPS_TLS_TPREL_HI16:
+     case BFD_RELOC_MIPS_TLS_TPREL_LO16:
+     case BFD_RELOC_MICROMIPS_TLS_GD:
+@@ -15378,6 +15391,13 @@ md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
+     case BFD_RELOC_MICROMIPS_TLS_GOTTPREL:
+     case BFD_RELOC_MICROMIPS_TLS_TPREL_HI16:
+     case BFD_RELOC_MICROMIPS_TLS_TPREL_LO16:
++    case BFD_RELOC_MIPS16_TLS_GD:
++    case BFD_RELOC_MIPS16_TLS_LDM:
++    case BFD_RELOC_MIPS16_TLS_DTPREL_HI16:
++    case BFD_RELOC_MIPS16_TLS_DTPREL_LO16:
++    case BFD_RELOC_MIPS16_TLS_GOTTPREL:
++    case BFD_RELOC_MIPS16_TLS_TPREL_HI16:
++    case BFD_RELOC_MIPS16_TLS_TPREL_LO16:
+       S_SET_THREAD_LOCAL (fixP->fx_addsy);
+       /* fall through */
+ 
+@@ -16547,12 +16567,14 @@ s_cpreturn (int ignore ATTRIBUTE_UNUSED)
+   demand_empty_rest_of_line ();
+ }
+ 
+-/* Handle the .dtprelword and .dtpreldword pseudo-ops.  They generate
+-   a 32-bit or 64-bit DTP-relative relocation (BYTES says which) for
+-   use in DWARF debug information.  */
++/* Handle a .dtprelword, .dtpreldword, .tprelword, or .tpreldword
++   pseudo-op; DIRSTR says which. The pseudo-op generates a BYTES-size
++   DTP- or TP-relative relocation of type RTYPE, for use in either DWARF
++   debug information or MIPS16 TLS.  */
+ 
+ static void
+-s_dtprel_internal (size_t bytes)
++s_tls_rel_directive (const size_t bytes, const char *dirstr,
++		     bfd_reloc_code_real_type rtype)
+ {
+   expressionS ex;
+   char *p;
+@@ -16561,20 +16583,15 @@ s_dtprel_internal (size_t bytes)
+ 
+   if (ex.X_op != O_symbol)
+     {
+-      as_bad (_("Unsupported use of %s"), (bytes == 8
+-					   ? ".dtpreldword"
+-					   : ".dtprelword"));
++      as_bad (_("Unsupported use of %s"), dirstr);
+       ignore_rest_of_line ();
+     }
+ 
+   p = frag_more (bytes);
+   md_number_to_chars (p, 0, bytes);
+-  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE,
+-	       (bytes == 8
+-		? BFD_RELOC_MIPS_TLS_DTPREL64
+-		: BFD_RELOC_MIPS_TLS_DTPREL32));
+-
++  fix_new_exp (frag_now, p - frag_now->fr_literal, bytes, &ex, FALSE, rtype);
+   demand_empty_rest_of_line ();
++  mips_clear_insn_labels ();
+ }
+ 
+ /* Handle .dtprelword.  */
+@@ -16582,7 +16599,7 @@ s_dtprel_internal (size_t bytes)
+ static void
+ s_dtprelword (int ignore ATTRIBUTE_UNUSED)
+ {
+-  s_dtprel_internal (4);
++  s_tls_rel_directive (4, ".dtprelword", BFD_RELOC_MIPS_TLS_DTPREL32);
+ }
+ 
+ /* Handle .dtpreldword.  */
+@@ -16590,7 +16607,23 @@ s_dtprelword (int ignore ATTRIBUTE_UNUSED)
+ static void
+ s_dtpreldword (int ignore ATTRIBUTE_UNUSED)
+ {
+-  s_dtprel_internal (8);
++  s_tls_rel_directive (8, ".dtpreldword", BFD_RELOC_MIPS_TLS_DTPREL64);
++}
++
++/* Handle .tprelword.  */
++
++static void
++s_tprelword (int ignore ATTRIBUTE_UNUSED)
++{
++  s_tls_rel_directive (4, ".tprelword", BFD_RELOC_MIPS_TLS_TPREL32);
++}
++
++/* Handle .tpreldword.  */
++
++static void
++s_tpreldword (int ignore ATTRIBUTE_UNUSED)
++{
++  s_tls_rel_directive (8, ".tpreldword", BFD_RELOC_MIPS_TLS_TPREL64);
+ }
+ 
+ /* Handle the .gpvalue pseudo-op.  This is used when generating NewABI PIC
+diff --git a/gas/testsuite/ChangeLog b/gas/testsuite/ChangeLog
+index 0631572..cbb2309 100644
+--- a/gas/testsuite/ChangeLog
++++ b/gas/testsuite/ChangeLog
+@@ -1,3 +1,8 @@
++2012-01-08  Richard Sandiford  <rdsandiford@googlemail.com>
++
++	* gas/mips/tls-relw.s, gas/mips/tls-relw.d: New test.
++	* gas/mips/mips.exp: Run it.
++
+ 2011-11-14  Maciej W. Rozycki  <macro@codesourcery.com>
+ 
+ 	Apply mainline patches
+diff --git a/gas/testsuite/gas/mips/mips.exp b/gas/testsuite/gas/mips/mips.exp
+index cbaaa70..2f49a2a 100644
+--- a/gas/testsuite/gas/mips/mips.exp
++++ b/gas/testsuite/gas/mips/mips.exp
+@@ -878,6 +878,7 @@ if { [istarget mips*-*-vxworks*] } {
+ 
+ 	run_list_test "tls-ill" "-32"
+ 	run_dump_test "tls-o32"
++	run_dump_test "tls-relw"
+ 	run_dump_test "jalr2"
+ 
+ 	run_dump_test_arches "aent"	[mips_arch_list_matching mips1]
+diff --git a/gas/testsuite/gas/mips/tls-relw.d b/gas/testsuite/gas/mips/tls-relw.d
+new file mode 100644
+index 0000000..bc13b43
+--- /dev/null
++++ b/gas/testsuite/gas/mips/tls-relw.d
+@@ -0,0 +1,8 @@
++# as: -EB
++# objdump: -sj.data
++
++.*
++
++Contents of section \.data:
++ 0000 00000001 00000000 00000002 00000004  ................
++ 0010 00000000 00000003 00000010 00000000  ................
+diff --git a/gas/testsuite/gas/mips/tls-relw.s b/gas/testsuite/gas/mips/tls-relw.s
+new file mode 100644
+index 0000000..6890685
+--- /dev/null
++++ b/gas/testsuite/gas/mips/tls-relw.s
+@@ -0,0 +1,12 @@
++	.data
++start:
++	.word	1
++a:
++	.tprelword t1
++	.word	2
++	.word	a-start
++b:
++	.dtprelword t2
++	.word	3
++	.word	b-start
++	.word	0
+diff --git a/gold/ChangeLog b/gold/ChangeLog
+index 7f91606..437cf97 100644
+--- a/gold/ChangeLog
++++ b/gold/ChangeLog
+@@ -1,3 +1,185 @@
++2012-04-27  Doug Kwan  <dougkwan@google.com>
++
++	Backport from mainline:
++
++	2012-03-16  Doug Kwan  <dougkwan@google.com>
++
++		* testsuite/Makefile.am: Disable test initpri3b.
++		* testsuite/Makefile.in: Regenerate.
++
++	2012-03-14  Doug Kwan  <dougkwan@google.com>
++
++		* gold/arm.cc (Target_arm::Scan::global): Generate
++		 R_ARM_GLOB_DAT dynamic relocations for protected symbols in
++		shared objects.
++
++2012-04-06  Ian Lance Taylor  <iant@google.com>
++
++	* timer.cc: #include <unistd.h>.
++
++2011-12-19  Ian Lance Taylor  <iant@google.com>
++
++	Copy from mainline to binutils 2.22 branch:
++
++	2011-12-17  Cary Coutant  <ccoutant@google.com>
++
++	* dwarf_reader.cc (Sized_dwarf_line_info::read_lines): Add casts.
++	* resolve.cc (Symbol_table::resolve): Likewise.
++	* i386.cc (Target_i386::do_code_fill): Use char constants for nop
++	arrays.
++	* x86_64.cc (Target_x86_64::do_code_fill): Likewise.
++
++	2011-10-31  Cary Coutant  <ccoutant@google.com>
++
++	PR gold/13023
++	* expression.cc (Expression::eval_with_dot): Add
++	is_section_dot_assignment parameter.
++	(Expression::eval_maybe_dot): Likewise.  Adjust value when rhs is
++	absolute and assigning to dot within a section.
++	* script-sections.cc
++	(Output_section_element_assignment::set_section_addresses): Pass
++	dot_section to set_if_absolute.
++	(Output_section_element_dot_assignment::finalize_symbols): Pass TRUE
++	as is_section_dot_assignment flag to eval_with_dot.
++	(Output_section_element_dot_assignment::set_section_addresses):
++	Likewise.
++	* script.cc (Symbol_assignment::set_if_absolute): Add dot_section
++	parameter.  Also set value if relative to dot_section; set the
++	symbol's output_section.
++	* script.h (Expression::eval_with_dot): Add is_section_dot_assignment
++	parameter.  Adjust all callers.
++	(Expression::eval_maybe_dot): Likewise.
++	(Symbol_assignment::set_if_absolute): Add dot_section parameter.
++	Adjust all callers.
++	* testsuite/script_test_2.t: Test assignment of an absolute value
++	to dot within an output section element.
++
++	2011-10-31  Cary Coutant  <ccoutant@google.com>
++
++	* options.h (class General_options): Add --[no-]gnu-unique options.
++	* symtab.cc (Symbol_table::sized_write_globals): Convert
++	STB_GNU_UNIQUE to STB_GLOBAL if --no-gnu-unique.
++
++	2011-10-31  Cary Coutant  <ccoutant@google.com>
++
++	PR gold/13359
++	* i386.cc (Target_i386::Relocate::relocate_tls): Remove
++	unnecessary assertion.
++	* x86_64.cc (Target_x86_64::Relocate::relocate_tls): Likewise.
++
++	2011-10-31 Sriraman Tallam  <tmsriram@google.com>
++
++	* symtab.h (Symbol_table::gc_mark_symbol_for_shlib): Rename to
++	gc_mark_symbol.
++	* symtab.cc (Symbol_table::gc_mark_symbol_for_shlib): Rename to
++	gc_mark_symbol.
++	Change to just keep the section associated with symbol.
++	(Symbol_table::add_from_relobj): Mark symbols as not garbage when
++	they are externally visible and --export-dynamic is turned on.
++	(Symbol_table::gc_mark_dyn_syms): Call gc_mark_symbol.
++
++	2011-10-19  Ian Lance Taylor  <iant@google.com>
++
++	PR gold/13163
++	* script-sections.cc
++	(Output_section_element_dot_assignment::needs_output_section): New
++	function.
++
++	2011-10-19  Ian Lance Taylor  <iant@google.com>
++
++	PR gold/13204
++	* layout.cc (Layout::segment_precedes): Don't assert failure if a
++	--section-start option was seen.
++	* options.h (General_options::any_section_start): New function.
++
++	2011-10-18  Cary Coutant  <ccoutant@google.com>
++
++	* output.cc (posix_fallocate): Return 0 on success, errno on failure.
++	(Output_file::map_no_anonymous): Check for non-zero
++	return code from posix_fallocate.
++
++	2011-10-17  Cary Coutant  <ccoutant@google.com>
++
++	PR gold/13245
++	* plugin.cc (is_visible_from_outside): Check for symbols
++	referenced from dynamic objects.
++	* resolve.cc (Symbol_table::resolve): Don't count references
++	from dynamic objects as references from real ELF files.
++	* testsuite/plugin_test_2.sh: Adjust expected result.
++
++	2011-10-17  Cary Coutant  <ccoutant@google.com>
++
++	* readsyms.cc (Read_symbols::run): Don't queue an unblocker
++	task for members of lib groups.
++
++	2011-10-17  Cary Coutant  <ccoutant@google.com>
++
++	PR gold/13288
++	* fileread.cc (File_read::find_view): Add assert.
++	(File_read::make_view): Move bounds check (replace with assert)...
++	(File_read::find_or_make_view): ... to here.
++
++	2011-10-12  Cary Coutant  <ccoutant@google.com>
++
++	* output.cc (Output_file::open_base_file): Handle case where
++	::read returns less than requested size.
++
++	2011-10-10  Cary Coutant  <ccoutant@google.com>
++
++	* incremental.cc (Sized_relobj_incr::Sized_relobj_incr):
++	Initialize defined_count_.
++	(Sized_relobj_incr::do_add_symbols): Count defined symbols.
++	(Sized_relobj_incr::do_get_global_symbol_counts): Rewrite.
++	(Sized_incr_dynobj::Sized_incr_dynobj): Initialize defined_count_.
++	(Sized_incr_dynobj::do_add_symbols): Count defined symbols.
++	(Sized_incr_dynobj::do_get_global_symbol_counts): Rewrite.
++	* incremental.h (Sized_relobj_incr::defined_count_): New data
++	member.
++	(Sized_incr_dynobj::defined_count_): New data member.
++	* plugin.cc (Sized_pluginobj::do_get_global_symbol_counts):
++	Return zeroes instead of internal error.
++
++	2011-10-10  Cary Coutant  <ccoutant@google.com>
++
++	PR gold/13249
++	* output.cc (Output_reloc::Output_reloc): Add use_plt_offset flag.
++	(Output_reloc::symbol_value): Return PLT offset if flag is set.
++	* output.h (class Output_reloc): Add use_plt_offset flag.
++	(Output_reloc::type_): Adjust size of bit field.
++	(Output_reloc::use_plt_offset_): New bit field.
++	(class Output_data_reloc): Adjust all calls to Output_reloc_type.
++	(Output_data_reloc::add_local_relative): (RELA only) Add use_plt_offset
++	flag.  Adjust all callers.
++	* x86_64.cc (Target_x86_64::Scan::local): Check for IFUNC when
++	creating RELATIVE relocations.
++
++	2011-10-03   Diego Novillo  <dnovillo@google.com>
++
++	* options.cc (parse_uint): Fix dereference of RETVAL.
++
++	2011-09-29  Cary Coutant  <ccoutant@google.com>
++
++	* incremental.cc (Sized_incremental_binary::do_process_got_plt):
++	Check for NULL.
++	* symtab.cc (Symbol_table::add_from_relobj): Ignore version
++	symbols during incremental update.
++	(Symbol_table::add_from_dynobj): Likewise.
++
++	2011-09-26  Cary Coutant  <ccoutant@google.com>
++
++	* gold.cc (queue_initial_tasks): Move option checks ...
++	* options.cc (General_options::finalize): ... to here. Disable
++	some options; make others fatal.
++
++	2011-09-23  Simon Baldwin  <simonb@google.com>
++
++	* configure.ac: Add new --with-gold-ldadd and --with-gold-ldflags
++	configuration options.
++	* configure: Regenerate.
++	* Makefile.am: Handle GOLD_LDADD and GOLD_LDFLAGS.
++	* Makefile.in: Regenerate.
++	* testsuite/Makefile.in: Regenerate.
++
+ 2011-11-11  Doug Kwan  <dougkwan@google.com>
+ 
+ 	* arm.cc (Target_arm::do_make_elf_object): Allow executable also
+diff --git a/gold/arm.cc b/gold/arm.cc
+index 72c3670..a1e8e4c 100644
+--- a/gold/arm.cc
++++ b/gold/arm.cc
+@@ -8374,7 +8374,9 @@ Target_arm<big_endian>::Scan::global(Symbol_table* symtab,
+ 	    Reloc_section* rel_dyn = target->rel_dyn_section(layout);
+ 	    if (gsym->is_from_dynobj()
+ 		|| gsym->is_undefined()
+-		|| gsym->is_preemptible())
++		|| gsym->is_preemptible()
++		|| (gsym->visibility() == elfcpp::STV_PROTECTED
++		    && parameters->options().shared()))
+ 	      got->add_global_with_rel(gsym, GOT_TYPE_STANDARD,
+ 				       rel_dyn, elfcpp::R_ARM_GLOB_DAT);
+ 	    else
+diff --git a/gold/dwarf_reader.cc b/gold/dwarf_reader.cc
+index 3dc33e4..2b47a28 100644
+--- a/gold/dwarf_reader.cc
++++ b/gold/dwarf_reader.cc
+@@ -1,6 +1,6 @@
+ // dwarf_reader.cc -- parse dwarf2/3 debug information
+ 
+-// Copyright 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
++// Copyright 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+ // Written by Ian Lance Taylor <iant@google.com>.
+ 
+ // This file is part of gold.
+@@ -491,8 +491,10 @@ Sized_dwarf_line_info<size, big_endian>::read_lines(unsigned const char* lineptr
+               && (shndx == -1U || lsm.shndx == -1U || shndx == lsm.shndx))
+             {
+               Offset_to_lineno_entry entry
+-                  = { lsm.address, this->current_header_index_,
+-                      lsm.file_num, true, lsm.line_num };
++                  = { static_cast<off_t>(lsm.address),
++		      this->current_header_index_,
++		      static_cast<unsigned int>(lsm.file_num),
++		      true, lsm.line_num };
+ 	      std::vector<Offset_to_lineno_entry>&
+ 		map(this->line_number_map_[lsm.shndx]);
+ 	      // If we see two consecutive entries with the same
+diff --git a/gold/expression.cc b/gold/expression.cc
+index e527b5e..e31c151 100644
+--- a/gold/expression.cc
++++ b/gold/expression.cc
+@@ -1,6 +1,6 @@
+ // expression.cc -- expressions in linker scripts for gold
+ 
+-// Copyright 2006, 2007, 2008 Free Software Foundation, Inc.
++// Copyright 2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+ // Written by Ian Lance Taylor <iant@google.com>.
+ 
+ // This file is part of gold.
+@@ -77,7 +77,7 @@ Expression::eval(const Symbol_table* symtab, const Layout* layout,
+ 		 bool check_assertions)
+ {
+   return this->eval_maybe_dot(symtab, layout, check_assertions,
+-			      false, 0, NULL, NULL, NULL);
++			      false, 0, NULL, NULL, NULL, false);
+ }
+ 
+ // Evaluate an expression which may refer to the dot symbol.
+@@ -87,11 +87,13 @@ Expression::eval_with_dot(const Symbol_table* symtab, const Layout* layout,
+ 			  bool check_assertions, uint64_t dot_value,
+ 			  Output_section* dot_section,
+ 			  Output_section** result_section_pointer,
+-			  uint64_t* result_alignment_pointer)
++			  uint64_t* result_alignment_pointer,
++			  bool is_section_dot_assignment)
+ {
+   return this->eval_maybe_dot(symtab, layout, check_assertions, true,
+ 			      dot_value, dot_section, result_section_pointer,
+-			      result_alignment_pointer);
++			      result_alignment_pointer,
++			      is_section_dot_assignment);
+ }
+ 
+ // Evaluate an expression which may or may not refer to the dot
+@@ -102,7 +104,8 @@ Expression::eval_maybe_dot(const Symbol_table* symtab, const Layout* layout,
+ 			   bool check_assertions, bool is_dot_available,
+ 			   uint64_t dot_value, Output_section* dot_section,
+ 			   Output_section** result_section_pointer,
+-			   uint64_t* result_alignment_pointer)
++			   uint64_t* result_alignment_pointer,
++			   bool is_section_dot_assignment)
+ {
+   Expression_eval_info eei;
+   eei.symtab = symtab;
+@@ -113,14 +116,24 @@ Expression::eval_maybe_dot(const Symbol_table* symtab, const Layout* layout,
+   eei.dot_section = dot_section;
+ 
+   // We assume the value is absolute, and only set this to a section
+-  // if we find a section relative reference.
++  // if we find a section-relative reference.
+   if (result_section_pointer != NULL)
+     *result_section_pointer = NULL;
+   eei.result_section_pointer = result_section_pointer;
+ 
+   eei.result_alignment_pointer = result_alignment_pointer;
+ 
+-  return this->value(&eei);
++  uint64_t val = this->value(&eei);
++
++  // If this is an assignment to dot within a section, and the value
++  // is absolute, treat it as a section-relative offset.
++  if (is_section_dot_assignment && *result_section_pointer == NULL)
++    {
++      gold_assert(dot_section != NULL);
++      val += dot_section->address();
++      *result_section_pointer = dot_section;
++    }
++  return val;
+ }
+ 
+ // A number.
+@@ -257,7 +270,8 @@ class Unary_expression : public Expression
+ 				      eei->dot_value,
+ 				      eei->dot_section,
+ 				      arg_section_pointer,
+-				      eei->result_alignment_pointer);
++				      eei->result_alignment_pointer,
++				      false);
+   }
+ 
+   void
+@@ -336,7 +350,8 @@ class Binary_expression : public Expression
+ 				       eei->dot_value,
+ 				       eei->dot_section,
+ 				       section_pointer,
+-				       alignment_pointer);
++				       alignment_pointer,
++				       false);
+   }
+ 
+   uint64_t
+@@ -350,7 +365,8 @@ class Binary_expression : public Expression
+ 					eei->dot_value,
+ 					eei->dot_section,
+ 					section_pointer,
+-					alignment_pointer);
++					alignment_pointer,
++					false);
+   }
+ 
+   void
+@@ -500,7 +516,8 @@ class Trinary_expression : public Expression
+ 				       eei->dot_value,
+ 				       eei->dot_section,
+ 				       section_pointer,
+-				       NULL);
++				       NULL,
++				       false);
+   }
+ 
+   uint64_t
+@@ -514,7 +531,8 @@ class Trinary_expression : public Expression
+ 				       eei->dot_value,
+ 				       eei->dot_section,
+ 				       section_pointer,
+-				       alignment_pointer);
++				       alignment_pointer,
++				       false);
+   }
+ 
+   uint64_t
+@@ -528,7 +546,8 @@ class Trinary_expression : public Expression
+ 				       eei->dot_value,
+ 				       eei->dot_section,
+ 				       section_pointer,
+-				       alignment_pointer);
++				       alignment_pointer,
++				       false);
+   }
+ 
+   void
+diff --git a/gold/fileread.cc b/gold/fileread.cc
+index 80ddfbc..c5dc320 100644
+--- a/gold/fileread.cc
++++ b/gold/fileread.cc
+@@ -329,6 +329,10 @@ inline File_read::View*
+ File_read::find_view(off_t start, section_size_type size,
+ 		     unsigned int byteshift, File_read::View** vshifted) const
+ {
++  gold_assert(start <= this->size_
++	      && (static_cast<unsigned long long>(size)
++		  <= static_cast<unsigned long long>(this->size_ - start)));
++
+   if (vshifted != NULL)
+     *vshifted = NULL;
+ 
+@@ -456,16 +460,9 @@ File_read::make_view(off_t start, section_size_type size,
+ 		     unsigned int byteshift, bool cache)
+ {
+   gold_assert(size > 0);
+-
+-  // Check that start and end of the view are within the file.
+-  if (start > this->size_
+-      || (static_cast<unsigned long long>(size)
+-          > static_cast<unsigned long long>(this->size_ - start)))
+-    gold_fatal(_("%s: attempt to map %lld bytes at offset %lld exceeds "
+-                 "size of file; the file may be corrupt"),
+-		   this->filename().c_str(),
+-		   static_cast<long long>(size),
+-		   static_cast<long long>(start));
++  gold_assert(start <= this->size_
++	      && (static_cast<unsigned long long>(size)
++		  <= static_cast<unsigned long long>(this->size_ - start)));
+ 
+   off_t poff = File_read::page_offset(start);
+ 
+@@ -523,6 +520,16 @@ File_read::View*
+ File_read::find_or_make_view(off_t offset, off_t start,
+ 			     section_size_type size, bool aligned, bool cache)
+ {
++  // Check that start and end of the view are within the file.
++  if (start > this->size_
++      || (static_cast<unsigned long long>(size)
++          > static_cast<unsigned long long>(this->size_ - start)))
++    gold_fatal(_("%s: attempt to map %lld bytes at offset %lld exceeds "
++                 "size of file; the file may be corrupt"),
++		   this->filename().c_str(),
++		   static_cast<long long>(size),
++		   static_cast<long long>(start));
++
+   unsigned int byteshift;
+   if (offset == 0)
+     byteshift = 0;
+diff --git a/gold/gold.cc b/gold/gold.cc
+index 12f25b7..693ff79 100644
+--- a/gold/gold.cc
++++ b/gold/gold.cc
+@@ -197,46 +197,29 @@ queue_initial_tasks(const General_options& options,
+   // For incremental links, the base output file.
+   Incremental_binary* ibase = NULL;
+ 
+-  if (parameters->incremental())
+-    {
+-      if (options.relocatable())
+-	gold_error(_("incremental linking is incompatible with -r"));
+-      if (options.emit_relocs())
+-	gold_error(_("incremental linking is incompatible with --emit-relocs"));
+-      if (options.gc_sections())
+-	gold_error(_("incremental linking is incompatible with --gc-sections"));
+-      if (options.icf_enabled())
+-	gold_error(_("incremental linking is incompatible with --icf"));
+-      if (options.has_plugins())
+-	gold_error(_("incremental linking is incompatible with --plugin"));
+-      if (strcmp(options.compress_debug_sections(), "none") != 0)
+-	gold_error(_("incremental linking is incompatible with "
+-		     "--compress-debug-sections"));
+-
+-      if (parameters->incremental_update())
++  if (parameters->incremental_update())
++    {
++      Output_file* of = new Output_file(options.output_file_name());
++      if (of->open_base_file(options.incremental_base(), true))
+ 	{
+-	  Output_file* of = new Output_file(options.output_file_name());
+-	  if (of->open_base_file(options.incremental_base(), true))
+-	    {
+-	      ibase = open_incremental_binary(of);
+-	      if (ibase != NULL
+-		  && ibase->check_inputs(cmdline, layout->incremental_inputs()))
+-		ibase->init_layout(layout);
+-	      else
+-		{
+-		  delete ibase;
+-		  ibase = NULL;
+-		  of->close();
+-		}
+-	    }
+-	  if (ibase == NULL)
++	  ibase = open_incremental_binary(of);
++	  if (ibase != NULL
++	      && ibase->check_inputs(cmdline, layout->incremental_inputs()))
++	    ibase->init_layout(layout);
++	  else
+ 	    {
+-	      if (set_parameters_incremental_full())
+-		gold_info(_("linking with --incremental-full"));
+-	      else
+-		gold_fallback(_("restart link with --incremental-full"));
++	      delete ibase;
++	      ibase = NULL;
++	      of->close();
+ 	    }
+ 	}
++      if (ibase == NULL)
++	{
++	  if (set_parameters_incremental_full())
++	    gold_info(_("linking with --incremental-full"));
++	  else
++	    gold_fallback(_("restart link with --incremental-full"));
++	}
+     }
+ 
+   // Read the input files.  We have to add the symbols to the symbol
+diff --git a/gold/i386.cc b/gold/i386.cc
+index 445bc68..efb6248 100644
+--- a/gold/i386.cc
++++ b/gold/i386.cc
+@@ -2709,12 +2709,6 @@ Target_i386::Relocate::relocate_tls(const Relocate_info<32, false>* relinfo,
+             }
+           if (optimized_type == tls::TLSOPT_TO_IE)
+ 	    {
+-	      if (tls_segment == NULL)
+-		{
+-		  gold_assert(parameters->errors()->error_count() > 0
+-			      || issue_undefined_symbol_error(gsym));
+-		  return;
+-		}
+ 	      this->tls_gd_to_ie(relinfo, relnum, tls_segment, rel, r_type,
+                                  got_offset, view, view_size);
+               break;
+@@ -3480,42 +3474,51 @@ Target_i386::do_code_fill(section_size_type length) const
+     }
+ 
+   // Nop sequences of various lengths.
+-  const char nop1[1] = { 0x90 };                   // nop
+-  const char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
+-  const char nop3[3] = { 0x8d, 0x76, 0x00 };       // leal 0(%esi),%esi
+-  const char nop4[4] = { 0x8d, 0x74, 0x26, 0x00};  // leal 0(%esi,1),%esi
+-  const char nop5[5] = { 0x90, 0x8d, 0x74, 0x26,   // nop
+-                         0x00 };                   // leal 0(%esi,1),%esi
+-  const char nop6[6] = { 0x8d, 0xb6, 0x00, 0x00,   // leal 0L(%esi),%esi
+-                         0x00, 0x00 };
+-  const char nop7[7] = { 0x8d, 0xb4, 0x26, 0x00,   // leal 0L(%esi,1),%esi
+-                         0x00, 0x00, 0x00 };
+-  const char nop8[8] = { 0x90, 0x8d, 0xb4, 0x26,   // nop
+-                         0x00, 0x00, 0x00, 0x00 }; // leal 0L(%esi,1),%esi
+-  const char nop9[9] = { 0x89, 0xf6, 0x8d, 0xbc,   // movl %esi,%esi
+-                         0x27, 0x00, 0x00, 0x00,   // leal 0L(%edi,1),%edi
+-                         0x00 };
+-  const char nop10[10] = { 0x8d, 0x76, 0x00, 0x8d, // leal 0(%esi),%esi
+-                           0xbc, 0x27, 0x00, 0x00, // leal 0L(%edi,1),%edi
+-                           0x00, 0x00 };
+-  const char nop11[11] = { 0x8d, 0x74, 0x26, 0x00, // leal 0(%esi,1),%esi
+-                           0x8d, 0xbc, 0x27, 0x00, // leal 0L(%edi,1),%edi
+-                           0x00, 0x00, 0x00 };
+-  const char nop12[12] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
+-                           0x00, 0x00, 0x8d, 0xbf, // leal 0L(%edi),%edi
+-                           0x00, 0x00, 0x00, 0x00 };
+-  const char nop13[13] = { 0x8d, 0xb6, 0x00, 0x00, // leal 0L(%esi),%esi
+-                           0x00, 0x00, 0x8d, 0xbc, // leal 0L(%edi,1),%edi
+-                           0x27, 0x00, 0x00, 0x00,
+-                           0x00 };
+-  const char nop14[14] = { 0x8d, 0xb4, 0x26, 0x00, // leal 0L(%esi,1),%esi
+-                           0x00, 0x00, 0x00, 0x8d, // leal 0L(%edi,1),%edi
+-                           0xbc, 0x27, 0x00, 0x00,
+-                           0x00, 0x00 };
+-  const char nop15[15] = { 0xeb, 0x0d, 0x90, 0x90, // jmp .+15
+-                           0x90, 0x90, 0x90, 0x90, // nop,nop,nop,...
+-                           0x90, 0x90, 0x90, 0x90,
+-                           0x90, 0x90, 0x90 };
++  const char nop1[1] = { '\x90' };                   // nop
++  const char nop2[2] = { '\x66', '\x90' };           // xchg %ax %ax
++  const char nop3[3] = { '\x8d', '\x76', '\x00' };   // leal 0(%esi),%esi
++  const char nop4[4] = { '\x8d', '\x74', '\x26',     // leal 0(%esi,1),%esi
++			 '\x00'};
++  const char nop5[5] = { '\x90', '\x8d', '\x74',     // nop
++  			 '\x26', '\x00' };           // leal 0(%esi,1),%esi
++  const char nop6[6] = { '\x8d', '\xb6', '\x00',     // leal 0L(%esi),%esi
++  			 '\x00', '\x00', '\x00' };
++  const char nop7[7] = { '\x8d', '\xb4', '\x26',     // leal 0L(%esi,1),%esi
++  			 '\x00', '\x00', '\x00',
++			 '\x00' };
++  const char nop8[8] = { '\x90', '\x8d', '\xb4',     // nop
++  			 '\x26', '\x00', '\x00',     // leal 0L(%esi,1),%esi
++			 '\x00', '\x00' };
++  const char nop9[9] = { '\x89', '\xf6', '\x8d',     // movl %esi,%esi
++  			 '\xbc', '\x27', '\x00',     // leal 0L(%edi,1),%edi
++			 '\x00', '\x00', '\x00' };
++  const char nop10[10] = { '\x8d', '\x76', '\x00',   // leal 0(%esi),%esi
++  			   '\x8d', '\xbc', '\x27',   // leal 0L(%edi,1),%edi
++			   '\x00', '\x00', '\x00',
++			   '\x00' };
++  const char nop11[11] = { '\x8d', '\x74', '\x26',   // leal 0(%esi,1),%esi
++  			   '\x00', '\x8d', '\xbc',   // leal 0L(%edi,1),%edi
++			   '\x27', '\x00', '\x00',
++			   '\x00', '\x00' };
++  const char nop12[12] = { '\x8d', '\xb6', '\x00',   // leal 0L(%esi),%esi
++  			   '\x00', '\x00', '\x00',   // leal 0L(%edi),%edi
++			   '\x8d', '\xbf', '\x00',
++			   '\x00', '\x00', '\x00' };
++  const char nop13[13] = { '\x8d', '\xb6', '\x00',   // leal 0L(%esi),%esi
++  			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
++			   '\x8d', '\xbc', '\x27',
++			   '\x00', '\x00', '\x00',
++                           '\x00' };
++  const char nop14[14] = { '\x8d', '\xb4', '\x26',   // leal 0L(%esi,1),%esi
++  			   '\x00', '\x00', '\x00',   // leal 0L(%edi,1),%edi
++			   '\x00', '\x8d', '\xbc',
++			   '\x27', '\x00', '\x00',
++                           '\x00', '\x00' };
++  const char nop15[15] = { '\xeb', '\x0d', '\x90',   // jmp .+15
++  			   '\x90', '\x90', '\x90',   // nop,nop,nop,...
++			   '\x90', '\x90', '\x90',
++			   '\x90', '\x90', '\x90',
++                           '\x90', '\x90', '\x90' };
+ 
+   const char* nops[16] = {
+     NULL,
+diff --git a/gold/incremental.cc b/gold/incremental.cc
+index b422827..75e44c5 100644
+--- a/gold/incremental.cc
++++ b/gold/incremental.cc
+@@ -685,7 +685,7 @@ Sized_incremental_binary<size, big_endian>::do_process_got_plt(
+       gold_assert(plt_desc >= first_global && plt_desc < symtab_count);
+       Symbol* sym = this->global_symbol(plt_desc - first_global);
+       // Add the PLT entry only if the symbol is still referenced.
+-      if (sym->in_reg())
++      if (sym != NULL && sym->in_reg())
+ 	{
+ 	  gold_debug(DEBUG_INCREMENTAL,
+ 		     "PLT entry %d: %s",
+@@ -1966,8 +1966,9 @@ Sized_relobj_incr<size, big_endian>::Sized_relobj_incr(
+     input_reader_(ibase->inputs_reader().input_file(input_file_index)),
+     local_symbol_count_(0), output_local_dynsym_count_(0),
+     local_symbol_index_(0), local_symbol_offset_(0), local_dynsym_offset_(0),
+-    symbols_(), incr_reloc_offset_(-1U), incr_reloc_count_(0),
+-    incr_reloc_output_index_(0), incr_relocs_(NULL), local_symbols_()
++    symbols_(), defined_count_(0), incr_reloc_offset_(-1U),
++    incr_reloc_count_(0), incr_reloc_output_index_(0), incr_relocs_(NULL),
++    local_symbols_()
+ {
+   if (this->input_reader_.is_in_system_directory())
+     this->set_is_in_system_directory();
+@@ -2120,6 +2121,9 @@ Sized_relobj_incr<size, big_endian>::do_add_symbols(
+ 
+       Symbol* res = symtab->add_from_incrobj(this, name, NULL, &sym);
+ 
++      if (shndx != elfcpp::SHN_UNDEF)
++        ++this->defined_count_;
++
+       // If this is a linker-defined symbol that hasn't yet been defined,
+       // define it now.
+       if (input_shndx == -1U && !res->is_defined())
+@@ -2283,9 +2287,21 @@ Sized_relobj_incr<size, big_endian>::do_initialize_xindex()
+ template<int size, bool big_endian>
+ void
+ Sized_relobj_incr<size, big_endian>::do_get_global_symbol_counts(
+-    const Symbol_table*, size_t*, size_t*) const
+-{
+-  gold_unreachable();
++    const Symbol_table*,
++    size_t* defined,
++    size_t* used) const
++{
++  *defined = this->defined_count_;
++  size_t count = 0;
++  for (typename Symbols::const_iterator p = this->symbols_.begin();
++       p != this->symbols_.end();
++       ++p)
++    if (*p != NULL
++	&& (*p)->source() == Symbol::FROM_OBJECT
++	&& (*p)->object() == this
++	&& (*p)->is_defined())
++      ++count;
++  *used = count;
+ }
+ 
+ // Read the relocs.
+@@ -2579,7 +2595,7 @@ Sized_incr_dynobj<size, big_endian>::Sized_incr_dynobj(
+   : Dynobj(name, NULL), ibase_(ibase),
+     input_file_index_(input_file_index),
+     input_reader_(ibase->inputs_reader().input_file(input_file_index)),
+-    symbols_()
++    symbols_(), defined_count_(0)
+ {
+   if (this->input_reader_.is_in_system_directory())
+     this->set_is_in_system_directory();
+@@ -2677,6 +2693,7 @@ Sized_incr_dynobj<size, big_endian>::do_add_symbols(
+ 	  // is meaningless, as long as it's not SHN_UNDEF.
+ 	  shndx = 1;
+ 	  v = gsym.get_st_value();
++	  ++this->defined_count_;
+ 	}
+ 
+       osym.put_st_name(0);
+@@ -2845,9 +2862,22 @@ Sized_incr_dynobj<size, big_endian>::do_initialize_xindex()
+ template<int size, bool big_endian>
+ void
+ Sized_incr_dynobj<size, big_endian>::do_get_global_symbol_counts(
+-    const Symbol_table*, size_t*, size_t*) const
+-{
+-  gold_unreachable();
++    const Symbol_table*,
++    size_t* defined,
++    size_t* used) const
++{
++  *defined = this->defined_count_;
++  size_t count = 0;
++  for (typename Symbols::const_iterator p = this->symbols_.begin();
++       p != this->symbols_.end();
++       ++p)
++    if (*p != NULL
++	&& (*p)->source() == Symbol::FROM_OBJECT
++	&& (*p)->object() == this
++	&& (*p)->is_defined()
++	&& (*p)->dynsym_index() != -1U)
++      ++count;
++  *used = count;
+ }
+ 
+ // Allocate an incremental object of the appropriate size and endianness.
+diff --git a/gold/incremental.h b/gold/incremental.h
+index e6732df..56fc52b 100644
+--- a/gold/incremental.h
++++ b/gold/incremental.h
+@@ -1996,6 +1996,8 @@ class Sized_relobj_incr : public Sized_relobj<size, big_endian>
+   unsigned int local_dynsym_offset_;
+   // The entries in the symbol table for the external symbols.
+   Symbols symbols_;
++  // Number of symbols defined in object file itself.
++  size_t defined_count_;
+   // The offset of the first incremental relocation for this object.
+   unsigned int incr_reloc_offset_;
+   // The number of incremental relocations for this object.
+@@ -2127,6 +2129,8 @@ class Sized_incr_dynobj : public Dynobj
+   Input_entry_reader input_reader_;
+   // The entries in the symbol table for the external symbols.
+   Symbols symbols_;
++  // Number of symbols defined in object file itself.
++  size_t defined_count_;
+ };
+ 
+ // Allocate an incremental object of the appropriate size and endianness.
+diff --git a/gold/layout.cc b/gold/layout.cc
+index 1c32bcf..9d8a43a 100644
+--- a/gold/layout.cc
++++ b/gold/layout.cc
+@@ -2975,8 +2975,9 @@ Layout::segment_precedes(const Output_segment* seg1,
+ 
+   // We shouldn't get here--we shouldn't create segments which we
+   // can't distinguish.  Unless of course we are using a weird linker
+-  // script.
+-  gold_assert(this->script_options_->saw_phdrs_clause());
++  // script or overlapping --section-start options.
++  gold_assert(this->script_options_->saw_phdrs_clause()
++	      || parameters->options().any_section_start());
+   return false;
+ }
+ 
+diff --git a/gold/options.cc b/gold/options.cc
+index be32645..dcf6ba7 100644
+--- a/gold/options.cc
++++ b/gold/options.cc
+@@ -198,7 +198,7 @@ parse_uint(const char* option_name, const char* arg, int* retval)
+ {
+   char* endptr;
+   *retval = strtol(arg, &endptr, 0);
+-  if (*endptr != '\0' || retval < 0)
++  if (*endptr != '\0' || *retval < 0)
+     gold_fatal(_("%s: invalid option value (expected an integer): %s"),
+                option_name, arg);
+ }
+@@ -1224,6 +1224,37 @@ General_options::finalize()
+     gold_fatal(_("Options --incremental-changed, --incremental-unchanged, "
+                  "--incremental-unknown require the use of --incremental"));
+ 
++  // Check for options that are not compatible with incremental linking.
++  // Where an option can be disabled without seriously changing the semantics
++  // of the link, we turn the option off; otherwise, we issue a fatal error.
++
++  if (this->incremental_mode_ != INCREMENTAL_OFF)
++    {
++      if (this->relocatable())
++	gold_fatal(_("incremental linking is not compatible with -r"));
++      if (this->emit_relocs())
++	gold_fatal(_("incremental linking is not compatible with "
++		     "--emit-relocs"));
++      if (this->has_plugins())
++	gold_fatal(_("incremental linking is not compatible with --plugin"));
++      if (this->gc_sections())
++	{
++	  gold_warning(_("ignoring --gc-sections for an incremental link"));
++	  this->set_gc_sections(false);
++	}
++      if (this->icf_enabled())
++	{
++	  gold_warning(_("ignoring --icf for an incremental link"));
++	  this->set_icf_status(ICF_NONE);
++	}
++      if (strcmp(this->compress_debug_sections(), "none") != 0)
++	{
++	  gold_warning(_("ignoring --compress-debug-sections for an "
++			 "incremental link"));
++	  this->set_compress_debug_sections("none");
++	}
++    }
++
+   // FIXME: we can/should be doing a lot more sanity checking here.
+ }
+ 
+diff --git a/gold/options.h b/gold/options.h
+index 768df9c..8876a1e 100644
+--- a/gold/options.h
++++ b/gold/options.h
+@@ -791,6 +791,10 @@ class General_options
+   DEFINE_bool(g, options::EXACTLY_ONE_DASH, '\0', false,
+ 	      N_("Ignored"), NULL);
+ 
++  DEFINE_bool(gnu_unique, options::TWO_DASHES, '\0', true,
++	      N_("Enable STB_GNU_UNIQUE symbol binding (default)"),
++	      N_("Disable STB_GNU_UNIQUE symbol binding"));
++
+   DEFINE_string(soname, options::ONE_DASH, 'h', NULL,
+                 N_("Set shared library name"), N_("FILENAME"));
+ 
+@@ -1385,6 +1389,11 @@ class General_options
+   bool
+   section_start(const char* secname, uint64_t* paddr) const;
+ 
++  // Return whether any --section-start option was used.
++  bool
++  any_section_start() const
++  { return !this->section_starts_.empty(); }
++
+   enum Fix_v4bx
+   {
+     // Leave original instruction.
+diff --git a/gold/output.cc b/gold/output.cc
+index 29d8e3d..a7e1e9a 100644
+--- a/gold/output.cc
++++ b/gold/output.cc
+@@ -119,7 +119,9 @@ extern "C" void *gold_mremap(void *, size_t, size_t, int);
+ static int
+ posix_fallocate(int o, off_t offset, off_t len)
+ {
+-  return ftruncate(o, offset + len);
++  if (ftruncate(o, offset + len) < 0)
++    return errno;
++  return 0;
+ }
+ #endif // !defined(HAVE_POSIX_FALLOCATE)
+ 
+@@ -706,7 +708,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     bool is_symbolless)
+   : address_(address), local_sym_index_(GSYM_CODE), type_(type),
+     is_relative_(is_relative), is_symbolless_(is_symbolless),
+-    is_section_symbol_(false), shndx_(INVALID_CODE)
++    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
+ {
+   // this->type_ is a bitfield; make sure TYPE fits.
+   gold_assert(this->type_ == type);
+@@ -727,7 +729,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     bool is_symbolless)
+   : address_(address), local_sym_index_(GSYM_CODE), type_(type),
+     is_relative_(is_relative), is_symbolless_(is_symbolless),
+-    is_section_symbol_(false), shndx_(shndx)
++    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
+ {
+   gold_assert(shndx != INVALID_CODE);
+   // this->type_ is a bitfield; make sure TYPE fits.
+@@ -749,10 +751,12 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address,
+     bool is_relative,
+     bool is_symbolless,
+-    bool is_section_symbol)
++    bool is_section_symbol,
++    bool use_plt_offset)
+   : address_(address), local_sym_index_(local_sym_index), type_(type),
+     is_relative_(is_relative), is_symbolless_(is_symbolless),
+-    is_section_symbol_(is_section_symbol), shndx_(INVALID_CODE)
++    is_section_symbol_(is_section_symbol), use_plt_offset_(use_plt_offset),
++    shndx_(INVALID_CODE)
+ {
+   gold_assert(local_sym_index != GSYM_CODE
+               && local_sym_index != INVALID_CODE);
+@@ -773,10 +777,12 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address,
+     bool is_relative,
+     bool is_symbolless,
+-    bool is_section_symbol)
++    bool is_section_symbol,
++    bool use_plt_offset)
+   : address_(address), local_sym_index_(local_sym_index), type_(type),
+     is_relative_(is_relative), is_symbolless_(is_symbolless),
+-    is_section_symbol_(is_section_symbol), shndx_(shndx)
++    is_section_symbol_(is_section_symbol), use_plt_offset_(use_plt_offset),
++    shndx_(shndx)
+ {
+   gold_assert(local_sym_index != GSYM_CODE
+               && local_sym_index != INVALID_CODE);
+@@ -799,7 +805,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address)
+   : address_(address), local_sym_index_(SECTION_CODE), type_(type),
+     is_relative_(false), is_symbolless_(false),
+-    is_section_symbol_(true), shndx_(INVALID_CODE)
++    is_section_symbol_(true), use_plt_offset_(false), shndx_(INVALID_CODE)
+ {
+   // this->type_ is a bitfield; make sure TYPE fits.
+   gold_assert(this->type_ == type);
+@@ -820,7 +826,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address)
+   : address_(address), local_sym_index_(SECTION_CODE), type_(type),
+     is_relative_(false), is_symbolless_(false),
+-    is_section_symbol_(true), shndx_(shndx)
++    is_section_symbol_(true), use_plt_offset_(false), shndx_(shndx)
+ {
+   gold_assert(shndx != INVALID_CODE);
+   // this->type_ is a bitfield; make sure TYPE fits.
+@@ -842,7 +848,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address)
+   : address_(address), local_sym_index_(0), type_(type),
+     is_relative_(false), is_symbolless_(false),
+-    is_section_symbol_(false), shndx_(INVALID_CODE)
++    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
+ {
+   // this->type_ is a bitfield; make sure TYPE fits.
+   gold_assert(this->type_ == type);
+@@ -858,7 +864,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address)
+   : address_(address), local_sym_index_(0), type_(type),
+     is_relative_(false), is_symbolless_(false),
+-    is_section_symbol_(false), shndx_(shndx)
++    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
+ {
+   gold_assert(shndx != INVALID_CODE);
+   // this->type_ is a bitfield; make sure TYPE fits.
+@@ -877,7 +883,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address)
+   : address_(address), local_sym_index_(TARGET_CODE), type_(type),
+     is_relative_(false), is_symbolless_(false),
+-    is_section_symbol_(false), shndx_(INVALID_CODE)
++    is_section_symbol_(false), use_plt_offset_(false), shndx_(INVALID_CODE)
+ {
+   // this->type_ is a bitfield; make sure TYPE fits.
+   gold_assert(this->type_ == type);
+@@ -894,7 +900,7 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::Output_reloc(
+     Address address)
+   : address_(address), local_sym_index_(TARGET_CODE), type_(type),
+     is_relative_(false), is_symbolless_(false),
+-    is_section_symbol_(false), shndx_(shndx)
++    is_section_symbol_(false), use_plt_offset_(false), shndx_(shndx)
+ {
+   gold_assert(shndx != INVALID_CODE);
+   // this->type_ is a bitfield; make sure TYPE fits.
+@@ -1121,6 +1127,12 @@ Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>::symbol_value(
+   Sized_relobj_file<size, big_endian>* relobj =
+       this->u1_.relobj->sized_relobj();
+   gold_assert(relobj != NULL);
++  if (this->use_plt_offset_)
++    {
++      uint64_t plt_address =
++	  parameters->target().plt_address_for_local(relobj, lsi);
++      return plt_address + relobj->local_plt_offset(lsi);
++    }
+   const Symbol_value<size>* symval = relobj->local_symbol(lsi);
+   return symval->value(relobj, addend);
+ }
+@@ -4880,17 +4892,27 @@ Output_file::open_base_file(const char* base_name, bool writable)
+   if (use_base_file)
+     {
+       this->open(s.st_size);
+-      ssize_t len = ::read(o, this->base_, s.st_size);
+-      if (len < 0)
+-        {
+-	  gold_info(_("%s: read failed: %s"), base_name, strerror(errno));
+-	  return false;
+-        }
+-      if (len < s.st_size)
+-        {
+-	  gold_info(_("%s: file too short"), base_name);
+-	  return false;
+-        }
++      ssize_t bytes_to_read = s.st_size;
++      unsigned char* p = this->base_;
++      while (bytes_to_read > 0)
++	{
++	  ssize_t len = ::read(o, p, bytes_to_read);
++	  if (len < 0)
++	    {
++	      gold_info(_("%s: read failed: %s"), base_name, strerror(errno));
++	      return false;
++	    }
++	  if (len == 0)
++	    {
++	      gold_info(_("%s: file too short: read only %lld of %lld bytes"),
++			base_name,
++			static_cast<long long>(s.st_size - bytes_to_read),
++			static_cast<long long>(s.st_size));
++	      return false;
++	    }
++	  p += len;
++	  bytes_to_read -= len;
++	}
+       ::close(o);
+       return true;
+     }
+@@ -5052,8 +5074,12 @@ Output_file::map_no_anonymous(bool writable)
+   // output file will wind up incomplete, but we will have already
+   // exited.  The alternative to fallocate would be to use fdatasync,
+   // but that would be a more significant performance hit.
+-  if (writable && ::posix_fallocate(o, 0, this->file_size_) < 0)
+-    gold_fatal(_("%s: %s"), this->name_, strerror(errno));
++  if (writable)
++    {
++      int err = ::posix_fallocate(o, 0, this->file_size_);
++      if (err != 0)
++       gold_fatal(_("%s: %s"), this->name_, strerror(err));
++    }
+ 
+   // Map the file into memory.
+   int prot = PROT_READ;
+diff --git a/gold/output.h b/gold/output.h
+index 1bec2c0..e2d35e2 100644
+--- a/gold/output.h
++++ b/gold/output.h
+@@ -1033,12 +1033,14 @@ class Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+   Output_reloc(Sized_relobj<size, big_endian>* relobj,
+ 	       unsigned int local_sym_index, unsigned int type,
+ 	       Output_data* od, Address address, bool is_relative,
+-               bool is_symbolless, bool is_section_symbol);
++               bool is_symbolless, bool is_section_symbol,
++               bool use_plt_offset);
+ 
+   Output_reloc(Sized_relobj<size, big_endian>* relobj,
+ 	       unsigned int local_sym_index, unsigned int type,
+ 	       unsigned int shndx, Address address, bool is_relative,
+-               bool is_symbolless, bool is_section_symbol);
++               bool is_symbolless, bool is_section_symbol,
++               bool use_plt_offset);
+ 
+   // A reloc against the STT_SECTION symbol of an output section.
+ 
+@@ -1216,7 +1218,7 @@ class Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+   // input file.
+   unsigned int local_sym_index_;
+   // The reloc type--a processor specific code.
+-  unsigned int type_ : 29;
++  unsigned int type_ : 28;
+   // True if the relocation is a RELATIVE relocation.
+   bool is_relative_ : 1;
+   // True if the relocation is one which should not use
+@@ -1224,6 +1226,10 @@ class Output_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+   bool is_symbolless_ : 1;
+   // True if the relocation is against a section symbol.
+   bool is_section_symbol_ : 1;
++  // True if the addend should be the PLT offset.  This is used only
++  // for RELATIVE relocations to local symbols.
++  // (Used only for RELA, but stored here for space.)
++  bool use_plt_offset_ : 1;
+   // If the reloc address is an input section in an object, the
+   // section index.  This is INVALID_CODE if the reloc address is
+   // specified in some other way.
+@@ -1268,9 +1274,10 @@ class Output_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 	       unsigned int local_sym_index, unsigned int type,
+ 	       Output_data* od, Address address,
+ 	       Addend addend, bool is_relative,
+-	       bool is_symbolless, bool is_section_symbol)
++	       bool is_symbolless, bool is_section_symbol,
++	       bool use_plt_offset)
+     : rel_(relobj, local_sym_index, type, od, address, is_relative,
+-           is_symbolless, is_section_symbol),
++           is_symbolless, is_section_symbol, use_plt_offset),
+       addend_(addend)
+   { }
+ 
+@@ -1278,9 +1285,10 @@ class Output_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 	       unsigned int local_sym_index, unsigned int type,
+ 	       unsigned int shndx, Address address,
+ 	       Addend addend, bool is_relative,
+-	       bool is_symbolless, bool is_section_symbol)
++	       bool is_symbolless, bool is_section_symbol,
++	       bool use_plt_offset)
+     : rel_(relobj, local_sym_index, type, shndx, address, is_relative,
+-           is_symbolless, is_section_symbol),
++           is_symbolless, is_section_symbol, use_plt_offset),
+       addend_(addend)
+   { }
+ 
+@@ -1571,7 +1579,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+ 	    Output_data* od, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
+-                                    address, false, false, false));
++                                    address, false, false, false, false));
+   }
+ 
+   void
+@@ -1580,7 +1588,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+ 	    Output_data* od, unsigned int shndx, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
+-				    address, false, false, false));
++				    address, false, false, false, false));
+   }
+ 
+   // Add a RELATIVE reloc against a local symbol.
+@@ -1591,7 +1599,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+ 	             Output_data* od, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
+-                                    address, true, true, false));
++                                    address, true, true, false, false));
+   }
+ 
+   void
+@@ -1600,7 +1608,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+ 	             Output_data* od, unsigned int shndx, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
+-				    address, true, true, false));
++				    address, true, true, false, false));
+   }
+ 
+   // Add a local relocation which does not use a symbol for the relocation,
+@@ -1612,7 +1620,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+ 			      Output_data* od, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, od,
+-                                    address, false, true, false));
++                                    address, false, true, false, false));
+   }
+ 
+   void
+@@ -1622,7 +1630,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+ 			      Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
+-				    address, false, true, false));
++				    address, false, true, false, false));
+   }
+ 
+   // Add a reloc against a local section symbol.  This will be
+@@ -1635,7 +1643,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+                     Output_data* od, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, input_shndx, type, od,
+-                                    address, false, false, true));
++                                    address, false, false, true, false));
+   }
+ 
+   void
+@@ -1644,7 +1652,7 @@ class Output_data_reloc<elfcpp::SHT_REL, dynamic, size, big_endian>
+                     Output_data* od, unsigned int shndx, Address address)
+   {
+     this->add(od, Output_reloc_type(relobj, input_shndx, type, shndx,
+-                                    address, false, false, true));
++                                    address, false, false, true, false));
+   }
+ 
+   // A reloc against the STT_SECTION symbol of an output section.
+@@ -1767,7 +1775,7 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 	    Output_data* od, Address address, Addend addend)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
+-				    addend, false, false, false));
++				    addend, false, false, false, false));
+   }
+ 
+   void
+@@ -1777,7 +1785,8 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 	    Addend addend)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
+-                                    address, addend, false, false, false));
++                                    address, addend, false, false, false,
++                                    false));
+   }
+ 
+   // Add a RELATIVE reloc against a local symbol.
+@@ -1785,20 +1794,23 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+   void
+   add_local_relative(Sized_relobj<size, big_endian>* relobj,
+ 	             unsigned int local_sym_index, unsigned int type,
+-	             Output_data* od, Address address, Addend addend)
++	             Output_data* od, Address address, Addend addend,
++	             bool use_plt_offset)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
+-				    addend, true, true, false));
++				    addend, true, true, false,
++				    use_plt_offset));
+   }
+ 
+   void
+   add_local_relative(Sized_relobj<size, big_endian>* relobj,
+ 	             unsigned int local_sym_index, unsigned int type,
+ 	             Output_data* od, unsigned int shndx, Address address,
+-	             Addend addend)
++	             Addend addend, bool use_plt_offset)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
+-                                    address, addend, true, true, false));
++                                    address, addend, true, true, false,
++                                    use_plt_offset));
+   }
+ 
+   // Add a local relocation which does not use a symbol for the relocation,
+@@ -1810,7 +1822,7 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 			      Output_data* od, Address address, Addend addend)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, od, address,
+-				    addend, false, true, false));
++				    addend, false, true, false, false));
+   }
+ 
+   void
+@@ -1820,7 +1832,8 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 			      Address address, Addend addend)
+   {
+     this->add(od, Output_reloc_type(relobj, local_sym_index, type, shndx,
+-                                    address, addend, false, true, false));
++                                    address, addend, false, true, false,
++                                    false));
+   }
+ 
+   // Add a reloc against a local section symbol.  This will be
+@@ -1833,7 +1846,7 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+                     Output_data* od, Address address, Addend addend)
+   {
+     this->add(od, Output_reloc_type(relobj, input_shndx, type, od, address,
+-				    addend, false, false, true));
++				    addend, false, false, true, false));
+   }
+ 
+   void
+@@ -1843,7 +1856,8 @@ class Output_data_reloc<elfcpp::SHT_RELA, dynamic, size, big_endian>
+ 		    Addend addend)
+   {
+     this->add(od, Output_reloc_type(relobj, input_shndx, type, shndx,
+-                                    address, addend, false, false, true));
++                                    address, addend, false, false, true,
++                                    false));
+   }
+ 
+   // A reloc against the STT_SECTION symbol of an output section.
+diff --git a/gold/plugin.cc b/gold/plugin.cc
+index 3ccd8d0..b4e68f8 100644
+--- a/gold/plugin.cc
++++ b/gold/plugin.cc
+@@ -818,7 +818,9 @@ Pluginobj::Pluginobj(const std::string& name, Input_file* input_file,
+ }
+ 
+ // Return TRUE if a defined symbol is referenced from outside the
+-// universe of claimed objects.
++// universe of claimed objects.  Only references from relocatable,
++// non-IR (unclaimed) objects count as a reference.  References from
++// dynamic objects count only as "visible".
+ 
+ static inline bool
+ is_referenced_from_outside(Symbol* lsym)
+@@ -838,6 +840,8 @@ is_referenced_from_outside(Symbol* lsym)
+ static inline bool
+ is_visible_from_outside(Symbol* lsym)
+ {
++  if (lsym->in_dyn())
++    return true;
+   if (parameters->options().export_dynamic() || parameters->options().shared())
+     return lsym->is_externally_visible();
+   return false;
+@@ -1244,14 +1248,18 @@ Sized_pluginobj<size, big_endian>::do_initialize_xindex()
+   return NULL;
+ }
+ 
+-// Get symbol counts.  Not used for plugin objects.
++// Get symbol counts.  Don't count plugin objects; the replacement
++// files will provide the counts.
+ 
+ template<int size, bool big_endian>
+ void
+-Sized_pluginobj<size, big_endian>::do_get_global_symbol_counts(const Symbol_table*,
+-                                                   size_t*, size_t*) const
++Sized_pluginobj<size, big_endian>::do_get_global_symbol_counts(
++    const Symbol_table*,
++    size_t* defined,
++    size_t* used) const
+ {
+-  gold_unreachable();
++  *defined = 0;
++  *used = 0;
+ }
+ 
+ // Get symbols.  Not used for plugin objects.
+diff --git a/gold/powerpc.cc b/gold/powerpc.cc
+index 45783c3..62a17ca 100644
+--- a/gold/powerpc.cc
++++ b/gold/powerpc.cc
+@@ -1329,7 +1329,7 @@ Target_powerpc<size, big_endian>::Scan::local(
+               rela_dyn->add_local_relative(object, r_sym, r_type,
+ 					   output_section, data_shndx,
+ 					   reloc.get_r_offset(),
+-					   reloc.get_r_addend());
++					   reloc.get_r_addend(), false);
+             }
+         }
+       break;
+@@ -1372,7 +1372,7 @@ Target_powerpc<size, big_endian>::Scan::local(
+ 		object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off);
+ 		rela_dyn->add_local_relative(object, r_sym,
+ 					     elfcpp::R_POWERPC_RELATIVE,
+-					     got, off, 0);
++					     got, off, 0, false);
+ 	      }
+           }
+ 	else
+diff --git a/gold/readsyms.cc b/gold/readsyms.cc
+index 1e50942..9974722 100644
+--- a/gold/readsyms.cc
++++ b/gold/readsyms.cc
+@@ -161,8 +161,10 @@ void
+ Read_symbols::run(Workqueue* workqueue)
+ {
+   // If we didn't queue a new task, then we need to explicitly unblock
+-  // the token.
+-  if (!this->do_read_symbols(workqueue))
++  // the token. If the object is a member of a lib group, however,
++  // the token was already added to the list of locks for the task,
++  // and it will be unblocked automatically at the end of the task.
++  if (!this->do_read_symbols(workqueue) && this->member_ == NULL)
+     workqueue->queue_soon(new Unblock_token(this->this_blocker_,
+ 					    this->next_blocker_));
+ }
+diff --git a/gold/resolve.cc b/gold/resolve.cc
+index 03288ec..780038a 100644
+--- a/gold/resolve.cc
++++ b/gold/resolve.cc
+@@ -296,7 +296,7 @@ Symbol_table::resolve(Sized_symbol<size>* to,
+ 
+   // Record if we've seen this symbol in a real ELF object (i.e., the
+   // symbol is referenced from outside the world known to the plugin).
+-  if (object->pluginobj() == NULL)
++  if (object->pluginobj() == NULL && !object->is_dynamic())
+     to->set_in_real_elf();
+ 
+   // If we're processing replacement files, allow new symbols to override
+@@ -336,9 +336,9 @@ Symbol_table::resolve(Sized_symbol<size>* to,
+       && to->name()[0] == '_' && to->name()[1] == 'Z')
+     {
+       Symbol_location fromloc
+-          = { object, orig_st_shndx, sym.get_st_value() };
++          = { object, orig_st_shndx, static_cast<off_t>(sym.get_st_value()) };
+       Symbol_location toloc = { to->object(), to->shndx(&to_is_ordinary),
+-				to->value() };
++				static_cast<off_t>(to->value()) };
+       this->candidate_odr_violations_[to->name()].insert(fromloc);
+       this->candidate_odr_violations_[to->name()].insert(toloc);
+     }
+diff --git a/gold/script-sections.cc b/gold/script-sections.cc
+index 1fad88d..f90c0b3 100644
+--- a/gold/script-sections.cc
++++ b/gold/script-sections.cc
+@@ -680,7 +680,7 @@ class Sections_element_assignment : public Sections_element
+   set_section_addresses(Symbol_table* symtab, Layout* layout,
+ 			uint64_t* dot_value, uint64_t*, uint64_t*)
+   {
+-    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value);
++    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value, NULL);
+   }
+ 
+   // Print for debugging.
+@@ -714,7 +714,7 @@ class Sections_element_dot_assignment : public Sections_element
+     // output section definition the dot symbol is always considered
+     // to be absolute.
+     *dot_value = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
+-					   NULL, NULL, NULL);
++					   NULL, NULL, NULL, false);
+   }
+ 
+   // Update the dot symbol while setting section addresses.
+@@ -724,7 +724,7 @@ class Sections_element_dot_assignment : public Sections_element
+ 			uint64_t* load_address)
+   {
+     *dot_value = this->val_->eval_with_dot(symtab, layout, false, *dot_value,
+-					   NULL, NULL, dot_alignment);
++					   NULL, NULL, dot_alignment, false);
+     *load_address = *dot_value;
+   }
+ 
+@@ -866,9 +866,11 @@ class Output_section_element_assignment : public Output_section_element
+   void
+   set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
+ 			uint64_t, uint64_t* dot_value, uint64_t*,
+-			Output_section**, std::string*, Input_section_list*)
++			Output_section** dot_section, std::string*,
++			Input_section_list*)
+   {
+-    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value);
++    this->assignment_.set_if_absolute(symtab, layout, true, *dot_value,
++				      *dot_section);
+   }
+ 
+   // Print for debugging.
+@@ -892,20 +894,28 @@ class Output_section_element_dot_assignment : public Output_section_element
+     : val_(val)
+   { }
+ 
++  // An assignment to dot within an output section is enough to force
++  // the output section to exist.
++  bool
++  needs_output_section() const
++  { return true; }
++
+   // Finalize the symbol.
+   void
+   finalize_symbols(Symbol_table* symtab, const Layout* layout,
+ 		   uint64_t* dot_value, Output_section** dot_section)
+   {
+     *dot_value = this->val_->eval_with_dot(symtab, layout, true, *dot_value,
+-					   *dot_section, dot_section, NULL);
++					   *dot_section, dot_section, NULL,
++					   true);
+   }
+ 
+   // Update the dot symbol while setting section addresses.
+   void
+   set_section_addresses(Symbol_table* symtab, Layout* layout, Output_section*,
+ 			uint64_t, uint64_t* dot_value, uint64_t*,
+-			Output_section**, std::string*, Input_section_list*);
++			Output_section** dot_section, std::string*,
++			Input_section_list*);
+ 
+   // Print for debugging.
+   void
+@@ -936,7 +946,8 @@ Output_section_element_dot_assignment::set_section_addresses(
+ {
+   uint64_t next_dot = this->val_->eval_with_dot(symtab, layout, false,
+ 						*dot_value, *dot_section,
+-						dot_section, dot_alignment);
++						dot_section, dot_alignment,
++						true);
+   if (next_dot < *dot_value)
+     gold_error(_("dot may not move backward"));
+   if (next_dot > *dot_value && output_section != NULL)
+@@ -1037,7 +1048,8 @@ Output_data_expression::do_write_to_buffer(unsigned char* buf)
+ {
+   uint64_t val = this->val_->eval_with_dot(this->symtab_, this->layout_,
+ 					   true, this->dot_value_,
+-					   this->dot_section_, NULL, NULL);
++					   this->dot_section_, NULL, NULL,
++					   false);
+ 
+   if (parameters->target().is_big_endian())
+     this->endian_write_to_buffer<true>(val, buf);
+@@ -1187,7 +1199,7 @@ class Output_section_element_fill : public Output_section_element
+     Output_section* fill_section;
+     uint64_t fill_val = this->val_->eval_with_dot(symtab, layout, false,
+ 						  *dot_value, *dot_section,
+-						  &fill_section, NULL);
++						  &fill_section, NULL, false);
+     if (fill_section != NULL)
+       gold_warning(_("fill value is not absolute"));
+     // FIXME: The GNU linker supports fill values of arbitrary length.
+@@ -2108,13 +2120,13 @@ Output_section_definition::finalize_symbols(Symbol_table* symtab,
+ 	{
+ 	  address = this->address_->eval_with_dot(symtab, layout, true,
+ 						  *dot_value, NULL,
+-						  NULL, NULL);
++						  NULL, NULL, false);
+ 	}
+       if (this->align_ != NULL)
+ 	{
+ 	  uint64_t align = this->align_->eval_with_dot(symtab, layout, true,
+ 						       *dot_value, NULL,
+-						       NULL, NULL);
++						       NULL, NULL, false);
+ 	  address = align_address(address, align);
+ 	}
+       *dot_value = address;
+@@ -2303,7 +2315,7 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
+   else
+     address = this->address_->eval_with_dot(symtab, layout, true,
+ 					    *dot_value, NULL, NULL,
+-					    dot_alignment);
++					    dot_alignment, false);
+   uint64_t align;
+   if (this->align_ == NULL)
+     {
+@@ -2316,7 +2328,7 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
+     {
+       Output_section* align_section;
+       align = this->align_->eval_with_dot(symtab, layout, true, *dot_value,
+-					  NULL, &align_section, NULL);
++					  NULL, &align_section, NULL, false);
+       if (align_section != NULL)
+ 	gold_warning(_("alignment of section %s is not absolute"),
+ 		     this->name_.c_str());
+@@ -2401,7 +2413,7 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
+       laddr = this->load_address_->eval_with_dot(symtab, layout, true,
+ 						 *dot_value,
+ 						 this->output_section_,
+-						 NULL, NULL);
++						 NULL, NULL, false);
+       if (this->output_section_ != NULL)
+         this->output_section_->set_load_address(laddr);
+     }
+@@ -2416,7 +2428,8 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
+       Output_section* subalign_section;
+       subalign = this->subalign_->eval_with_dot(symtab, layout, true,
+ 						*dot_value, NULL,
+-						&subalign_section, NULL);
++						&subalign_section, NULL,
++						false);
+       if (subalign_section != NULL)
+ 	gold_warning(_("subalign of section %s is not absolute"),
+ 		     this->name_.c_str());
+@@ -2431,7 +2444,7 @@ Output_section_definition::set_section_addresses(Symbol_table* symtab,
+       uint64_t fill_val = this->fill_->eval_with_dot(symtab, layout, true,
+ 						     *dot_value,
+ 						     NULL, &fill_section,
+-						     NULL);
++						     NULL, false);
+       if (fill_section != NULL)
+ 	gold_warning(_("fill of section %s is not absolute"),
+ 		     this->name_.c_str());
+diff --git a/gold/script.cc b/gold/script.cc
+index 7df0c9e..b471cf9 100644
+--- a/gold/script.cc
++++ b/gold/script.cc
+@@ -983,18 +983,20 @@ Symbol_assignment::sized_finalize(Symbol_table* symtab, const Layout* layout,
+   uint64_t final_val = this->val_->eval_maybe_dot(symtab, layout, true,
+ 						  is_dot_available,
+ 						  dot_value, dot_section,
+-						  &section, NULL);
++						  &section, NULL, false);
+   Sized_symbol<size>* ssym = symtab->get_sized_symbol<size>(this->sym_);
+   ssym->set_value(final_val);
+   if (section != NULL)
+     ssym->set_output_section(section);
+ }
+ 
+-// Set the symbol value if the expression yields an absolute value.
++// Set the symbol value if the expression yields an absolute value or
++// a value relative to DOT_SECTION.
+ 
+ void
+ Symbol_assignment::set_if_absolute(Symbol_table* symtab, const Layout* layout,
+-				   bool is_dot_available, uint64_t dot_value)
++				   bool is_dot_available, uint64_t dot_value,
++				   Output_section* dot_section)
+ {
+   if (this->sym_ == NULL)
+     return;
+@@ -1002,8 +1004,9 @@ Symbol_assignment::set_if_absolute(Symbol_table* symtab, const Layout* layout,
+   Output_section* val_section;
+   uint64_t val = this->val_->eval_maybe_dot(symtab, layout, false,
+ 					    is_dot_available, dot_value,
+-					    NULL, &val_section, NULL);
+-  if (val_section != NULL)
++					    dot_section, &val_section, NULL,
++					    false);
++  if (val_section != NULL && val_section != dot_section)
+     return;
+ 
+   if (parameters->target().get_size() == 32)
+@@ -1026,6 +1029,8 @@ Symbol_assignment::set_if_absolute(Symbol_table* symtab, const Layout* layout,
+     }
+   else
+     gold_unreachable();
++  if (val_section != NULL)
++    this->sym_->set_output_section(val_section);
+ }
+ 
+ // Print for debugging.
+@@ -1215,7 +1220,7 @@ Script_options::set_section_addresses(Symbol_table* symtab, Layout* layout)
+   for (Symbol_assignments::iterator p = this->symbol_assignments_.begin();
+        p != this->symbol_assignments_.end();
+        ++p)
+-    (*p)->set_if_absolute(symtab, layout, false, 0);
++    (*p)->set_if_absolute(symtab, layout, false, 0, NULL);
+ 
+   return this->script_sections_.set_section_addresses(symtab, layout);
+ }
+diff --git a/gold/script.h b/gold/script.h
+index 73079a4..f41f438 100644
+--- a/gold/script.h
++++ b/gold/script.h
+@@ -90,20 +90,28 @@ class Expression
+   // the section address.  If RESULT_ALIGNMENT is not NULL, this sets
+   // *RESULT_ALIGNMENT to the alignment of the value of that alignment
+   // is larger than *RESULT_ALIGNMENT; this will only be non-zero if
+-  // this is an ALIGN expression.
++  // this is an ALIGN expression.  If IS_SECTION_DOT_ASSIGMENT is true,
++  // we are evaluating an assignment to dot within an output section,
++  // and an absolute value should be interpreted as an offset within
++  // the section.
+   uint64_t
+   eval_with_dot(const Symbol_table*, const Layout*, bool check_assertions,
+ 		uint64_t dot_value, Output_section* dot_section,
+-		Output_section** result_section, uint64_t* result_alignment);
++		Output_section** result_section, uint64_t* result_alignment,
++		bool is_section_dot_assignment);
+ 
+   // Return the value of an expression which may or may not be
+   // permitted to refer to the dot symbol, depending on
+-  // is_dot_available.
++  // is_dot_available.  If IS_SECTION_DOT_ASSIGMENT is true,
++  // we are evaluating an assignment to dot within an output section,
++  // and an absolute value should be interpreted as an offset within
++  // the section.
+   uint64_t
+   eval_maybe_dot(const Symbol_table*, const Layout*, bool check_assertions,
+ 		 bool is_dot_available, uint64_t dot_value,
+ 		 Output_section* dot_section,
+-		 Output_section** result_section, uint64_t* result_alignment);
++		 Output_section** result_section, uint64_t* result_alignment,
++		 bool is_section_dot_assignment);
+ 
+   // Print the expression to the FILE.  This is for debugging.
+   virtual void
+@@ -339,12 +347,12 @@ class Symbol_assignment
+   finalize_with_dot(Symbol_table*, const Layout*, uint64_t dot_value,
+ 		    Output_section* dot_section);
+ 
+-  // Set the symbol value, but only if the value is absolute.  This is
+-  // used while processing a SECTIONS clause.  We assume that dot is
+-  // an absolute value here.  We do not check assertions.
++  // Set the symbol value, but only if the value is absolute or relative to
++  // DOT_SECTION.  This is used while processing a SECTIONS clause.
++  // We assume that dot is an absolute value here.  We do not check assertions.
+   void
+   set_if_absolute(Symbol_table*, const Layout*, bool is_dot_available,
+-		  uint64_t dot_value);
++		  uint64_t dot_value, Output_section* dot_section);
+ 
+   const std::string&
+   name() const
+diff --git a/gold/sparc.cc b/gold/sparc.cc
+index 5f67a4e..12e1dee 100644
+--- a/gold/sparc.cc
++++ b/gold/sparc.cc
+@@ -1855,7 +1855,7 @@ Target_sparc<size, big_endian>::Scan::local(
+           rela_dyn->add_local_relative(object, r_sym, elfcpp::R_SPARC_RELATIVE,
+ 				       output_section, data_shndx,
+ 				       reloc.get_r_offset(),
+-				       reloc.get_r_addend());
++				       reloc.get_r_addend(), false);
+         }
+       break;
+ 
+@@ -1946,7 +1946,7 @@ Target_sparc<size, big_endian>::Scan::local(
+ 		object->set_local_got_offset(r_sym, GOT_TYPE_STANDARD, off);
+ 		rela_dyn->add_local_relative(object, r_sym,
+ 					     elfcpp::R_SPARC_RELATIVE,
+-					     got, off, 0);
++					     got, off, 0, false);
+ 	      }
+ 	  }
+ 	else
+diff --git a/gold/symtab.cc b/gold/symtab.cc
+index ff1b5ca..f0ba1d5 100644
+--- a/gold/symtab.cc
++++ b/gold/symtab.cc
+@@ -602,20 +602,16 @@ Symbol_table::gc_mark_undef_symbols(Layout* layout)
+ }
+ 
+ void
+-Symbol_table::gc_mark_symbol_for_shlib(Symbol* sym)
++Symbol_table::gc_mark_symbol(Symbol* sym)
+ {
+-  if (!sym->is_from_dynobj() 
+-      && sym->is_externally_visible())
++  // Add the object and section to the work list.
++  Relobj* obj = static_cast<Relobj*>(sym->object());
++  bool is_ordinary;
++  unsigned int shndx = sym->shndx(&is_ordinary);
++  if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
+     {
+-      //Add the object and section to the work list.
+-      Relobj* obj = static_cast<Relobj*>(sym->object());
+-      bool is_ordinary;
+-      unsigned int shndx = sym->shndx(&is_ordinary);
+-      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
+-        {
+-          gold_assert(this->gc_!= NULL);
+-          this->gc_->worklist().push(Section_id(obj, shndx));
+-        }
++      gold_assert(this->gc_!= NULL);
++      this->gc_->worklist().push(Section_id(obj, shndx));
+     }
+ }
+ 
+@@ -626,16 +622,7 @@ Symbol_table::gc_mark_dyn_syms(Symbol* sym)
+ {
+   if (sym->in_dyn() && sym->source() == Symbol::FROM_OBJECT
+       && !sym->object()->is_dynamic())
+-    {
+-      Relobj* obj = static_cast<Relobj*>(sym->object()); 
+-      bool is_ordinary;
+-      unsigned int shndx = sym->shndx(&is_ordinary);
+-      if (is_ordinary && shndx != elfcpp::SHN_UNDEF)
+-        {
+-          gold_assert(this->gc_ != NULL);
+-          this->gc_->worklist().push(Section_id(obj, shndx));
+-        }
+-    }
++    this->gc_mark_symbol(sym);
+ }
+ 
+ // Make TO a symbol which forwards to FROM.
+@@ -1143,6 +1130,14 @@ Symbol_table::add_from_relobj(
+       bool is_default_version = false;
+       bool is_forced_local = false;
+ 
++      // FIXME: For incremental links, we don't store version information,
++      // so we need to ignore version symbols for now.
++      if (parameters->incremental_update() && ver != NULL)
++	{
++	  namelen = ver - name;
++	  ver = NULL;
++	}
++
+       if (ver != NULL)
+         {
+           // The symbol name is of the form foo@VERSION or foo@@VERSION
+@@ -1243,11 +1238,16 @@ Symbol_table::add_from_relobj(
+       if (is_forced_local)
+ 	this->force_local(res);
+ 
+-      // If building a shared library using garbage collection, do not 
+-      // treat externally visible symbols as garbage.
+-      if (parameters->options().gc_sections() 
+-          && parameters->options().shared())
+-        this->gc_mark_symbol_for_shlib(res);
++      // Do not treat this symbol as garbage if this symbol will be
++      // exported to the dynamic symbol table.  This is true when
++      // building a shared library or using --export-dynamic and
++      // the symbol is externally visible.
++      if (parameters->options().gc_sections()
++	  && res->is_externally_visible()
++	  && !res->is_from_dynobj()
++          && (parameters->options().shared()
++	      || parameters->options().export_dynamic()))
++        this->gc_mark_symbol(res);
+ 
+       if (is_defined_in_discarded_section)
+ 	res->set_is_defined_in_discarded_section();
+@@ -1346,6 +1346,11 @@ Symbol_table::add_from_dynobj(
+       return;
+     }
+ 
++  // FIXME: For incremental links, we don't store version information,
++  // so we need to ignore version symbols for now.
++  if (parameters->incremental_update())
++    versym = NULL;
++
+   if (versym != NULL && versym_size / 2 < count)
+     {
+       dynobj->error(_("too few symbol versions"));
+@@ -2809,6 +2814,12 @@ Symbol_table::sized_write_globals(const Stringpool* sympool,
+       typename elfcpp::Elf_types<size>::Elf_Addr sym_value = sym->value();
+       typename elfcpp::Elf_types<size>::Elf_Addr dynsym_value = sym_value;
+       elfcpp::STB binding = sym->binding();
++
++      // If --no-gnu-unique is set, change STB_GNU_UNIQUE to STB_GLOBAL.
++      if (binding == elfcpp::STB_GNU_UNIQUE
++	  && !parameters->options().gnu_unique())
++	binding = elfcpp::STB_GLOBAL;
++
+       switch (sym->source())
+ 	{
+ 	case Symbol::FROM_OBJECT:
+diff --git a/gold/symtab.h b/gold/symtab.h
+index b9b9e00..427f72f 100644
+--- a/gold/symtab.h
++++ b/gold/symtab.h
+@@ -1308,10 +1308,9 @@ class Symbol_table
+   void
+   gc_mark_undef_symbols(Layout*);
+ 
+-  // During garbage collection, this ensures externally visible symbols
+-  // are not treated as garbage while building shared objects.
++  // This tells garbage collection that this symbol is referenced.
+   void
+-  gc_mark_symbol_for_shlib(Symbol* sym);
++  gc_mark_symbol(Symbol* sym);
+ 
+   // During garbage collection, this keeps sections that correspond to 
+   // symbols seen in dynamic objects.
+diff --git a/gold/testsuite/Makefile.am b/gold/testsuite/Makefile.am
+index 9b8605b..97d6457 100644
+--- a/gold/testsuite/Makefile.am
++++ b/gold/testsuite/Makefile.am
+@@ -870,11 +870,16 @@ initpri3a_DEPENDENCIES = gcctestdir/ld
+ initpri3a_LDFLAGS = -Bgcctestdir/
+ initpri3a_LDADD =
+ 
+-check_PROGRAMS += initpri3b
+-initpri3b_SOURCES = initpri3.c
+-initpri3b_DEPENDENCIES = gcctestdir/ld
+-initpri3b_LDFLAGS = -Bgcctestdir/ -Wl,--no-ctors-in-init-array
+-initpri3b_LDADD =
++# This test fails on targets not using .ctors and .dtors sections (e.g. ARM
++# EABI). Given that gcc is moving towards using .init_array in all cases,
++# this test is commented out.  A better fix would be checking whether gcc
++# uses .ctors or .init_array sections in configure.
++
++# check_PROGRAMS += initpri3b
++# initpri3b_SOURCES = initpri3.c
++# initpri3b_DEPENDENCIES = gcctestdir/ld
++# initpri3b_LDFLAGS = -Bgcctestdir/ -Wl,--no-ctors-in-init-array
++# initpri3b_LDADD =
+ 
+ # Test --detect-odr-violations
+ check_SCRIPTS += debug_msg.sh
+diff --git a/gold/testsuite/Makefile.in b/gold/testsuite/Makefile.in
+index 67149fb..518d32b 100644
+--- a/gold/testsuite/Makefile.in
++++ b/gold/testsuite/Makefile.in
+@@ -56,6 +56,17 @@ check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \
+ @NATIVE_OR_CROSS_LINKER_TRUE@am__append_1 = object_unittest \
+ @NATIVE_OR_CROSS_LINKER_TRUE@	binary_unittest
+ 
++# This test fails on targets not using .ctors and .dtors sections (e.g. ARM
++# EABI). Given that gcc is moving towards using .init_array in all cases,
++# this test is commented out.  A better fix would be checking whether gcc
++# uses .ctors or .init_array sections in configure.
++
++# check_PROGRAMS += initpri3b
++# initpri3b_SOURCES = initpri3.c
++# initpri3b_DEPENDENCIES = gcctestdir/ld
++# initpri3b_LDFLAGS = -Bgcctestdir/ -Wl,--no-ctors-in-init-array
++# initpri3b_LDADD =
++
+ # Test --detect-odr-violations
+ 
+ # Similar to --detect-odr-violations: check for undefined symbols in .so's
+@@ -189,7 +200,7 @@ check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \
+ # Test -o when emitting to a special file (such as something in /dev).
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@am__append_24 = many_sections_test \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	many_sections_r_test initpri1 \
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri2 initpri3a initpri3b \
++@GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri2 initpri3a \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	flagstest_o_specialfile
+ @GCC_FALSE@many_sections_test_DEPENDENCIES =
+ @NATIVE_LINKER_FALSE@many_sections_test_DEPENDENCIES =
+@@ -204,8 +215,6 @@ check_PROGRAMS = $(am__EXEEXT_1) $(am__EXEEXT_2) $(am__EXEEXT_3) \
+ @NATIVE_LINKER_FALSE@initpri2_DEPENDENCIES =
+ @GCC_FALSE@initpri3a_DEPENDENCIES =
+ @NATIVE_LINKER_FALSE@initpri3a_DEPENDENCIES =
+-@GCC_FALSE@initpri3b_DEPENDENCIES =
+-@NATIVE_LINKER_FALSE@initpri3b_DEPENDENCIES =
+ 
+ # Check that --detect-odr-violations works with compressed debug sections.
+ @GCC_TRUE@@HAVE_ZLIB_TRUE@@NATIVE_LINKER_TRUE@am__append_27 = debug_msg_cdebug.err
+@@ -712,7 +721,6 @@ libgoldtest_a_OBJECTS = $(am_libgoldtest_a_OBJECTS)
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri1$(EXEEXT) \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri2$(EXEEXT) \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri3a$(EXEEXT) \
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri3b$(EXEEXT) \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	flagstest_o_specialfile$(EXEEXT)
+ @GCC_TRUE@@HAVE_ZLIB_TRUE@@NATIVE_LINKER_TRUE@am__EXEEXT_21 = flagstest_compress_debug_sections$(EXEEXT) \
+ @GCC_TRUE@@HAVE_ZLIB_TRUE@@NATIVE_LINKER_TRUE@	flagstest_o_specialfile_and_compress_debug_sections$(EXEEXT)
+@@ -1200,11 +1208,6 @@ initpri2_LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(initpri2_LDFLAGS) \
+ initpri3a_OBJECTS = $(am_initpri3a_OBJECTS)
+ initpri3a_LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(initpri3a_LDFLAGS) \
+ 	$(LDFLAGS) -o $@
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@am_initpri3b_OBJECTS =  \
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@	initpri3.$(OBJEXT)
+-initpri3b_OBJECTS = $(am_initpri3b_OBJECTS)
+-initpri3b_LINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(initpri3b_LDFLAGS) \
+-	$(LDFLAGS) -o $@
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@am_justsyms_OBJECTS =  \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@	justsyms_1.$(OBJEXT)
+ justsyms_OBJECTS = $(am_justsyms_OBJECTS)
+@@ -1698,7 +1701,7 @@ SOURCES = $(libgoldtest_a_SOURCES) basic_pic_test.c basic_pie_test.c \
+ 	incremental_copy_test.c incremental_test_2.c \
+ 	incremental_test_3.c incremental_test_4.c incremental_test_5.c \
+ 	incremental_test_6.c $(initpri1_SOURCES) $(initpri2_SOURCES) \
+-	$(initpri3a_SOURCES) $(initpri3b_SOURCES) $(justsyms_SOURCES) \
++	$(initpri3a_SOURCES) $(justsyms_SOURCES) \
+ 	$(justsyms_exec_SOURCES) $(large_SOURCES) local_labels_test.c \
+ 	many_sections_r_test.c $(many_sections_test_SOURCES) \
+ 	$(object_unittest_SOURCES) permission_test.c plugin_test_1.c \
+@@ -1844,6 +1847,8 @@ EGREP = @EGREP@
+ EXEEXT = @EXEEXT@
+ GENCAT = @GENCAT@
+ GMSGFMT = @GMSGFMT@
++GOLD_LDADD = @GOLD_LDADD@
++GOLD_LDFLAGS = @GOLD_LDFLAGS@
+ GREP = @GREP@
+ INCINTL = @INCINTL@
+ INSTALL = @INSTALL@
+@@ -2279,10 +2284,6 @@ LDADD = libgoldtest.a ../libgold.a ../../libiberty/libiberty.a $(LIBINTL) \
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3a_DEPENDENCIES = gcctestdir/ld
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3a_LDFLAGS = -Bgcctestdir/
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3a_LDADD = 
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3b_SOURCES = initpri3.c
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3b_DEPENDENCIES = gcctestdir/ld
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3b_LDFLAGS = -Bgcctestdir/ -Wl,--no-ctors-in-init-array
+-@GCC_TRUE@@NATIVE_LINKER_TRUE@initpri3b_LDADD = 
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@ver_test_SOURCES = ver_test_main.cc
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@ver_test_DEPENDENCIES = gcctestdir/ld ver_test_1.so ver_test_2.so ver_test_4.so
+ @GCC_TRUE@@NATIVE_LINKER_TRUE@ver_test_LDFLAGS = -Bgcctestdir/ -Wl,-R,.
+@@ -2926,9 +2927,6 @@ initpri2$(EXEEXT): $(initpri2_OBJECTS) $(initpri2_DEPENDENCIES)
+ initpri3a$(EXEEXT): $(initpri3a_OBJECTS) $(initpri3a_DEPENDENCIES) 
+ 	@rm -f initpri3a$(EXEEXT)
+ 	$(initpri3a_LINK) $(initpri3a_OBJECTS) $(initpri3a_LDADD) $(LIBS)
+-initpri3b$(EXEEXT): $(initpri3b_OBJECTS) $(initpri3b_DEPENDENCIES) 
+-	@rm -f initpri3b$(EXEEXT)
+-	$(initpri3b_LINK) $(initpri3b_OBJECTS) $(initpri3b_LDADD) $(LIBS)
+ justsyms$(EXEEXT): $(justsyms_OBJECTS) $(justsyms_DEPENDENCIES) 
+ 	@rm -f justsyms$(EXEEXT)
+ 	$(justsyms_LINK) $(justsyms_OBJECTS) $(justsyms_LDADD) $(LIBS)
+@@ -3867,8 +3865,6 @@ initpri2.log: initpri2$(EXEEXT)
+ 	@p='initpri2$(EXEEXT)'; $(am__check_pre) $(LOG_COMPILE) "$$tst" $(am__check_post)
+ initpri3a.log: initpri3a$(EXEEXT)
+ 	@p='initpri3a$(EXEEXT)'; $(am__check_pre) $(LOG_COMPILE) "$$tst" $(am__check_post)
+-initpri3b.log: initpri3b$(EXEEXT)
+-	@p='initpri3b$(EXEEXT)'; $(am__check_pre) $(LOG_COMPILE) "$$tst" $(am__check_post)
+ flagstest_o_specialfile.log: flagstest_o_specialfile$(EXEEXT)
+ 	@p='flagstest_o_specialfile$(EXEEXT)'; $(am__check_pre) $(LOG_COMPILE) "$$tst" $(am__check_post)
+ flagstest_compress_debug_sections.log: flagstest_compress_debug_sections$(EXEEXT)
+diff --git a/gold/testsuite/plugin_test_2.sh b/gold/testsuite/plugin_test_2.sh
+index a47d22a..293b1f0 100755
+--- a/gold/testsuite/plugin_test_2.sh
++++ b/gold/testsuite/plugin_test_2.sh
+@@ -45,7 +45,7 @@ check plugin_test_2.err "two_file_test_main.o: claim file hook called"
+ check plugin_test_2.err "two_file_test_1.syms: claim file hook called"
+ check plugin_test_2.err "two_file_test_1b.syms: claim file hook called"
+ check plugin_test_2.err "two_file_shared_2.so: claim file hook called"
+-check plugin_test_2.err "two_file_test_1.syms: _Z4f13iv: PREVAILING_DEF_REG"
++check plugin_test_2.err "two_file_test_1.syms: _Z4f13iv: PREVAILING_DEF_IRONLY_EXP"
+ check plugin_test_2.err "two_file_test_1.syms: _Z2t2v: PREVAILING_DEF_REG"
+ check plugin_test_2.err "two_file_test_1.syms: v2: RESOLVED_DYN"
+ check plugin_test_2.err "two_file_test_1.syms: t17data: RESOLVED_DYN"
+diff --git a/gold/testsuite/script_test_2.t b/gold/testsuite/script_test_2.t
+index 73d39df..6a0188f 100644
+--- a/gold/testsuite/script_test_2.t
++++ b/gold/testsuite/script_test_2.t
+@@ -49,7 +49,7 @@ SECTIONS
+     /* This should match the remaining sections.  */
+     *(.gold_test)
+ 
+-    . = . + 4;
++    . = 60;
+     start_data = .;
+     BYTE(1)
+     SHORT(2)
+diff --git a/gold/timer.cc b/gold/timer.cc
+index d9b8874..44e19f5 100644
+--- a/gold/timer.cc
++++ b/gold/timer.cc
+@@ -22,6 +22,8 @@
+ 
+ #include "gold.h"
+ 
++#include <unistd.h>
++
+ #ifdef HAVE_TIMES
+ #include <sys/times.h>
+ #endif
+diff --git a/gold/x86_64.cc b/gold/x86_64.cc
+index e6b0021..e7c981b 100644
+--- a/gold/x86_64.cc
++++ b/gold/x86_64.cc
+@@ -1549,7 +1549,7 @@ Target_x86_64::reserve_local_got_entry(
+     case GOT_TYPE_STANDARD:
+       if (parameters->options().output_is_position_independent())
+ 	rela_dyn->add_local_relative(obj, r_sym, elfcpp::R_X86_64_RELATIVE,
+-				     this->got_, got_offset, 0);
++				     this->got_, got_offset, 0, false);
+       break;
+     case GOT_TYPE_TLS_OFFSET:
+       rela_dyn->add_local(obj, r_sym, elfcpp::R_X86_64_TPOFF64,
+@@ -1953,8 +1953,8 @@ Target_x86_64::Scan::local(Symbol_table* symtab,
+                            const elfcpp::Sym<64, false>& lsym)
+ {
+   // A local STT_GNU_IFUNC symbol may require a PLT entry.
+-  if (lsym.get_st_type() == elfcpp::STT_GNU_IFUNC
+-      && this->reloc_needs_plt_for_ifunc(object, r_type))
++  bool is_ifunc = lsym.get_st_type() == elfcpp::STT_GNU_IFUNC;
++  if (is_ifunc && this->reloc_needs_plt_for_ifunc(object, r_type))
+     {
+       unsigned int r_sym = elfcpp::elf_r_sym<64>(reloc.get_r_info());
+       target->make_local_ifunc_plt_entry(symtab, layout, object, r_sym);
+@@ -1982,7 +1982,7 @@ Target_x86_64::Scan::local(Symbol_table* symtab,
+ 				       elfcpp::R_X86_64_RELATIVE,
+ 				       output_section, data_shndx,
+ 				       reloc.get_r_offset(),
+-				       reloc.get_r_addend());
++				       reloc.get_r_addend(), is_ifunc);
+         }
+       break;
+ 
+@@ -2058,7 +2058,7 @@ Target_x86_64::Scan::local(Symbol_table* symtab,
+ 	// lets function pointers compare correctly with shared
+ 	// libraries.  Otherwise we would need an IRELATIVE reloc.
+ 	bool is_new;
+-	if (lsym.get_st_type() == elfcpp::STT_GNU_IFUNC)
++	if (is_ifunc)
+ 	  is_new = got->add_local_plt(object, r_sym, GOT_TYPE_STANDARD);
+ 	else
+ 	  is_new = got->add_local(object, r_sym, GOT_TYPE_STANDARD);
+@@ -2076,7 +2076,7 @@ Target_x86_64::Scan::local(Symbol_table* symtab,
+ 		      object->local_got_offset(r_sym, GOT_TYPE_STANDARD);
+ 		    rela_dyn->add_local_relative(object, r_sym,
+ 						 elfcpp::R_X86_64_RELATIVE,
+-						 got, got_offset, 0);
++						 got, got_offset, 0, is_ifunc);
+ 		  }
+                 else
+                   {
+@@ -3181,12 +3181,6 @@ Target_x86_64::Relocate::relocate_tls(const Relocate_info<64, false>* relinfo,
+             }
+           if (optimized_type == tls::TLSOPT_TO_IE)
+             {
+-	      if (tls_segment == NULL)
+-		{
+-		  gold_assert(parameters->errors()->error_count() > 0
+-			      || issue_undefined_symbol_error(gsym));
+-		  return;
+-		}
+               value = target->got_plt_section()->address() + got_offset;
+               this->tls_gd_to_ie(relinfo, relnum, tls_segment, rela, r_type,
+                                  value, view, address, view_size);
+@@ -3867,42 +3861,51 @@ Target_x86_64::do_code_fill(section_size_type length) const
+     }
+ 
+   // Nop sequences of various lengths.
+-  const char nop1[1] = { 0x90 };                   // nop
+-  const char nop2[2] = { 0x66, 0x90 };             // xchg %ax %ax
+-  const char nop3[3] = { 0x0f, 0x1f, 0x00 };       // nop (%rax)
+-  const char nop4[4] = { 0x0f, 0x1f, 0x40, 0x00};  // nop 0(%rax)
+-  const char nop5[5] = { 0x0f, 0x1f, 0x44, 0x00,   // nop 0(%rax,%rax,1)
+-                         0x00 };
+-  const char nop6[6] = { 0x66, 0x0f, 0x1f, 0x44,   // nopw 0(%rax,%rax,1)
+-                         0x00, 0x00 };
+-  const char nop7[7] = { 0x0f, 0x1f, 0x80, 0x00,   // nopl 0L(%rax)
+-                         0x00, 0x00, 0x00 };
+-  const char nop8[8] = { 0x0f, 0x1f, 0x84, 0x00,   // nopl 0L(%rax,%rax,1)
+-                         0x00, 0x00, 0x00, 0x00 };
+-  const char nop9[9] = { 0x66, 0x0f, 0x1f, 0x84,   // nopw 0L(%rax,%rax,1)
+-                         0x00, 0x00, 0x00, 0x00,
+-                         0x00 };
+-  const char nop10[10] = { 0x66, 0x2e, 0x0f, 0x1f, // nopw %cs:0L(%rax,%rax,1)
+-                           0x84, 0x00, 0x00, 0x00,
+-                           0x00, 0x00 };
+-  const char nop11[11] = { 0x66, 0x66, 0x2e, 0x0f, // data16
+-                           0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
+-                           0x00, 0x00, 0x00 };
+-  const char nop12[12] = { 0x66, 0x66, 0x66, 0x2e, // data16; data16
+-                           0x0f, 0x1f, 0x84, 0x00, // nopw %cs:0L(%rax,%rax,1)
+-                           0x00, 0x00, 0x00, 0x00 };
+-  const char nop13[13] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
+-                           0x2e, 0x0f, 0x1f, 0x84, // nopw %cs:0L(%rax,%rax,1)
+-                           0x00, 0x00, 0x00, 0x00,
+-                           0x00 };
+-  const char nop14[14] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
+-                           0x66, 0x2e, 0x0f, 0x1f, // data16
+-                           0x84, 0x00, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
+-                           0x00, 0x00 };
+-  const char nop15[15] = { 0x66, 0x66, 0x66, 0x66, // data16; data16; data16
+-                           0x66, 0x66, 0x2e, 0x0f, // data16; data16
+-                           0x1f, 0x84, 0x00, 0x00, // nopw %cs:0L(%rax,%rax,1)
+-                           0x00, 0x00, 0x00 };
++  const char nop1[1] = { '\x90' };                 // nop
++  const char nop2[2] = { '\x66', '\x90' };         // xchg %ax %ax
++  const char nop3[3] = { '\x0f', '\x1f', '\x00' }; // nop (%rax)
++  const char nop4[4] = { '\x0f', '\x1f', '\x40',   // nop 0(%rax)
++  			 '\x00'};
++  const char nop5[5] = { '\x0f', '\x1f', '\x44',   // nop 0(%rax,%rax,1)
++			 '\x00', '\x00' };
++  const char nop6[6] = { '\x66', '\x0f', '\x1f',   // nopw 0(%rax,%rax,1)
++  			 '\x44', '\x00', '\x00' };
++  const char nop7[7] = { '\x0f', '\x1f', '\x80',   // nopl 0L(%rax)
++  			 '\x00', '\x00', '\x00',
++			 '\x00' };
++  const char nop8[8] = { '\x0f', '\x1f', '\x84',   // nopl 0L(%rax,%rax,1)
++  			 '\x00', '\x00', '\x00',
++			 '\x00', '\x00' };
++  const char nop9[9] = { '\x66', '\x0f', '\x1f',   // nopw 0L(%rax,%rax,1)
++  			 '\x84', '\x00', '\x00',
++			 '\x00', '\x00', '\x00' };
++  const char nop10[10] = { '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
++  			   '\x1f', '\x84', '\x00',
++			   '\x00', '\x00', '\x00',
++			   '\x00' };
++  const char nop11[11] = { '\x66', '\x66', '\x2e', // data16
++  			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
++			   '\x00', '\x00', '\x00',
++			   '\x00', '\x00' };
++  const char nop12[12] = { '\x66', '\x66', '\x66', // data16; data16
++  			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
++			   '\x84', '\x00', '\x00',
++			   '\x00', '\x00', '\x00' };
++  const char nop13[13] = { '\x66', '\x66', '\x66', // data16; data16; data16
++  			   '\x66', '\x2e', '\x0f', // nopw %cs:0L(%rax,%rax,1)
++			   '\x1f', '\x84', '\x00',
++			   '\x00', '\x00', '\x00',
++                           '\x00' };
++  const char nop14[14] = { '\x66', '\x66', '\x66', // data16; data16; data16
++  			   '\x66', '\x66', '\x2e', // data16
++			   '\x0f', '\x1f', '\x84', // nopw %cs:0L(%rax,%rax,1)
++			   '\x00', '\x00', '\x00',
++                           '\x00', '\x00' };
++  const char nop15[15] = { '\x66', '\x66', '\x66', // data16; data16; data16
++  			   '\x66', '\x66', '\x66', // data16; data16
++			   '\x2e', '\x0f', '\x1f', // nopw %cs:0L(%rax,%rax,1)
++			   '\x84', '\x00', '\x00',
++                           '\x00', '\x00', '\x00' };
+ 
+   const char* nops[16] = {
+     NULL,
+diff --git a/include/ChangeLog b/include/ChangeLog
+index af96977..e32f0f9 100644
+--- a/include/ChangeLog
++++ b/include/ChangeLog
+@@ -1,3 +1,11 @@
++2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	Backport from mainline:
++
++	2011-12-19  Chung-Lin Tang  <cltang@codesourcery.com>
++
++	* elf/mips.h (elf_mips_reloc_type): Add R_MIPS16_TLS_* entries.
++
+ 2011-10-25  Alan Modra  <amodra@gmail.com>
+ 
+ 	Apply mainline patches.
+diff --git a/include/elf/mips.h b/include/elf/mips.h
+index db5fa54..c2c5922 100644
+--- a/include/elf/mips.h
++++ b/include/elf/mips.h
+@@ -98,7 +98,14 @@ START_RELOC_NUMBERS (elf_mips_reloc_type)
+   RELOC_NUMBER (R_MIPS16_CALL16, 103)
+   RELOC_NUMBER (R_MIPS16_HI16, 104)
+   RELOC_NUMBER (R_MIPS16_LO16, 105)
+-  FAKE_RELOC (R_MIPS16_max, 106)
++  RELOC_NUMBER (R_MIPS16_TLS_GD, 106)
++  RELOC_NUMBER (R_MIPS16_TLS_LDM, 107)
++  RELOC_NUMBER (R_MIPS16_TLS_DTPREL_HI16, 108)
++  RELOC_NUMBER (R_MIPS16_TLS_DTPREL_LO16, 109)
++  RELOC_NUMBER (R_MIPS16_TLS_GOTTPREL, 110)
++  RELOC_NUMBER (R_MIPS16_TLS_TPREL_HI16, 111)
++  RELOC_NUMBER (R_MIPS16_TLS_TPREL_LO16, 112)
++  FAKE_RELOC (R_MIPS16_max, 113)
+   /* These relocations are specific to VxWorks.  */
+   RELOC_NUMBER (R_MIPS_COPY, 126)
+   RELOC_NUMBER (R_MIPS_JUMP_SLOT, 127)
+diff --git a/ld/ChangeLog b/ld/ChangeLog
+index f5fa6ff..98fd778 100644
+--- a/ld/ChangeLog
++++ b/ld/ChangeLog
+@@ -1,3 +1,23 @@
++2012-05-11  Ralf Cors√©pius  <ralf.corsepius@rtems.org>
++
++	PR ld/13991
++	Backport from mainline:
++	2012-04-24  Alan Modra  <amodra@gmail.com>
++
++	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
++	usrdata->flags.just_syms.
++	* ld/ldwrite.c (build_link_order): Likewise.
++	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
++	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
++	* ld/emultempl/armelf.em (build_section_lists): Likewise.
++	(after_allocation): Update for renamed sec_info_type value.
++	* ld/emultempl/tic6xdsbt.em: Likewise.
++
++2011-12-20  Joseph Myers  <joseph@codesourcery.com>
++
++	* emulparams/elf32bmip.sh (OTHER_SECTIONS): Put .mdebug.* and
++	.gcc_compiled_long* sections at address 0.
++
+ 2011-11-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+ 
+ 	Backport from mainline:
+diff --git a/ld/emulparams/elf32bmip.sh b/ld/emulparams/elf32bmip.sh
+index 44a0b8a..f0fcd2c 100644
+--- a/ld/emulparams/elf32bmip.sh
++++ b/ld/emulparams/elf32bmip.sh
+@@ -64,14 +64,14 @@ OTHER_BSS_SYMBOLS='_fbss = .;'
+ OTHER_SECTIONS='
+   .gptab.sdata : { *(.gptab.data) *(.gptab.sdata) }
+   .gptab.sbss : { *(.gptab.bss) *(.gptab.sbss) }
+-  .mdebug.abi32 : { KEEP(*(.mdebug.abi32)) }
+-  .mdebug.abiN32 : { KEEP(*(.mdebug.abiN32)) }
+-  .mdebug.abi64 : { KEEP(*(.mdebug.abi64)) }
+-  .mdebug.abiO64 : { KEEP(*(.mdebug.abiO64)) }
+-  .mdebug.eabi32 : { KEEP(*(.mdebug.eabi32)) }
+-  .mdebug.eabi64 : { KEEP(*(.mdebug.eabi64)) }
+-  .gcc_compiled_long32 : { KEEP(*(.gcc_compiled_long32)) }
+-  .gcc_compiled_long64 : { KEEP(*(.gcc_compiled_long64)) }
++  .mdebug.abi32 0 : { KEEP(*(.mdebug.abi32)) }
++  .mdebug.abiN32 0 : { KEEP(*(.mdebug.abiN32)) }
++  .mdebug.abi64 0 : { KEEP(*(.mdebug.abi64)) }
++  .mdebug.abiO64 0 : { KEEP(*(.mdebug.abiO64)) }
++  .mdebug.eabi32 0 : { KEEP(*(.mdebug.eabi32)) }
++  .mdebug.eabi64 0 : { KEEP(*(.mdebug.eabi64)) }
++  .gcc_compiled_long32 0 : { KEEP(*(.gcc_compiled_long32)) }
++  .gcc_compiled_long64 0 : { KEEP(*(.gcc_compiled_long64)) }
+ '
+ ARCH=mips
+ MACHINE=
+diff --git a/ld/emultempl/armelf.em b/ld/emultempl/armelf.em
+index d29da59..7631474 100644
+--- a/ld/emultempl/armelf.em
++++ b/ld/emultempl/armelf.em
+@@ -240,7 +240,7 @@ build_section_lists (lang_statement_union_type *statement)
+     {
+       asection *i = statement->input_section.section;
+ 
+-      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
++      if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 	  && (i->flags & SEC_EXCLUDE) == 0
+ 	  && i->output_section != NULL
+ 	  && i->output_section->owner == link_info.output_bfd)
+@@ -299,7 +299,7 @@ gld${EMULATION_NAME}_after_allocation (void)
+ 		  && elf_section_type (sec) == SHT_PROGBITS
+ 		  && (elf_section_flags (sec) & SHF_EXECINSTR) != 0
+ 		  && (sec->flags & SEC_EXCLUDE) == 0
+-		  && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS
++		  && sec->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 		  && out_sec != bfd_abs_section_ptr)
+ 		{
+ 		  if (sec_count == list_size)
+diff --git a/ld/emultempl/hppaelf.em b/ld/emultempl/hppaelf.em
+index 1137ba2..6258bf4 100644
+--- a/ld/emultempl/hppaelf.em
++++ b/ld/emultempl/hppaelf.em
+@@ -229,7 +229,7 @@ build_section_lists (lang_statement_union_type *statement)
+     {
+       asection *i = statement->input_section.section;
+ 
+-      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
++      if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 	  && (i->flags & SEC_EXCLUDE) == 0
+ 	  && i->output_section != NULL
+ 	  && i->output_section->owner == link_info.output_bfd)
+diff --git a/ld/emultempl/ppc64elf.em b/ld/emultempl/ppc64elf.em
+index 92a468f..52b9f05 100644
+--- a/ld/emultempl/ppc64elf.em
++++ b/ld/emultempl/ppc64elf.em
+@@ -428,7 +428,7 @@ build_toc_list (lang_statement_union_type *statement)
+     {
+       asection *i = statement->input_section.section;
+ 
+-      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
++      if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 	  && (i->flags & SEC_EXCLUDE) == 0
+ 	  && i->output_section == toc_section)
+ 	{
+@@ -446,7 +446,7 @@ build_section_lists (lang_statement_union_type *statement)
+     {
+       asection *i = statement->input_section.section;
+ 
+-      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
++      if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 	  && (i->flags & SEC_EXCLUDE) == 0
+ 	  && i->output_section != NULL
+ 	  && i->output_section->owner == link_info.output_bfd)
+diff --git a/ld/emultempl/tic6xdsbt.em b/ld/emultempl/tic6xdsbt.em
+index e287005..fd7a12b 100644
+--- a/ld/emultempl/tic6xdsbt.em
++++ b/ld/emultempl/tic6xdsbt.em
+@@ -122,7 +122,7 @@ gld${EMULATION_NAME}_after_allocation (void)
+ 		  && elf_section_type (sec) == SHT_PROGBITS
+ 		  && (elf_section_flags (sec) & SHF_EXECINSTR) != 0
+ 		  && (sec->flags & SEC_EXCLUDE) == 0
+-		  && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS
++		  && sec->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 		  && out_sec != bfd_abs_section_ptr)
+ 		{
+ 		  if (sec_count == list_size)
+diff --git a/ld/ldlang.c b/ld/ldlang.c
+index 2c56b56..7ecbae2 100644
+--- a/ld/ldlang.c
++++ b/ld/ldlang.c
+@@ -4648,7 +4648,7 @@ size_input_section
+   lang_input_section_type *is = &((*this_ptr)->input_section);
+   asection *i = is->section;
+ 
+-  if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
++  if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+       && (i->flags & SEC_EXCLUDE) == 0)
+     {
+       unsigned int alignment_needed;
+diff --git a/ld/ldwrite.c b/ld/ldwrite.c
+index b7a1469..2503d1f 100644
+--- a/ld/ldwrite.c
++++ b/ld/ldwrite.c
+@@ -1,6 +1,6 @@
+ /* ldwrite.c -- write out the linked file
+    Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2000, 2002,
+-   2003, 2004, 2005, 2006, 2007, 2008, 2010
++   2003, 2004, 2005, 2006, 2007, 2008, 2010, 2012
+    Free Software Foundation, Inc.
+    Written by Steve Chamberlain sac@cygnus.com
+ 
+@@ -240,7 +240,7 @@ build_link_order (lang_statement_union_type *statement)
+ 	   attached */
+ 	asection *i = statement->input_section.section;
+ 
+-	if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
++	if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
+ 	    && (i->flags & SEC_EXCLUDE) == 0)
+ 	  {
+ 	    asection *output_section = i->output_section;
+diff --git a/ld/testsuite/ChangeLog b/ld/testsuite/ChangeLog
+index 233d962..6318c4f 100644
+--- a/ld/testsuite/ChangeLog
++++ b/ld/testsuite/ChangeLog
+@@ -1,3 +1,22 @@
++2012-01-10  H.J. Lu  <hongjiu.lu@intel.com>
++
++	Backport from mainline:
++	PR ld/13581
++	* ld-x86-64/ilp32-4.s: New.
++	* ld-x86-64/ilp32-10.d: Likewise.
++	* ld-x86-64/ilp32-10.s: Likewise.
++
++	* ld-x86-64/ilp32-4.d: Adjusted.
++	* ld-x86-64/ilp32-5.d: Likewise.
++	* ld-x86-64/ilp32-5.s: Likewise.
++
++	* ld-x86-64/x86-64.exp: Run ilp32-10.
++
++2011-12-01  Hans-Peter Nilsson  <hp@axis.com>
++
++	* ld-cris/pic-gc-72.d: Revert last change to adjust for reverted
++	cause for last change.
++
+ 2011-11-10  Matthew Gretton-Dann  <matthew.gretton-dann@arm.com>
+ 
+ 	Apply mainline patches.
+diff --git a/ld/testsuite/ld-cris/pic-gc-72.d b/ld/testsuite/ld-cris/pic-gc-72.d
+index 7e72752..7c30980 100644
+--- a/ld/testsuite/ld-cris/pic-gc-72.d
++++ b/ld/testsuite/ld-cris/pic-gc-72.d
+@@ -19,11 +19,10 @@ Contents of section .dynsym:
+ Contents of section .dynstr:
+ #...
+ Contents of section .text:
+- 016e 0f050f05                             .*
++ 0188 0f050f05                             .*
+ Contents of section .dynamic:
+- 2174 .*
+ #...
+ Contents of section .got:
+- 21cc 74210000 00000000 00000000           .*
++ 21e4 8c210000 00000000 00000000           .*
+ Contents of section .data:
+- 21d8 00000000                             .*
++ 21f0 00000000                             .*
+diff --git a/ld/testsuite/ld-x86-64/ilp32-10.d b/ld/testsuite/ld-x86-64/ilp32-10.d
+new file mode 100644
+index 0000000..43d9fbd
+--- /dev/null
++++ b/ld/testsuite/ld-x86-64/ilp32-10.d
+@@ -0,0 +1,3 @@
++#as: --x32
++#ld: -shared -melf32_x86_64
++#error: .*relocation R_X86_64_PC32 against undefined symbol `bar' can not be used when making a shared object; recompile with -fPIC
+diff --git a/ld/testsuite/ld-x86-64/ilp32-10.s b/ld/testsuite/ld-x86-64/ilp32-10.s
+new file mode 100644
+index 0000000..70e4a90
+--- /dev/null
++++ b/ld/testsuite/ld-x86-64/ilp32-10.s
+@@ -0,0 +1,3 @@
++	.globl foo
++foo:
++	mov bar(%rip), %rax
+diff --git a/ld/testsuite/ld-x86-64/ilp32-4.d b/ld/testsuite/ld-x86-64/ilp32-4.d
+index 84dc7b2..92d8a67 100644
+--- a/ld/testsuite/ld-x86-64/ilp32-4.d
++++ b/ld/testsuite/ld-x86-64/ilp32-4.d
+@@ -1,36 +1,30 @@
+-#source: start.s
+ #as: --x32
+ #ld: -m elf32_x86_64 -shared --no-ld-generated-unwind-info
+ #readelf: -d -S --wide
+ 
+-There are 10 section headers, starting at offset 0x22c:
++There are 9 section headers, starting at offset 0x1d8:
+ 
+ Section Headers:
+   \[Nr\] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
+   \[ 0\]                   NULL            00000000 000000 000000 00      0   0  0
+-  \[ 1\] .hash             HASH            00000094 000094 000030 04   A  2   0  4
+-  \[ 2\] .dynsym           DYNSYM          000000c4 0000c4 000070 10   A  3   2  4
+-  \[ 3\] .dynstr           STRTAB          00000134 000134 00001d 00   A  0   0  1
+-  \[ 4\] .rela.dyn         RELA            00000154 000154 00000c 0c   A  2   0  4
+-  \[ 5\] .text             PROGBITS        00000160 000160 000005 00  AX  0   0  4
+-  \[ 6\] .dynamic          DYNAMIC         00200168 000168 000078 08  WA  3   0  4
+-  \[ 7\] .shstrtab         STRTAB          00000000 0001e0 00004a 00      0   0  1
+-  \[ 8\] .symtab           SYMTAB          00000000 0003bc 0000e0 10      9   9  4
+-  \[ 9\] .strtab           STRTAB          00000000 00049c 000043 00      0   0  1
++  \[ 1\] .hash             HASH            00000094 000094 00002c 04   A  2   0  4
++  \[ 2\] .dynsym           DYNSYM          000000c0 0000c0 000060 10   A  3   2  4
++  \[ 3\] .dynstr           STRTAB          00000120 000120 000019 00   A  0   0  1
++  \[ 4\] .text             PROGBITS        0000013c 00013c 000001 00  AX  0   0  4
++  \[ 5\] .dynamic          DYNAMIC         00200140 000140 000058 08  WA  3   0  4
++  \[ 6\] .shstrtab         STRTAB          00000000 000198 000040 00      0   0  1
++  \[ 7\] .symtab           SYMTAB          00000000 000340 0000c0 10      8   8  4
++  \[ 8\] .strtab           STRTAB          00000000 000400 00003f 00      0   0  1
+ Key to Flags:
+   W \(write\), A \(alloc\), X \(execute\), M \(merge\), S \(strings\), l \(large\)
+   I \(info\), L \(link order\), G \(group\), T \(TLS\), E \(exclude\), x \(unknown\)
+   O \(extra OS processing required\) o \(OS specific\), p \(processor specific\)
+ 
+-Dynamic section at offset 0x168 contains 10 entries:
++Dynamic section at offset 0x140 contains 6 entries:
+   Tag        Type                         Name/Value
+  0x00000004 \(HASH\)                       0x94
+- 0x00000005 \(STRTAB\)                     0x134
+- 0x00000006 \(SYMTAB\)                     0xc4
+- 0x0000000a \(STRSZ\)                      29 \(bytes\)
++ 0x00000005 \(STRTAB\)                     0x120
++ 0x00000006 \(SYMTAB\)                     0xc0
++ 0x0000000a \(STRSZ\)                      25 \(bytes\)
+  0x0000000b \(SYMENT\)                     16 \(bytes\)
+- 0x00000007 \(RELA\)                       0x154
+- 0x00000008 \(RELASZ\)                     12 \(bytes\)
+- 0x00000009 \(RELAENT\)                    12 \(bytes\)
+- 0x00000016 \(TEXTREL\)                    0x0
+  0x00000000 \(NULL\)                       0x0
+diff --git a/ld/testsuite/ld-x86-64/ilp32-4.s b/ld/testsuite/ld-x86-64/ilp32-4.s
+new file mode 100644
+index 0000000..5f270c7
+--- /dev/null
++++ b/ld/testsuite/ld-x86-64/ilp32-4.s
+@@ -0,0 +1,3 @@
++	.globl _start
++_start:
++	ret
+diff --git a/ld/testsuite/ld-x86-64/ilp32-5.d b/ld/testsuite/ld-x86-64/ilp32-5.d
+index e4673e5..4870c2b 100644
+--- a/ld/testsuite/ld-x86-64/ilp32-5.d
++++ b/ld/testsuite/ld-x86-64/ilp32-5.d
+@@ -4,5 +4,5 @@
+ 
+ #...
+ [0-9a-f]+ +[0-9a-f]+ +R_X86_64_RELATIVE +[0-9a-f]+
+-[0-9a-f]+ +[0-9a-f]+ +R_X86_64_PC32 +[0-9a-f]+ +foo - 4
++[0-9a-f]+ +[0-9a-f]+ +R_X86_64_GLOB_DAT +[0-9a-f]+ +foo \+ 0
+ [0-9a-f]+ +[0-9a-f]+ +R_X86_64_32 +[0-9a-f]+ +foo \+ 0
+diff --git a/ld/testsuite/ld-x86-64/ilp32-5.s b/ld/testsuite/ld-x86-64/ilp32-5.s
+index 0d97807..ef0c60e 100644
+--- a/ld/testsuite/ld-x86-64/ilp32-5.s
++++ b/ld/testsuite/ld-x86-64/ilp32-5.s
+@@ -1,6 +1,6 @@
+ 	.globl bar
+ bar:
+-	mov foo(%rip), %rax
++	mov foo@GOTPCREL(%rip), %rax
+ 
+ 	.data
+ xxx:
+diff --git a/ld/testsuite/ld-x86-64/x86-64.exp b/ld/testsuite/ld-x86-64/x86-64.exp
+index 77b081b..44d3e07 100644
+--- a/ld/testsuite/ld-x86-64/x86-64.exp
++++ b/ld/testsuite/ld-x86-64/x86-64.exp
+@@ -207,6 +207,7 @@ run_dump_test "ilp32-6"
+ run_dump_test "ilp32-7"
+ run_dump_test "ilp32-8"
+ run_dump_test "ilp32-9"
++run_dump_test "ilp32-10"
+ run_dump_test "ia32-1"
+ run_dump_test "ia32-2"
+ run_dump_test "ia32-3"
+diff --git a/opcodes/ChangeLog b/opcodes/ChangeLog
+index a445030..26f759e 100644
+--- a/opcodes/ChangeLog
++++ b/opcodes/ChangeLog
+@@ -1,3 +1,8 @@
++2011-11-25  Pierre Muller  <muller@ics.u-strasbg.fr>
++
++	* mips-dis.c (print_insn_micromips): Rename local variable iprintf
++	to infprintf to avoid shadow warning.
++
+ 2011-10-27  Peter Bergner  <bergner@vnet.ibm.com>
+ 
+ 	* ppc-opc.c (powerpc_opcodes) <drrndq, drrndq., dtstexq, dctqpq,
+diff --git a/opcodes/mips-dis.c b/opcodes/mips-dis.c
+index 4e18d8a..72285de 100644
+--- a/opcodes/mips-dis.c
++++ b/opcodes/mips-dis.c
+@@ -2260,7 +2260,7 @@ print_insn_mips16 (bfd_vma memaddr, struct disassemble_info *info)
+ static int
+ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ {
+-  const fprintf_ftype iprintf = info->fprintf_func;
++  const fprintf_ftype infprintf = info->fprintf_func;
+   const struct mips_opcode *op, *opend;
+   unsigned int lsb, msbd, msb;
+   void *is = info->stream;
+@@ -2307,7 +2307,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+       status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
+       if (status != 0)
+ 	{
+-	  iprintf (is, "micromips 0x%x", higher);
++	  infprintf (is, "micromips 0x%x", higher);
+ 	  (*info->memory_error_func) (status, memaddr + 2, info);
+ 	  return -1;
+ 	}
+@@ -2320,7 +2320,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+       status = (*info->read_memory_func) (memaddr + 4, buffer, 2, info);
+       if (status != 0)
+ 	{
+-	  iprintf (is, "micromips 0x%x", higher);
++	  infprintf (is, "micromips 0x%x", higher);
+ 	  (*info->memory_error_func) (status, memaddr + 4, info);
+ 	  return -1;
+ 	}
+@@ -2328,7 +2328,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 	insn = bfd_getb16 (buffer);
+       else
+ 	insn = bfd_getl16 (buffer);
+-      iprintf (is, "0x%x%04x (48-bit insn)", higher, insn);
++      infprintf (is, "0x%x%04x (48-bit insn)", higher, insn);
+ 
+       info->insn_type = dis_noninsn;
+       return 6;
+@@ -2341,7 +2341,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+       status = (*info->read_memory_func) (memaddr + 2, buffer, 2, info);
+       if (status != 0)
+ 	{
+-	  iprintf (is, "micromips 0x%x", higher);
++	  infprintf (is, "micromips 0x%x", higher);
+ 	  (*info->memory_error_func) (status, memaddr + 2, info);
+ 	  return -1;
+ 	}
+@@ -2371,9 +2371,9 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 	{
+ 	  const char *s;
+ 
+-	  iprintf (is, "%s", op->name);
++	  infprintf (is, "%s", op->name);
+ 	  if (op->args[0] != '\0')
+-	    iprintf (is, "\t");
++	    infprintf (is, "\t");
+ 
+ 	  for (s = op->args; *s != '\0'; s++)
+ 	    {
+@@ -2382,37 +2382,37 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		case ',':
+ 		case '(':
+ 		case ')':
+-		  iprintf (is, "%c", *s);
++		  infprintf (is, "%c", *s);
+ 		  break;
+ 
+ 		case '.':
+ 		  delta = GET_OP (insn, OFFSET10);
+ 		  if (delta & 0x200)
+ 		    delta |= ~0x3ff;
+-		  iprintf (is, "%d", delta);
++		  infprintf (is, "%d", delta);
+ 		  break;
+ 
+ 		case '1':
+-		  iprintf (is, "0x%lx", GET_OP (insn, STYPE));
++		  infprintf (is, "0x%lx", GET_OP (insn, STYPE));
+ 		  break;
+ 
+ 		case '<':
+-		  iprintf (is, "0x%lx", GET_OP (insn, SHAMT));
++		  infprintf (is, "0x%lx", GET_OP (insn, SHAMT));
+ 		  break;
+ 
+ 		case '\\':
+-		  iprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
++		  infprintf (is, "0x%lx", GET_OP (insn, 3BITPOS));
+ 		  break;
+ 
+ 		case '|':
+-		  iprintf (is, "0x%lx", GET_OP (insn, TRAP));
++		  infprintf (is, "0x%lx", GET_OP (insn, TRAP));
+ 		  break;
+ 
+ 		case '~':
+ 		  delta = GET_OP (insn, OFFSET12);
+ 		  if (delta & 0x800)
+ 		    delta |= ~0x7ff;
+-		  iprintf (is, "%d", delta);
++		  infprintf (is, "%d", delta);
+ 		  break;
+ 
+ 		case 'a':
+@@ -2433,34 +2433,34 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		case 'r':
+ 		case 's':
+ 		case 'v':
+-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
++		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS)]);
+ 		  break;
+ 
+ 		case 'c':
+-		  iprintf (is, "0x%lx", GET_OP (insn, CODE));
++		  infprintf (is, "0x%lx", GET_OP (insn, CODE));
+ 		  break;
+ 
+ 		case 'd':
+-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
++		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RD)]);
+ 		  break;
+ 
+ 		case 'h':
+-		  iprintf (is, "0x%lx", GET_OP (insn, PREFX));
++		  infprintf (is, "0x%lx", GET_OP (insn, PREFX));
+ 		  break;
+ 
+ 		case 'i':
+ 		case 'u':
+-		  iprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
++		  infprintf (is, "0x%lx", GET_OP (insn, IMMEDIATE));
+ 		  break;
+ 
+ 		case 'j': /* Same as i, but sign-extended.  */
+ 		case 'o':
+ 		  delta = (GET_OP (insn, DELTA) ^ 0x8000) - 0x8000;
+-		  iprintf (is, "%d", delta);
++		  infprintf (is, "%d", delta);
+ 		  break;
+ 
+ 		case 'k':
+-		  iprintf (is, "0x%x", GET_OP (insn, CACHE));
++		  infprintf (is, "0x%x", GET_OP (insn, CACHE));
+ 		  break;
+ 
+ 		case 'n':
+@@ -2472,26 +2472,26 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		    if (s_reg_encode != 0)
+ 		      {
+ 			if (s_reg_encode == 1)
+-			  iprintf (is, "%s", mips_gpr_names[16]);
++			  infprintf (is, "%s", mips_gpr_names[16]);
+ 			else if (s_reg_encode < 9)
+-			  iprintf (is, "%s-%s",
++			  infprintf (is, "%s-%s",
+ 				   mips_gpr_names[16],
+ 				   mips_gpr_names[15 + s_reg_encode]);
+ 			else if (s_reg_encode == 9)
+-			  iprintf (is, "%s-%s,%s",
++			  infprintf (is, "%s-%s,%s",
+ 				   mips_gpr_names[16],
+ 				   mips_gpr_names[23],
+ 				   mips_gpr_names[30]);
+ 			else
+-			  iprintf (is, "UNKNOWN");
++			  infprintf (is, "UNKNOWN");
+ 		      }
+ 
+ 		    if (immed & 0x10) /* For ra.  */
+ 		      {
+ 			if (s_reg_encode == 0)
+-			  iprintf (is, "%s", mips_gpr_names[31]);
++			  infprintf (is, "%s", mips_gpr_names[31]);
+ 			else
+-			  iprintf (is, ",%s", mips_gpr_names[31]);
++			  infprintf (is, ",%s", mips_gpr_names[31]);
+ 		      }
+ 		    break;
+ 		  }
+@@ -2504,32 +2504,32 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		  break;
+ 
+ 		case 'q':
+-		  iprintf (is, "0x%lx", GET_OP (insn, CODE2));
++		  infprintf (is, "0x%lx", GET_OP (insn, CODE2));
+ 		  break;
+ 
+ 		case 't':
+ 		case 'w':
+-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
++		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RT)]);
+ 		  break;
+ 
+ 		case 'y':
+-		  iprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
++		  infprintf (is, "%s", mips_gpr_names[GET_OP (insn, RS3)]);
+ 		  break;
+ 
+ 		case 'z':
+-		  iprintf (is, "%s", mips_gpr_names[0]);
++		  infprintf (is, "%s", mips_gpr_names[0]);
+ 		  break;
+ 
+ 		case 'B':
+-		  iprintf (is, "0x%lx", GET_OP (insn, CODE10));
++		  infprintf (is, "0x%lx", GET_OP (insn, CODE10));
+ 		  break;
+ 
+ 		case 'C':
+-		  iprintf (is, "0x%lx", GET_OP (insn, COPZ));
++		  infprintf (is, "0x%lx", GET_OP (insn, COPZ));
+ 		  break;
+ 
+ 		case 'D':
+-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
++		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FD)]);
+ 		  break;
+ 
+ 		case 'E':
+@@ -2540,7 +2540,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		    'T' format.  Therefore, until we gain understanding of
+ 		    cp2 register names, we can simply print the register
+ 		    numbers.  */
+-		  iprintf (is, "$%ld", GET_OP (insn, RT));
++		  infprintf (is, "$%ld", GET_OP (insn, RT));
+ 		  break;
+ 
+ 		case 'G':
+@@ -2559,44 +2559,44 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		    case 0x000002fc:				/* mtc0  */
+ 		    case 0x580000fc:				/* dmfc0 */
+ 		    case 0x580002fc:				/* dmtc0 */
+-		      iprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
++		      infprintf (is, "%s", mips_cp0_names[GET_OP (insn, RS)]);
+ 		      break;
+ 		    default:
+-		      iprintf (is, "$%ld", GET_OP (insn, RS));
++		      infprintf (is, "$%ld", GET_OP (insn, RS));
+ 		      break;
+ 		    }
+ 		  break;
+ 
+ 		case 'H':
+-		  iprintf (is, "%ld", GET_OP (insn, SEL));
++		  infprintf (is, "%ld", GET_OP (insn, SEL));
+ 		  break;
+ 
+ 		case 'K':
+-		  iprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
++		  infprintf (is, "%s", mips_hwr_names[GET_OP (insn, RS)]);
+ 		  break;
+ 
+ 		case 'M':
+-		  iprintf (is, "$fcc%ld", GET_OP (insn, CCC));
++		  infprintf (is, "$fcc%ld", GET_OP (insn, CCC));
+ 		  break;
+ 
+ 		case 'N':
+-		  iprintf (is,
++		  infprintf (is,
+ 			   (op->pinfo & (FP_D | FP_S)) != 0
+ 			   ? "$fcc%ld" : "$cc%ld",
+ 			   GET_OP (insn, BCC));
+ 		  break;
+ 
+ 		case 'R':
+-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
++		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FR)]);
+ 		  break;
+ 
+ 		case 'S':
+ 		case 'V':
+-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
++		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FS)]);
+ 		  break;
+ 
+ 		case 'T':
+-		  iprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
++		  infprintf (is, "%s", mips_fpr_names[GET_OP (insn, FT)]);
+ 		  break;
+ 
+ 		case '+':
+@@ -2606,18 +2606,18 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		    {
+ 		    case 'A':
+ 		      lsb = GET_OP (insn, EXTLSB);
+-		      iprintf (is, "0x%x", lsb);
++		      infprintf (is, "0x%x", lsb);
+ 		      break;
+ 
+ 		    case 'B':
+ 		      msb = GET_OP (insn, INSMSB);
+-		      iprintf (is, "0x%x", msb - lsb + 1);
++		      infprintf (is, "0x%x", msb - lsb + 1);
+ 		      break;
+ 
+ 		    case 'C':
+ 		    case 'H':
+ 		      msbd = GET_OP (insn, EXTMSBD);
+-		      iprintf (is, "0x%x", msbd + 1);
++		      infprintf (is, "0x%x", msbd + 1);
+ 		      break;
+ 
+ 		    case 'D':
+@@ -2637,30 +2637,30 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 						     mips_cp0sel_names_len,
+ 						     cp0reg, sel);
+ 			if (n != NULL)
+-			  iprintf (is, "%s", n->name);
++			  infprintf (is, "%s", n->name);
+ 			else
+-			  iprintf (is, "$%d,%d", cp0reg, sel);
++			  infprintf (is, "$%d,%d", cp0reg, sel);
+ 			break;
+ 		      }
+ 
+ 		    case 'E':
+ 		      lsb = GET_OP (insn, EXTLSB) + 32;
+-		      iprintf (is, "0x%x", lsb);
++		      infprintf (is, "0x%x", lsb);
+ 		      break;
+ 
+ 		    case 'F':
+ 		      msb = GET_OP (insn, INSMSB) + 32;
+-		      iprintf (is, "0x%x", msb - lsb + 1);
++		      infprintf (is, "0x%x", msb - lsb + 1);
+ 		      break;
+ 
+ 		    case 'G':
+ 		      msbd = GET_OP (insn, EXTMSBD) + 32;
+-		      iprintf (is, "0x%x", msbd + 1);
++		      infprintf (is, "0x%x", msbd + 1);
+ 		      break;
+ 
+ 		    default:
+ 		      /* xgettext:c-format */
+-		      iprintf (is,
++		      infprintf (is,
+ 			       _("# internal disassembler error, "
+ 				 "unrecognized modifier (+%c)"),
+ 			       *s);
+@@ -2674,111 +2674,111 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		  switch (*s)
+ 		    {
+ 		    case 'a':	/* global pointer.  */
+-		      iprintf (is, "%s", mips_gpr_names[28]);
++		      infprintf (is, "%s", mips_gpr_names[28]);
+ 		      break;
+ 
+ 		    case 'b':
+ 		      regno = micromips_to_32_reg_b_map[GET_OP (insn, MB)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'c':
+ 		      regno = micromips_to_32_reg_c_map[GET_OP (insn, MC)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'd':
+ 		      regno = micromips_to_32_reg_d_map[GET_OP (insn, MD)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'e':
+ 		      regno = micromips_to_32_reg_e_map[GET_OP (insn, ME)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'f':
+ 		      /* Save lastregno for "mt" to print out later.  */
+ 		      lastregno = micromips_to_32_reg_f_map[GET_OP (insn, MF)];
+-		      iprintf (is, "%s", mips_gpr_names[lastregno]);
++		      infprintf (is, "%s", mips_gpr_names[lastregno]);
+ 		      break;
+ 
+ 		    case 'g':
+ 		      regno = micromips_to_32_reg_g_map[GET_OP (insn, MG)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'h':
+ 		      regno = micromips_to_32_reg_h_map[GET_OP (insn, MH)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'i':
+ 		      regno = micromips_to_32_reg_i_map[GET_OP (insn, MI)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'j':
+-		      iprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
++		      infprintf (is, "%s", mips_gpr_names[GET_OP (insn, MJ)]);
+ 		      break;
+ 
+ 		    case 'l':
+ 		      regno = micromips_to_32_reg_l_map[GET_OP (insn, ML)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'm':
+ 		      regno = micromips_to_32_reg_m_map[GET_OP (insn, MM)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'n':
+ 		      regno = micromips_to_32_reg_n_map[GET_OP (insn, MN)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'p':
+ 		      /* Save lastregno for "mt" to print out later.  */
+ 		      lastregno = GET_OP (insn, MP);
+-		      iprintf (is, "%s", mips_gpr_names[lastregno]);
++		      infprintf (is, "%s", mips_gpr_names[lastregno]);
+ 		      break;
+ 
+ 		    case 'q':
+ 		      regno = micromips_to_32_reg_q_map[GET_OP (insn, MQ)];
+-		      iprintf (is, "%s", mips_gpr_names[regno]);
++		      infprintf (is, "%s", mips_gpr_names[regno]);
+ 		      break;
+ 
+ 		    case 'r':	/* program counter.  */
+-		      iprintf (is, "$pc");
++		      infprintf (is, "$pc");
+ 		      break;
+ 
+ 		    case 's':	/* stack pointer.  */
+ 		      lastregno = 29;
+-		      iprintf (is, "%s", mips_gpr_names[29]);
++		      infprintf (is, "%s", mips_gpr_names[29]);
+ 		      break;
+ 
+ 		    case 't':
+-		      iprintf (is, "%s", mips_gpr_names[lastregno]);
++		      infprintf (is, "%s", mips_gpr_names[lastregno]);
+ 		      break;
+ 
+ 		    case 'z':	/* $0.  */
+-		      iprintf (is, "%s", mips_gpr_names[0]);
++		      infprintf (is, "%s", mips_gpr_names[0]);
+ 		      break;
+ 
+ 		    case 'A':
+ 		      /* Sign-extend the immediate.  */
+ 		      immed = ((GET_OP (insn, IMMA) ^ 0x40) - 0x40) << 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'B':
+ 		      immed = micromips_imm_b_map[GET_OP (insn, IMMB)];
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'C':
+ 		      immed = micromips_imm_c_map[GET_OP (insn, IMMC)];
+-		      iprintf (is, "0x%lx", immed);
++		      infprintf (is, "0x%lx", immed);
+ 		      break;
+ 
+ 		    case 'D':
+@@ -2797,50 +2797,50 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 
+ 		    case 'F':
+ 		      immed = GET_OP (insn, IMMF);
+-		      iprintf (is, "0x%x", immed);
++		      infprintf (is, "0x%x", immed);
+ 		      break;
+ 
+ 		    case 'G':
+ 		      immed = (insn >> MICROMIPSOP_SH_IMMG) + 1;
+ 		      immed = (immed & MICROMIPSOP_MASK_IMMG) - 1;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'H':
+ 		      immed = GET_OP (insn, IMMH) << 1;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'I':
+ 		      immed = (insn >> MICROMIPSOP_SH_IMMI) + 1;
+ 		      immed = (immed & MICROMIPSOP_MASK_IMMI) - 1;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'J':
+ 		      immed = GET_OP (insn, IMMJ) << 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'L':
+ 		      immed = GET_OP (insn, IMML);
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'M':
+ 		      immed = (insn >> MICROMIPSOP_SH_IMMM) - 1;
+ 		      immed = (immed & MICROMIPSOP_MASK_IMMM) + 1;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'N':
+ 		      immed = GET_OP (insn, IMMN);
+ 		      if (immed == 0)
+-			iprintf (is, "%s,%s",
++			infprintf (is, "%s,%s",
+ 				 mips_gpr_names[16],
+ 				 mips_gpr_names[31]);
+ 		      else
+-			iprintf (is, "%s-%s,%s",
++			infprintf (is, "%s-%s,%s",
+ 				 mips_gpr_names[16],
+ 				 mips_gpr_names[16 + immed],
+ 				 mips_gpr_names[31]);
+@@ -2848,35 +2848,35 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 
+ 		    case 'O':
+ 		      immed = GET_OP (insn, IMMO);
+-		      iprintf (is, "0x%x", immed);
++		      infprintf (is, "0x%x", immed);
+ 		      break;
+ 
+ 		    case 'P':
+ 		      immed = GET_OP (insn, IMMP) << 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'Q':
+ 		      /* Sign-extend the immediate.  */
+ 		      immed = (GET_OP (insn, IMMQ) ^ 0x400000) - 0x400000;
+ 		      immed <<= 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'U':
+ 		      immed = GET_OP (insn, IMMU) << 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'W':
+ 		      immed = GET_OP (insn, IMMW) << 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'X':
+ 		      /* Sign-extend the immediate.  */
+ 		      immed = (GET_OP (insn, IMMX) ^ 0x8) - 0x8;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    case 'Y':
+@@ -2885,12 +2885,12 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 		      if (immed >= -2 && immed <= 1)
+ 			immed ^= 0x100;
+ 		      immed = immed << 2;
+-		      iprintf (is, "%d", immed);
++		      infprintf (is, "%d", immed);
+ 		      break;
+ 
+ 		    default:
+ 		      /* xgettext:c-format */
+-		      iprintf (is,
++		      infprintf (is,
+ 			       _("# internal disassembler error, "
+ 				 "unrecognized modifier (m%c)"),
+ 			       *s);
+@@ -2900,7 +2900,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+ 
+ 		default:
+ 		  /* xgettext:c-format */
+-		  iprintf (is,
++		  infprintf (is,
+ 			   _("# internal disassembler error, "
+ 			     "unrecognized modifier (%c)"),
+ 			   *s);
+@@ -2937,7 +2937,7 @@ print_insn_micromips (bfd_vma memaddr, struct disassemble_info *info)
+     }
+ #undef GET_OP
+ 
+-  iprintf (is, "0x%x", insn);
++  infprintf (is, "0x%x", insn);
+   info->insn_type = dis_noninsn;
+ 
+   return length;
diff -Nru a/patches/binutils/2.22/001_ld_makefile_patch.patch b/patches/binutils/2.22/001_ld_makefile_patch.patch
--- a/patches/binutils/2.22/001_ld_makefile_patch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/001_ld_makefile_patch.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,27 @@
+Author: 
+Description: Description: correct where ld scripts are installed
+Author: Chris Chimelis <chris@debian.org>
+Upstream status: N/A
+Date: ??
+--- a/ld/Makefile.am
++++ b/ld/Makefile.am
+@@ -24,7 +24,7 @@
+ # We put the scripts in the directory $(scriptdir)/ldscripts.
+ # We can't put the scripts in $(datadir) because the SEARCH_DIR
+ # directives need to be different for native and cross linkers.
+-scriptdir = $(tooldir)/lib
++scriptdir = $(libdir)
+ 
+ EMUL = @EMUL@
+ EMULATION_OFILES = @EMULATION_OFILES@
+--- a/ld/Makefile.in
++++ b/ld/Makefile.in
+@@ -337,7 +337,7 @@
+ # We put the scripts in the directory $(scriptdir)/ldscripts.
+ # We can't put the scripts in $(datadir) because the SEARCH_DIR
+ # directives need to be different for native and cross linkers.
+-scriptdir = $(tooldir)/lib
++scriptdir = $(libdir)
+ BASEDIR = $(srcdir)/..
+ BFDDIR = $(BASEDIR)/bfd
+ INCDIR = $(BASEDIR)/include
diff -Nru a/patches/binutils/2.22/002_gprof_profile_arcs.patch b/patches/binutils/2.22/002_gprof_profile_arcs.patch
--- a/patches/binutils/2.22/002_gprof_profile_arcs.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/002_gprof_profile_arcs.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,27 @@
+Author: Chris Chimelis <chris@debian.org>
+Description: Add more documentation about profiling and -fprofile-arcs.
+--- a/gprof/gprof.texi
++++ b/gprof/gprof.texi
+@@ -149,6 +149,10 @@
+ If more than one profile file is specified, the @code{gprof}
+ output shows the sum of the profile information in the given profile files.
+ 
++If you use gcc 2.95.x or 3.0 to compile your binaries, you may need
++to add the @samp{-fprofile-arcs} to the compile command line in order
++for the call graphs to be properly stored in gmon.out.
++
+ @code{Gprof} calculates the amount of time spent in each routine.
+ Next, these times are propagated along the edges of the call graph.
+ Cycles are discovered, and calls into a cycle are made to share the time
+@@ -280,6 +284,11 @@
+ options.  The same option, @samp{-pg}, alters either compilation or linking
+ to do what is necessary for profiling.  Here are examples:
+ 
++If you use gcc 2.95.x or 3.0.x, you may need to add the
++@samp{-fprofile-arcs} option to the compile line along with @samp{-pg}
++in order to allow the call-graphs to be properly included in the gmon.out
++file.
++
+ @example
+ cc -g -c myprog.c utils.c -pg
+ cc -o myprog myprog.o utils.o -pg
diff -Nru a/patches/binutils/2.22/003_gprof_see_also_monitor.patch b/patches/binutils/2.22/003_gprof_see_also_monitor.patch
--- a/patches/binutils/2.22/003_gprof_see_also_monitor.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/003_gprof_see_also_monitor.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,13 @@
+Author: Chris Chimelis <chris@debian.org>
+Description: Don't mention monitor(3) which doesn't exist in Debian. (#160654)
+--- a/gprof/gprof.texi
++++ b/gprof/gprof.texi
+@@ -197,7 +197,7 @@
+ @c man end
+ 
+ @c man begin SEEALSO
+-monitor(3), profil(2), cc(1), prof(1), and the Info entry for @file{gprof}.
++cc(1), prof(1), and the Info entry for @file{gprof}.
+ 
+ ``An Execution Profiler for Modular Programs'',
+ by S. Graham, P. Kessler, M. McKusick;
diff -Nru a/patches/binutils/2.22/006_better_file_error.patch b/patches/binutils/2.22/006_better_file_error.patch
--- a/patches/binutils/2.22/006_better_file_error.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/006_better_file_error.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,19 @@
+Author: David Kimdon <dwhedon@gordian.com>
+Description: Specify which filename is causing an error if the filename is a
+directory. (#45832)
+--- a/bfd/opncls.c
++++ b/bfd/opncls.c
+@@ -183,6 +183,13 @@
+ {
+   bfd *nbfd;
+   const bfd_target *target_vec;
++  struct stat s;
++
++  if (stat (filename, &s) == 0)
++    if (S_ISDIR(s.st_mode)) {
++      bfd_set_error (bfd_error_file_not_recognized);
++      return NULL;
++    }
+ 
+   nbfd = _bfd_new_bfd ();
+   if (nbfd == NULL)
diff -Nru a/patches/binutils/2.22/012_check_ldrunpath_length.patch b/patches/binutils/2.22/012_check_ldrunpath_length.patch
--- a/patches/binutils/2.22/012_check_ldrunpath_length.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/012_check_ldrunpath_length.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,23 @@
+Author: Chris Chimelis <chris@debian.org>
+Description: Only generate an RPATH entry if LD_RUN_PATH is not empty, for
+cases where -rpath isn't specified. (#151024)
+--- a/ld/emultempl/elf32.em
++++ b/ld/emultempl/elf32.em
+@@ -1266,6 +1266,8 @@
+ 	      && command_line.rpath == NULL)
+ 	    {
+ 	      lib_path = (const char *) getenv ("LD_RUN_PATH");
++	      if ((lib_path) && (strlen (lib_path) == 0))
++		lib_path = NULL;
+ 	      if (gld${EMULATION_NAME}_search_needed (lib_path, &n,
+ 						      force))
+ 		break;
+@@ -1493,6 +1495,8 @@
+   rpath = command_line.rpath;
+   if (rpath == NULL)
+     rpath = (const char *) getenv ("LD_RUN_PATH");
++  if ((rpath) && (strlen (rpath) == 0))
++      rpath = NULL;
+ 
+   for (abfd = link_info.input_bfds; abfd; abfd = abfd->link_next)
+     if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
diff -Nru a/patches/binutils/2.22/013_bash_in_ld_testsuite.patch b/patches/binutils/2.22/013_bash_in_ld_testsuite.patch
--- a/patches/binutils/2.22/013_bash_in_ld_testsuite.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/013_bash_in_ld_testsuite.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,26 @@
+Author: Matthias Klose <doko@ubuntu.com>
+Description: Explicitely use bash for the ld testsuite.
+--- a/ld/testsuite/config/default.exp
++++ b/ld/testsuite/config/default.exp
+@@ -119,10 +119,10 @@
+ 	#makefile rules, with embedded shell variable expansions.
+ 	#make wants $$shell_var, we want $shell_var ...
+ 	set cmd "host='$target_triplet' && . $srcdir/../configure.host && sed -e 's,\\\$\\\$,\$,g' <<EOF\n\$$varname\nEOF"
+-	set status [catch "exec sh -c [list $cmd]" result]
++	set status [catch "exec bash -c [list $cmd]" result]
+ 	if $status { error "Error getting native link files: $result" }
+ 	set cmd "CC='$CC' && eval echo \"$result\""
+-	set status [catch "exec sh -c [list $cmd]" result]
++	set status [catch "exec bash -c [list $cmd]" result]
+ 	if $status { error "Error getting native link files: $result" }
+ 	set $varname $result
+ 	send_log "$varname = $result\n"
+@@ -132,7 +132,7 @@
+ proc get_target_emul {} {
+     global target_triplet
+     global srcdir
+-    set status [catch "exec sh -c \"targ='$target_triplet' && . $srcdir/../configure.tgt && echo \\\$targ_emul\"" result]
++    set status [catch "exec bash -c \"targ='$target_triplet' && . $srcdir/../configure.tgt && echo \\\$targ_emul\"" result]
+     if $status { error "Error getting emulation name: $result" }
+     return $result
+ }
diff -Nru a/patches/binutils/2.22/127_x86_64_i386_biarch.patch b/patches/binutils/2.22/127_x86_64_i386_biarch.patch
--- a/patches/binutils/2.22/127_x86_64_i386_biarch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/127_x86_64_i386_biarch.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,20 @@
+Author: 
+Description: Description: Add (/usr)/lib32 to the search paths on x86_64.
+Author: Aurelien Jarno <aurel32.debian.org>
+Upstream status: Debian specific
+--- a/ld/emulparams/elf_i386.sh
++++ b/ld/emulparams/elf_i386.sh
+@@ -13,3 +13,13 @@
+ NO_SMALL_DATA=yes
+ SEPARATE_GOTPLT=12
+ IREL_IN_PLT=
++
++# Linux modify the default library search path to first include
++# a 32-bit specific directory.
++case "$target" in
++  x86_64*-linux* | i[3-7]86*-linux* | x86_64*-kfreebsd*-gnu | i[3-7]86*-kfreebsd*-gnu)
++    case "$EMULATION_NAME" in
++      *i386*) LIBPATH_SUFFIX=32 ;;
++    esac
++    ;;
++esac
diff -Nru a/patches/binutils/2.22/128_build_id.patch b/patches/binutils/2.22/128_build_id.patch
--- a/patches/binutils/2.22/128_build_id.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/128_build_id.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,42 @@
+Author: 
+Description: Description: Fix ld corrupt build ID generation
+Author: Nick Clifton
+Upstream status: Taken from Fedora (BZ 501582)
+--- a/bfd/compress.c
++++ b/bfd/compress.c
+@@ -174,7 +174,7 @@
+     case COMPRESS_SECTION_NONE:
+       if (p == NULL)
+ 	{
+-	  p = (bfd_byte *) bfd_malloc (sz);
++	  p = (bfd_byte *) bfd_zmalloc (sz);
+ 	  if (p == NULL)
+ 	    return FALSE;
+ 	  need_free = TRUE;
+--- a/bfd/elfcode.h
++++ b/bfd/elfcode.h
+@@ -1158,6 +1158,24 @@
+ 
+       if (i_shdr.contents)
+ 	(*process) (i_shdr.contents, i_shdr.sh_size, arg);
++      else
++	{
++	  asection *sec;
++
++	  sec = bfd_section_from_elf_index (abfd, count);
++	  if (sec != NULL)
++	    {
++	      if (sec->contents == NULL)
++		{
++		  /* Force rereading from file.  */
++		  sec->flags &= ~SEC_IN_MEMORY;
++		  if (! bfd_malloc_and_get_section (abfd, sec, & sec->contents))
++		    continue;
++		}
++	      if (sec->contents != NULL)
++		(*process) (sec->contents, i_shdr.sh_size, arg);
++	    }
++	}
+     }
+ 
+   return TRUE;
diff -Nru a/patches/binutils/2.22/128_ppc64_powerpc_biarch.patch b/patches/binutils/2.22/128_ppc64_powerpc_biarch.patch
--- a/patches/binutils/2.22/128_ppc64_powerpc_biarch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/128_ppc64_powerpc_biarch.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,15 @@
+--- a/ld/emulparams/elf32ppccommon.sh	2011-03-01 21:36:22.239025005 +0000
++++ b/ld/emulparams/elf32ppccommon.sh	2011-03-01 21:38:13.187024999 +0000
+@@ -48,3 +48,12 @@
+ case "$EMULATION_NAME" in
+   *64*) LIBPATH_SUFFIX=64 ;;
+ esac
++
++# On 64bit, look for 32 bit target libraries in /lib32, /usr/lib32 etc., first.
++case "$target" in
++  powerpc64-*-linux* | ppc64-*-linux*)
++    case "$EMULATION_NAME" in
++      *32*) LIBPATH_SUFFIX=32 ;;
++    esac
++    ;;
++esac
diff -Nru a/patches/binutils/2.22/129_ld_mulitarch_dirs.patch b/patches/binutils/2.22/129_ld_mulitarch_dirs.patch
--- a/patches/binutils/2.22/129_ld_mulitarch_dirs.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/129_ld_mulitarch_dirs.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,72 @@
+# DP: Add multiarch directories to linker search path.
+
+Index: binutils-2.21.0.20110322/ld/genscripts.sh
+===================================================================
+--- binutils-2.21.0.20110322.orig/ld/genscripts.sh	2011-03-27 18:45:12.283057003 +0000
++++ binutils-2.21.0.20110322/ld/genscripts.sh	2011-03-27 18:51:20.623057182 +0000
+@@ -240,6 +240,65 @@
+ fi
+ 
+ LIB_SEARCH_DIRS=`echo ${LIB_PATH} | sed -e 's/:/ /g' -e 's/\([^ ][^ ]*\)/SEARCH_DIR(\\"\1\\");/g'`
++if [ -n "$DEB_HOST_MULTIARCH" ]; then
++    temp_dirs=' '
++    for dir in `echo ${LIB_PATH} | sed -e 's/:/ /g'`; do
++	case "$dir" in
++	    ${tool_lib}*|*/${target_alias}/*)
++	        ;;
++	    */lib)
++		if [ -n "$DEB_HOST_MULTIARCH32" ]; then
++		    case $EMULATION_NAME in
++			elf_i386|elf32*)
++			    temp_dirs="${temp_dirs}${dir}/$DEB_HOST_MULTIARCH32 ";;
++			*)
++			    temp_dirs="${temp_dirs}${dir}/$DEB_HOST_MULTIARCH "
++		    esac
++		elif [ -n "$DEB_HOST_MULTIARCH64" ]; then
++		    case $EMULATION_NAME in
++			elf*_64|elf64*)
++			    temp_dirs="${temp_dirs}${dir}/$DEB_HOST_MULTIARCH64 ";;
++			*)
++			    temp_dirs="${temp_dirs}${dir}/$DEB_HOST_MULTIARCH "
++		    esac
++		else
++		    temp_dirs="${temp_dirs}${dir}/$DEB_HOST_MULTIARCH "
++		fi
++		;;
++	    */lib32)
++	        if [ -n "$DEB_HOST_MULTIARCH32" ]; then
++		    dir2=$(echo $dir | sed "s,32$,,")
++		    temp_dirs="${temp_dirs}${dir2}/$DEB_HOST_MULTIARCH32 "
++		fi
++		;;
++	    */lib64)
++	        case "${target}" in
++		    powerpc64-*-*|s390x-*-*|sparc64-*-*|x86_64-*-linux*)
++			#dir=$(echo $dir | sed "s,64$,,")
++			dir2=$(echo $dir | sed "s,64$,,")
++			temp_dirs="${temp_dirs}${dir2}/$DEB_HOST_MULTIARCH "
++			;;
++		    *)
++			if [ -n "$DEB_HOST_MULTIARCH64" ]; then
++			    dir2=$(echo $dir | sed "s,64$,,")
++			    temp_dirs="${temp_dirs}${dir2}/$DEB_HOST_MULTIARCH64 "
++			fi
++			;;
++		esac
++	        ;;
++	    *)
++		;;
++	esac
++	temp_dirs="${temp_dirs}${dir} "
++    done
++    LIB_SEARCH_DIRS=
++    for dir in $temp_dirs; do
++	if echo "$LIB_SEARCH_DIRS" | fgrep -q "\"$dir\""; then
++	    continue
++	fi
++	LIB_SEARCH_DIRS="${LIB_SEARCH_DIRS}SEARCH_DIR(\"$dir\"); "
++    done
++fi
+ 
+ # We need it for testsuite.
+ set $EMULATION_LIBPATH
diff -Nru a/patches/binutils/2.22/130_gold_disable_testsuite_build.patch b/patches/binutils/2.22/130_gold_disable_testsuite_build.patch
--- a/patches/binutils/2.22/130_gold_disable_testsuite_build.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/130_gold_disable_testsuite_build.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,26 @@
+Author: 
+Description: Description: Disable build of gold/testsuite
+Author: Matthias Klose
+Upstream status: local
+--- a/gold/Makefile.am
++++ b/gold/Makefile.am
+@@ -2,7 +2,7 @@
+ 
+ AUTOMAKE_OPTIONS = foreign
+ 
+-SUBDIRS = po testsuite
++SUBDIRS = po
+ 
+ tooldir = $(exec_prefix)/$(target_alias)
+ 
+--- a/gold/Makefile.in
++++ b/gold/Makefile.in
+@@ -355,7 +355,7 @@
+ top_builddir = @top_builddir@
+ top_srcdir = @top_srcdir@
+ AUTOMAKE_OPTIONS = foreign
+-SUBDIRS = po testsuite
++SUBDIRS = po
+ tooldir = $(exec_prefix)/$(target_alias)
+ ACLOCAL_AMFLAGS = -I ../bfd -I ../config
+ AM_CFLAGS = $(WARN_CFLAGS) $(LFS_CFLAGS) $(RANDOM_SEED_CFLAGS)
diff -Nru a/patches/binutils/2.22/134_gold_no_spu.patch b/patches/binutils/2.22/134_gold_no_spu.patch
--- a/patches/binutils/2.22/134_gold_no_spu.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/134_gold_no_spu.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,13 @@
+Author: 
+Description: Description: Don't configure gold for spu target.
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -21929,7 +21929,7 @@
+ 	srcdiroption="--srcdir=$${topdir}/gold"; \
+ 	libsrcdir="$$s/gold"; \
+ 	$(SHELL) $${libsrcdir}/configure \
+-	  $(HOST_CONFIGARGS) --build=${build_alias} --host=${host_alias} \
++	  $$(echo $(HOST_CONFIGARGS) |sed 's/,spu//') --build=${build_alias} --host=${host_alias} \
+ 	  --target=${target_alias} $${srcdiroption}  \
+ 	  || exit 1
+ @endif gold
diff -Nru a/patches/binutils/2.22/135_bfd_version.patch b/patches/binutils/2.22/135_bfd_version.patch
--- a/patches/binutils/2.22/135_bfd_version.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/135_bfd_version.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,47 @@
+Author: 
+Description: Description: Fix bfd version handling for extra builds
+
+Index: binutils-2.21.0.20110216/bfd/Makefile.am
+===================================================================
+--- binutils-2.21.0.20110216.orig/bfd/Makefile.am	2011-02-01 12:25:32.000000000 +0000
++++ binutils-2.21.0.20110216/bfd/Makefile.am	2011-02-16 18:28:14.568229030 +0000
+@@ -948,14 +948,14 @@
+ 
+ bfdver.h: $(srcdir)/version.h $(srcdir)/Makefile.in
+ 	@echo "creating $@"
+-	@bfd_version=`echo "$(VERSION)" | sed -e 's/\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\).*/\1.00\2.00\3.00\4.00\5/' -e 's/\([^\.]*\)\..*\(..\)\..*\(..\)\..*\(..\)\..*\(..\)$$/\1\2\3\4\5/'` ;\
+-	bfd_version_string="\"$(VERSION)\"" ;\
++	@bfd_version=`echo "$(VERSION)" | sed -e 's/-.*$$//' | sed -e 's/\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\).*/\1.00\2.00\3.00\4.00\5/' -e 's/\([^\.]*\)\..*\(..\)\..*\(..\)\..*\(..\)\..*\(..\)$$/\1\2\3\4\5/'` ;\
++	bfd_version_string="\"`echo $(VERSION) | sed -e 's/-.*$$//'`\"" ;\
+ 	bfd_soversion="$(VERSION)" ;\
+ 	bfd_version_package="\"$(PKGVERSION)\"" ;\
+ 	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
+ 	if test "x$(RELEASE)" = x ; then \
+ 	  bfd_version_date=`sed -n -e 's/.*DATE //p' < $(srcdir)/version.h` ;\
+-	  bfd_version_string="\"$(VERSION).$${bfd_version_date}\"" ;\
++	  bfd_version_string="\"`echo $(VERSION) | sed -e 's/-.*$$//'`.$${bfd_version_date}\"" ;\
+ 	  bfd_soversion="$(VERSION).$${bfd_version_date}" ;\
+ 	fi ;\
+ 	sed -e "s,@bfd_version@,$$bfd_version," \
+Index: binutils-2.21.0.20110216/bfd/Makefile.in
+===================================================================
+--- binutils-2.21.0.20110216.orig/bfd/Makefile.in	2011-02-01 12:25:32.000000000 +0000
++++ binutils-2.21.0.20110216/bfd/Makefile.in	2011-02-16 18:28:34.248228995 +0000
+@@ -1980,14 +1980,14 @@
+ 
+ bfdver.h: $(srcdir)/version.h $(srcdir)/Makefile.in
+ 	@echo "creating $@"
+-	@bfd_version=`echo "$(VERSION)" | sed -e 's/\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\).*/\1.00\2.00\3.00\4.00\5/' -e 's/\([^\.]*\)\..*\(..\)\..*\(..\)\..*\(..\)\..*\(..\)$$/\1\2\3\4\5/'` ;\
+-	bfd_version_string="\"$(VERSION)\"" ;\
++	@bfd_version=`echo "$(VERSION)" | sed -e 's/-.*$$//' | sed -e 's/\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\)\.*\([^\.]*\).*/\1.00\2.00\3.00\4.00\5/' -e 's/\([^\.]*\)\..*\(..\)\..*\(..\)\..*\(..\)\..*\(..\)$$/\1\2\3\4\5/'` ;\
++	bfd_version_string="\"`echo $(VERSION) | sed -e 's/-.*$$//'`\"" ;\
+ 	bfd_soversion="$(VERSION)" ;\
+ 	bfd_version_package="\"$(PKGVERSION)\"" ;\
+ 	report_bugs_to="\"$(REPORT_BUGS_TO)\"" ;\
+ 	if test "x$(RELEASE)" = x ; then \
+ 	  bfd_version_date=`sed -n -e 's/.*DATE //p' < $(srcdir)/version.h` ;\
+-	  bfd_version_string="\"$(VERSION).$${bfd_version_date}\"" ;\
++	  bfd_version_string="\"`echo $(VERSION) | sed -e 's/-.*$$//'`.$${bfd_version_date}\"" ;\
+ 	  bfd_soversion="$(VERSION).$${bfd_version_date}" ;\
+ 	fi ;\
+ 	sed -e "s,@bfd_version@,$$bfd_version," \
diff -Nru a/patches/binutils/2.22/157_ar_scripts_with_tilde.patch b/patches/binutils/2.22/157_ar_scripts_with_tilde.patch
--- a/patches/binutils/2.22/157_ar_scripts_with_tilde.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/157_ar_scripts_with_tilde.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,11 @@
+--- a/binutils/arlex.l
++++ b/binutils/arlex.l
+@@ -77,7 +77,7 @@
+ "("             { return '('; }
+ ")"             { return ')'; }
+ ","             { return ','; }
+-[A-Za-z0-9/\\$:.\-\_]+  { 	
++[A-Za-z0-9/\\$:.\-\_~]+  { 	
+ 		yylval.name =  xstrdup (yytext);
+ 		return FILENAME;
+ 		}
diff -Nru a/patches/binutils/2.22/158_ld_system_root.patch b/patches/binutils/2.22/158_ld_system_root.patch
--- a/patches/binutils/2.22/158_ld_system_root.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/158_ld_system_root.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,36 @@
+--- a/ld/configure.in
++++ b/ld/configure.in
+@@ -38,7 +38,9 @@
+  *) TARGET_SYSTEM_ROOT=$with_sysroot ;;
+  esac
+ 
++ if test "x$TARGET_SYSTEM_ROOT" != x/; then
+  TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"$(TARGET_SYSTEM_ROOT)\"'
++ fi
+  use_sysroot=yes
+ 
+  if test "x$prefix" = xNONE; then
+--- a/ld/configure
++++ b/ld/configure
+@@ -4139,7 +4139,9 @@
+  *) TARGET_SYSTEM_ROOT=$with_sysroot ;;
+  esac
+ 
++ if test "x$TARGET_SYSTEM_ROOT" != x/; then
+  TARGET_SYSTEM_ROOT_DEFINE='-DTARGET_SYSTEM_ROOT=\"$(TARGET_SYSTEM_ROOT)\"'
++ fi
+  use_sysroot=yes
+ 
+  if test "x$prefix" = xNONE; then
+--- a/ld/ldmain.c
++++ b/ld/ldmain.c
+@@ -214,8 +214,8 @@
+     {
+       if (*TARGET_SYSTEM_ROOT == 0)
+ 	{
+-	  einfo ("%P%F: this linker was not configured to use sysroots\n");
+ 	  ld_sysroot = "";
++	  ld_canon_sysroot = "";
+ 	}
+       else
+ 	ld_canon_sysroot = lrealpath (ld_sysroot);
diff -Nru a/patches/binutils/2.22/161_gold_dummy_zoption.patch b/patches/binutils/2.22/161_gold_dummy_zoption.patch
--- a/patches/binutils/2.22/161_gold_dummy_zoption.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/161_gold_dummy_zoption.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,25 @@
+# DP: let gold accept a dummy -z buildd-<random-string> option.
+
+--- a/gold/options.h
++++ b/gold/options.h
+@@ -1162,6 +1162,9 @@
+   DEFINE_bool_alias(textoff, text, options::DASH_Z, '\0',
+ 		    N_("Permit relocations in read-only segments (default)"),
+ 		    NULL, true);
++  DEFINE_bool(buildd, options::DASH_Z, '\0', false,
++	      N_("Dummy z option"),
++	      NULL);
+ 
+  public:
+   typedef options::Dir_list Dir_list;
+--- a/gold/options.cc
++++ b/gold/options.cc
+@@ -859,6 +859,8 @@
+     {
+       int dummy_i = 0;
+       const char* dash_z_arg = *arg;
++      if (strncmp(dash_z_arg, "buildd", strlen("buildd")) == 0)
++	  *arg = "buildd";
+       retval = parse_long_option(1, arg, true, arg, &dummy_i);
+       if (retval == NULL)
+         usage(_("unknown -z option"), dash_z_arg);
diff -Nru a/patches/binutils/2.22/162_fpic_s390x.patch b/patches/binutils/2.22/162_fpic_s390x.patch
--- a/patches/binutils/2.22/162_fpic_s390x.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/162_fpic_s390x.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,31 @@
+# DP: Fix s390x build.
+
+2011-08-24  Aurelien Jarno  <aurelien@aurel32.net>
+
+	* config/picflag.m4: use -FPIC on s390x.
+	* libiberty/configure: regenerate.
+
+--- binutils-2.21.53.20110823.orig/config/picflag.m4
++++ binutils-2.21.53.20110823/config/picflag.m4
+@@ -51,6 +51,9 @@
+     m68k-*-*)
+ 	$1=-fpic
+ 	;;
++    s390x*-*-*)
++	$1=-fPIC
++	;;
+     s390*-*-*)
+ 	$1=-fpic
+ 	;;
+--- binutils-2.21.53.20110823.orig/libiberty/configure
++++ binutils-2.21.53.20110823/libiberty/configure
+@@ -4891,6 +4891,9 @@
+     m68k-*-*)
+ 	PICFLAG=-fpic
+ 	;;
++    s390x*-*-*)
++	PICFLAG=-fPIC
++	;;
+     s390*-*-*)
+ 	PICFLAG=-fpic
+ 	;;
diff -Nru a/patches/binutils/2.22/163_multiarch_search_path.patch b/patches/binutils/2.22/163_multiarch_search_path.patch
--- a/patches/binutils/2.22/163_multiarch_search_path.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/163_multiarch_search_path.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,79 @@
+# DP: multiarch search paths
+
+--- binutils-2.21.53.20110810.orig/gold/Makefile.am
++++ binutils-2.21.53.20110810/gold/Makefile.am
+@@ -15,7 +15,7 @@
+ 	-I$(srcdir) -I$(srcdir)/../include -I$(srcdir)/../elfcpp \
+ 	-DLOCALEDIR="\"$(datadir)/locale\"" \
+ 	-DBINDIR="\"$(bindir)\"" -DTOOLBINDIR="\"$(tooldir)/bin\"" \
+-	@INCINTL@
++	@INCINTL@ @MULTIARCH_DIRNAME@
+ 
+ LIBIBERTY = ../libiberty/libiberty.a
+ 
+--- binutils-2.21.53.20110810.orig/gold/configure
++++ binutils-2.21.53.20110810/gold/configure
+@@ -594,6 +594,7 @@
+ MAINT
+ MAINTAINER_MODE_FALSE
+ MAINTAINER_MODE_TRUE
++MULTIARCH_DIRNAME
+ CXXCPP
+ HAVE_ZLIB_FALSE
+ HAVE_ZLIB_TRUE
+@@ -7133,6 +7134,14 @@
+ ac_compiler_gnu=$ac_cv_c_compiler_gnu
+ 
+ 
++if test x$target = x$host; then
++  multiarch=`$CC -print-multiarch 2>/dev/null`
++  if test -n "$multiarch"; then
++    MULTIARCH_DIRNAME='-DMULTIARCH_DIRNAME=\"'$multiarch'\"'
++  fi
++fi
++
++
+ 
+ { $as_echo "$as_me:${as_lineno-$LINENO}: checking whether to enable maintainer-specific portions of Makefiles" >&5
+ $as_echo_n "checking whether to enable maintainer-specific portions of Makefiles... " >&6; }
+--- binutils-2.21.53.20110810.orig/gold/configure.ac
++++ binutils-2.21.53.20110810/gold/configure.ac
+@@ -475,6 +475,14 @@
+ 
+ AC_LANG_POP(C++)
+ 
++if test x$target = x$host; then
++  multiarch=`$CC -print-multiarch 2>/dev/null`
++  if test -n "$multiarch"; then
++    MULTIARCH_DIRNAME='-DMULTIARCH_DIRNAME=\"'$multiarch'\"'
++  fi
++fi
++AC_SUBST(MULTIARCH_DIRNAME)
++
+ AM_MAINTAINER_MODE
+ 
+ AC_OUTPUT(Makefile testsuite/Makefile po/Makefile.in:po/Make-in)
+--- binutils-2.21.53.20110810.orig/gold/options.cc
++++ binutils-2.21.53.20110810/gold/options.cc
+@@ -1145,6 +1147,10 @@
+     {
+       // Even if they don't specify it, we add -L /lib and -L /usr/lib.
+       // FIXME: We should only do this when configured in native mode.
++#ifdef MULTIARCH_DIRNAME
++      this->add_to_library_path_with_sysroot("/lib/" MULTIARCH_DIRNAME);
++      this->add_to_library_path_with_sysroot("/usr/lib/" MULTIARCH_DIRNAME);
++#endif
+       this->add_to_library_path_with_sysroot("/lib");
+       this->add_to_library_path_with_sysroot("/usr/lib");
+     }
+--- binutils-2.21.53.20110810.orig/gold/Makefile.in
++++ binutils-2.21.53.20110810/gold/Makefile.in
+@@ -364,7 +364,7 @@
+ 	-I$(srcdir) -I$(srcdir)/../include -I$(srcdir)/../elfcpp \
+ 	-DLOCALEDIR="\"$(datadir)/locale\"" \
+ 	-DBINDIR="\"$(bindir)\"" -DTOOLBINDIR="\"$(tooldir)/bin\"" \
+-	@INCINTL@
++	@INCINTL@ @MULTIARCH_DIRNAME@
+ 
+ LIBIBERTY = ../libiberty/libiberty.a
+ @PLUGINS_TRUE@LIBDL = -ldl
diff -Nru a/patches/binutils/2.22/167_pr13302.patch b/patches/binutils/2.22/167_pr13302.patch
--- a/patches/binutils/2.22/167_pr13302.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/167_pr13302.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,532 @@
+# DP: Fix PR ld/13302, taken from the trunk
+
+bfd/
+
+2012-03-06  Jakub Jelinek  <jakub@redhat.com>
+
+        * elf64-x86-64.c (elf_x86_64_relocate_section): For R_X86_64_RELATIVE
+        set relocate to TRUE.
+
+2011-10-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/13302
+	* elf32-i386.c (elf_i386_relocate_section): Replace
+	R_386_IRELATIVE with R_386_RELATIVE.
+
+	* elf64-x86-64.c (elf_x86_64_relocate_section): Replace
+	R_X86_64_IRELATIVE with R_X86_64_RELATIVE.
+
+2011-10-21  H.J. Lu  <hongjiu.lu@intel.com>.
+
+	* elf32-i386.c (elf_i386_relocate_section): Fix a typo in
+	comments.
+	* elf64-x86-64.c (elf_x86_64_relocate_section): Likewise.
+
+2011-10-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/13302
+	* elf32-i386.c (elf_i386_link_hash_table): Add next_jump_slot_index
+	and next_irelative_index.
+	(elf_i386_link_hash_table_create): Initialize next_jump_slot_index
+	and next_irelative_index.
+	(elf_i386_allocate_dynrelocs): Increment reloc_count instead of
+	next_tls_desc_index.
+	(elf_i386_size_dynamic_sections): Set next_tls_desc_index and
+	next_irelative_index from reloc_count.
+	(elf_i386_finish_dynamic_symbol): Put R_386_IRELATIVE after
+	R_386_JUMP_SLOT.
+
+	* elf64-x86-64.c (elf_x86_64_link_hash_table): Add
+	next_jump_slot_index and next_irelative_index.
+	(elf_x86_64_link_hash_table_create): Initialize
+	next_jump_slot_index and next_irelative_index.
+	(elf_x86_64_size_dynamic_sections): Set next_irelative_index
+	from reloc_count.
+	(elf_x86_64_finish_dynamic_symbol): Put R_X86_64_IRELATIVE after
+	R_X86_64_JUMP_SLOT.
+
+ld/testsuite
+
+2011-10-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/13302
+	* ld-i386/i386.exp: Run pr13302.
+
+	* ld-i386/pr13302.d: New.
+	* ld-i386/pr13302.s: Likewise.
+
+	* ld-x86-64/pr13082-5b.d: Updated.
+	* ld-x86-64/pr13082-6a.d: Likewise.
+	* ld-x86-64/pr13082-6b.d: Likewise.
+
+2011-10-21  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR ld/13302
+	* ld-ifunc/ifunc-16-i386.d: New.
+	* ld-ifunc/ifunc-16-x86-64.d: Likewise.
+	* ld-ifunc/ifunc-16-x86.s: Likewise.
+
+diff --git a/bfd/elf32-i386.c b/bfd/elf32-i386.c
+index 7ef1fc1..d187305 100644
+--- a/bfd/elf32-i386.c
++++ b/bfd/elf32-i386.c
+@@ -806,6 +806,12 @@ struct elf_i386_link_hash_table
+ 
+   /* The index of the next unused R_386_TLS_DESC slot in .rel.plt.  */
+   bfd_vma next_tls_desc_index;
++
++  /* The index of the next unused R_386_JUMP_SLOT slot in .rel.plt.  */
++  bfd_vma next_jump_slot_index;
++
++  /* The index of the next unused R_386_IRELATIVE slot in .rel.plt.  */
++  bfd_vma next_irelative_index;
+ };
+ 
+ /* Get the i386 ELF linker hash table from a link_info structure.  */
+@@ -946,6 +952,8 @@ elf_i386_link_hash_table_create (bfd *abfd)
+   ret->sym_cache.abfd = NULL;
+   ret->srelplt2 = NULL;
+   ret->tls_module_base = NULL;
++  ret->next_jump_slot_index = 0;
++  ret->next_irelative_index = 0;
+ 
+   ret->loc_hash_table = htab_try_create (1024,
+ 					 elf_i386_local_htab_hash,
+@@ -2275,7 +2283,7 @@ elf_i386_allocate_dynrelocs (struct elf_link_hash_entry *h, void *inf)
+ 
+ 	  /* We also need to make an entry in the .rel.plt section.  */
+ 	  htab->elf.srelplt->size += sizeof (Elf32_External_Rel);
+-	  htab->next_tls_desc_index++;
++	  htab->elf.srelplt->reloc_count++;
+ 
+ 	  if (get_elf_i386_backend_data (info->output_bfd)->is_vxworks
+               && !info->shared)
+@@ -2700,9 +2708,19 @@ elf_i386_size_dynamic_sections (bfd *output_bfd, struct bfd_link_info *info)
+      incremented.  However, when we reserve space for TLS descriptors,
+      it's not incremented, so in order to compute the space reserved
+      for them, it suffices to multiply the reloc count by the jump
+-     slot size.  */
++     slot size.
++     
++     PR ld/13302: We start next_irelative_index at the end of .rela.plt
++     so that R_386_IRELATIVE entries come last.  */
+   if (htab->elf.srelplt)
+-    htab->sgotplt_jump_table_size = htab->next_tls_desc_index * 4;
++    {
++      htab->next_tls_desc_index = htab->elf.srelplt->reloc_count;
++      htab->sgotplt_jump_table_size = htab->next_tls_desc_index * 4;
++      htab->next_irelative_index = htab->elf.srelplt->reloc_count - 1;
++    }
++  else if (htab->elf.irelplt)
++    htab->next_irelative_index = htab->elf.irelplt->reloc_count - 1;
++
+ 
+   if (htab->elf.sgotplt)
+     {
+@@ -3232,13 +3250,14 @@ elf_i386_relocate_section (bfd *output_bfd,
+ 
+ 	    case R_386_32:
+ 	      /* Generate dynamic relcoation only when there is a
+-		 non-GOF reference in a shared object.  */
++		 non-GOT reference in a shared object.  */
+ 	      if (info->shared && h->non_got_ref)
+ 		{
+ 		  Elf_Internal_Rela outrel;
+ 		  bfd_byte *loc;
+ 		  asection *sreloc;
+ 		  bfd_vma offset;
++		  bfd_boolean relocate;
+ 
+ 		  /* Need a dynamic relocation to get the real function
+ 		     adddress.  */
+@@ -3259,15 +3278,14 @@ elf_i386_relocate_section (bfd *output_bfd,
+ 		      || info->executable)
+ 		    {
+ 		      /* This symbol is resolved locally.  */
+-		      outrel.r_info = ELF32_R_INFO (0, R_386_IRELATIVE);
+-		      bfd_put_32 (output_bfd,
+-				  (h->root.u.def.value
+-				   + h->root.u.def.section->output_section->vma
+-				   + h->root.u.def.section->output_offset),
+-				  contents + offset);
++		      outrel.r_info = ELF32_R_INFO (0, R_386_RELATIVE);
++		      relocate = TRUE;
+ 		    }
+ 		  else
+-		    outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
++		    {
++		      outrel.r_info = ELF32_R_INFO (h->dynindx, r_type);
++		      relocate = FALSE;
++		    }
+ 
+ 		  sreloc = htab->elf.irelifunc;
+ 		  loc = sreloc->contents;
+@@ -3280,7 +3298,8 @@ elf_i386_relocate_section (bfd *output_bfd,
+ 		     we need to include the symbol value so that it
+ 		     becomes an addend for the dynamic reloc.  For an
+ 		     internal symbol, we have updated addend.  */
+-		  continue;
++		  if (! relocate)
++		    continue;
+ 		}
+ 	      /* FALLTHROUGH */
+ 	    case R_386_PC32:
+@@ -4364,13 +4383,13 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
+ 
+       if (plt == htab->elf.splt)
+ 	{
+-	  plt_index = h->plt.offset / plt_entry_size - 1;
+-	  got_offset = (plt_index + 3) * 4;
++	  got_offset = h->plt.offset / plt_entry_size - 1;
++	  got_offset = (got_offset + 3) * 4;
+ 	}
+       else
+ 	{
+-	  plt_index = h->plt.offset / plt_entry_size;
+-	  got_offset = plt_index * 4;
++	  got_offset = h->plt.offset / plt_entry_size;
++	  got_offset = got_offset * 4;
+ 	}
+ 
+       /* Fill in the entry in the procedure linkage table.  */
+@@ -4431,18 +4450,6 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
+                       + abed->plt->plt_got_offset);
+ 	}
+ 
+-      /* Don't fill PLT entry for static executables.  */
+-      if (plt == htab->elf.splt)
+-	{
+-	  bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rel),
+-		      plt->contents + h->plt.offset
+-                      + abed->plt->plt_reloc_offset);
+-	  bfd_put_32 (output_bfd, - (h->plt.offset
+-                                     + abed->plt->plt_plt_offset + 4),
+-		      plt->contents + h->plt.offset
+-                      + abed->plt->plt_plt_offset);
+-	}
+-
+       /* Fill in the entry in the global offset table.  */
+       bfd_put_32 (output_bfd,
+ 		  (plt->output_section->vma
+@@ -4470,12 +4477,29 @@ elf_i386_finish_dynamic_symbol (bfd *output_bfd,
+ 		       + h->root.u.def.section->output_offset),
+ 		      gotplt->contents + got_offset);
+ 	  rel.r_info = ELF32_R_INFO (0, R_386_IRELATIVE);
++	  /* R_386_IRELATIVE comes last.  */
++	  plt_index = htab->next_irelative_index--;
+ 	}
+       else
+-	rel.r_info = ELF32_R_INFO (h->dynindx, R_386_JUMP_SLOT);
++	{
++	  rel.r_info = ELF32_R_INFO (h->dynindx, R_386_JUMP_SLOT);
++	  plt_index = htab->next_jump_slot_index++;
++	}
+       loc = relplt->contents + plt_index * sizeof (Elf32_External_Rel);
+       bfd_elf32_swap_reloc_out (output_bfd, &rel, loc);
+ 
++      /* Don't fill PLT entry for static executables.  */
++      if (plt == htab->elf.splt)
++	{
++	  bfd_put_32 (output_bfd, plt_index * sizeof (Elf32_External_Rel),
++		      plt->contents + h->plt.offset
++                      + abed->plt->plt_reloc_offset);
++	  bfd_put_32 (output_bfd, - (h->plt.offset
++                                     + abed->plt->plt_plt_offset + 4),
++		      plt->contents + h->plt.offset
++                      + abed->plt->plt_plt_offset);
++	}
++
+       if (!h->def_regular)
+ 	{
+ 	  /* Mark the symbol as undefined, rather than as defined in
+diff --git a/bfd/elf64-x86-64.c b/bfd/elf64-x86-64.c
+index e4c3946..2206dd4 100644
+--- a/bfd/elf64-x86-64.c
++++ b/bfd/elf64-x86-64.c
+@@ -698,6 +698,11 @@ struct elf_x86_64_link_hash_table
+   /* The offset into sgot of the GOT entry used by the PLT entry
+      above.  */
+   bfd_vma tlsdesc_got;
++
++  /* The index of the next R_X86_64_JUMP_SLOT entry in .rela.plt.  */
++  bfd_vma next_jump_slot_index;
++  /* The index of the next R_X86_64_IRELATIVE entry in .rela.plt.  */
++  bfd_vma next_irelative_index;
+ };
+ 
+ /* Get the x86-64 ELF linker hash table from a link_info structure.  */
+@@ -839,6 +844,8 @@ elf_x86_64_link_hash_table_create (bfd *abfd)
+   ret->tls_ld_got.refcount = 0;
+   ret->sgotplt_jump_table_size = 0;
+   ret->tls_module_base = NULL;
++  ret->next_jump_slot_index = 0; 
++  ret->next_irelative_index = 0;
+ 
+   if (ABI_64_P (abfd))
+     {
+@@ -2667,10 +2674,18 @@ elf_x86_64_size_dynamic_sections (bfd *output_bfd,
+      incremented.  However, when we reserve space for TLS descriptors,
+      it's not incremented, so in order to compute the space reserved
+      for them, it suffices to multiply the reloc count by the jump
+-     slot size.  */
++     slot size.
++
++     PR ld/13302: We start next_irelative_index at the end of .rela.plt
++     so that R_X86_64_IRELATIVE entries come last.  */
+   if (htab->elf.srelplt)
+-    htab->sgotplt_jump_table_size
+-      = elf_x86_64_compute_jump_table_size (htab);
++    {
++      htab->sgotplt_jump_table_size
++	= elf_x86_64_compute_jump_table_size (htab);
++      htab->next_irelative_index = htab->elf.srelplt->reloc_count - 1;
++    }
++  else if (htab->elf.irelplt)
++    htab->next_irelative_index = htab->elf.irelplt->reloc_count - 1;
+ 
+   if (htab->tlsdesc_plt)
+     {
+@@ -3141,11 +3156,12 @@ elf_x86_64_relocate_section (bfd *output_bfd,
+ 		}
+ 
+ 	      /* Generate dynamic relcoation only when there is a
+-		 non-GOF reference in a shared object.  */
++		 non-GOT reference in a shared object.  */
+ 	      if (info->shared && h->non_got_ref)
+ 		{
+ 		  Elf_Internal_Rela outrel;
+ 		  asection *sreloc;
++		  bfd_boolean relocate;
+ 
+ 		  /* Need a dynamic relocation to get the real function
+ 		     address.  */
+@@ -3165,15 +3181,15 @@ elf_x86_64_relocate_section (bfd *output_bfd,
+ 		      || info->executable)
+ 		    {
+ 		      /* This symbol is resolved locally.  */
+-		      outrel.r_info = htab->r_info (0, R_X86_64_IRELATIVE);
+-		      outrel.r_addend = (h->root.u.def.value
+-					 + h->root.u.def.section->output_section->vma
+-					 + h->root.u.def.section->output_offset);
++		      outrel.r_info = htab->r_info (0, R_X86_64_RELATIVE);
++		      outrel.r_addend = relocation;
++		      relocate = TRUE;
+ 		    }
+ 		  else
+ 		    {
+ 		      outrel.r_info = htab->r_info (h->dynindx, r_type);
+ 		      outrel.r_addend = 0;
++		      relocate = FALSE;
+ 		    }
+ 
+ 		  sreloc = htab->elf.irelifunc;
+@@ -3184,7 +3200,8 @@ elf_x86_64_relocate_section (bfd *output_bfd,
+ 		     we need to include the symbol value so that it
+ 		     becomes an addend for the dynamic reloc.  For an
+ 		     internal symbol, we have updated addend.  */
+-		  continue;
++		  if (! relocate)
++		    continue;
+ 		}
+ 	      /* FALLTHROUGH */
+ 	    case R_X86_64_PC32:
+@@ -4205,13 +4222,13 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
+ 
+       if (plt == htab->elf.splt)
+ 	{
+-	  plt_index = h->plt.offset / PLT_ENTRY_SIZE - 1;
+-	  got_offset = (plt_index + 3) * GOT_ENTRY_SIZE;
++	  got_offset = h->plt.offset / PLT_ENTRY_SIZE - 1;
++	  got_offset = (got_offset + 3) * GOT_ENTRY_SIZE;
+ 	}
+       else
+ 	{
+-	  plt_index = h->plt.offset / PLT_ENTRY_SIZE;
+-	  got_offset = plt_index * GOT_ENTRY_SIZE;
++	  got_offset = h->plt.offset / PLT_ENTRY_SIZE;
++	  got_offset = got_offset * GOT_ENTRY_SIZE;
+ 	}
+ 
+       /* Fill in the entry in the procedure linkage table.  */
+@@ -4233,17 +4250,6 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
+ 		       - 6),
+ 		  plt->contents + h->plt.offset + 2);
+ 
+-      /* Don't fill PLT entry for static executables.  */
+-      if (plt == htab->elf.splt)
+-	{
+-	  /* Put relocation index.  */
+-	  bfd_put_32 (output_bfd, plt_index,
+-		      plt->contents + h->plt.offset + 7);
+-	  /* Put offset for jmp .PLT0.  */
+-	  bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
+-		      plt->contents + h->plt.offset + 12);
+-	}
+-
+       /* Fill in the entry in the global offset table, initially this
+ 	 points to the pushq instruction in the PLT which is at offset 6.  */
+       bfd_put_64 (output_bfd, (plt->output_section->vma
+@@ -4267,11 +4273,25 @@ elf_x86_64_finish_dynamic_symbol (bfd *output_bfd,
+ 	  rela.r_addend = (h->root.u.def.value
+ 			   + h->root.u.def.section->output_section->vma
+ 			   + h->root.u.def.section->output_offset);
++	  /* R_X86_64_IRELATIVE comes last.  */
++	  plt_index = htab->next_irelative_index--;
+ 	}
+       else
+ 	{
+ 	  rela.r_info = htab->r_info (h->dynindx, R_X86_64_JUMP_SLOT);
+ 	  rela.r_addend = 0;
++	  plt_index = htab->next_jump_slot_index++;
++	}
++
++      /* Don't fill PLT entry for static executables.  */
++      if (plt == htab->elf.splt)
++	{
++	  /* Put relocation index.  */
++	  bfd_put_32 (output_bfd, plt_index,
++		      plt->contents + h->plt.offset + 7);
++	  /* Put offset for jmp .PLT0.  */
++	  bfd_put_32 (output_bfd, - (h->plt.offset + PLT_ENTRY_SIZE),
++		      plt->contents + h->plt.offset + 12);
+ 	}
+ 
+       bed = get_elf_backend_data (output_bfd);
+diff --git a/ld/testsuite/ld-i386/i386.exp b/ld/testsuite/ld-i386/i386.exp
+index 68b71fb..1727922 100644
+--- a/ld/testsuite/ld-i386/i386.exp
++++ b/ld/testsuite/ld-i386/i386.exp
+@@ -210,3 +210,4 @@ if { !([istarget "i?86-*-linux*"]
+ 
+ run_dump_test "compressed1"
+ run_dump_test "pr12627"
++run_dump_test "pr13302"
+diff --git a/ld/testsuite/ld-i386/pr13302.d b/ld/testsuite/ld-i386/pr13302.d
+new file mode 100644
+index 0000000..3d85d08
+--- /dev/null
++++ b/ld/testsuite/ld-i386/pr13302.d
+@@ -0,0 +1,12 @@
++#name: PR ld/13302
++#as: --32
++#ld: -pie -melf_i386
++#readelf: -r --wide
++
++Relocation section '.rel.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
++ Offset     Info    Type                Sym. Value  Symbol's Name
++[0-9a-f]+ +[0-9a-f]+ +R_386_RELATIVE +
++
++Relocation section '.rel.plt' at offset 0x[0-9a-f]+ contains 1 entries:
++ Offset     Info    Type                Sym. Value  Symbol's Name
++[0-9a-f]+ +[0-9a-f]+ +R_386_IRELATIVE +
+diff --git a/ld/testsuite/ld-i386/pr13302.s b/ld/testsuite/ld-i386/pr13302.s
+new file mode 100644
+index 0000000..cfd2717
+--- /dev/null
++++ b/ld/testsuite/ld-i386/pr13302.s
+@@ -0,0 +1,11 @@
++	.text
++	.globl _start
++	.type ifunc, @gnu_indirect_function
++_start:
++	lea	.Ljmp@GOTOFF(%ebx), %eax
++ifunc:
++	jmp	*(%eax)
++	.section	.data.rel.ro.local,"aw",@progbits
++	.align	4
++.Ljmp:
++	.long ifunc
+diff --git a/ld/testsuite/ld-ifunc/ifunc-16-i386.d b/ld/testsuite/ld-ifunc/ifunc-16-i386.d
+new file mode 100644
+index 0000000..8ae3d0a
+--- /dev/null
++++ b/ld/testsuite/ld-ifunc/ifunc-16-i386.d
+@@ -0,0 +1,10 @@
++#source: ifunc-16-x86.s
++#ld: -shared -m elf_i386
++#as: --32
++#readelf: -r --wide
++#target: x86_64-*-* i?86-*-*
++
++Relocation section '.rel.plt' at .*
++[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
++[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_JUMP_SLOT[ ]+0+[ ]+ifunc
++[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_386_IRELATIVE[ ]*
+diff --git a/ld/testsuite/ld-ifunc/ifunc-16-x86-64.d b/ld/testsuite/ld-ifunc/ifunc-16-x86-64.d
+new file mode 100644
+index 0000000..d69626d
+--- /dev/null
++++ b/ld/testsuite/ld-ifunc/ifunc-16-x86-64.d
+@@ -0,0 +1,10 @@
++#source: ifunc-16-x86.s
++#as: --64
++#ld: -shared -melf_x86_64
++#readelf: -r --wide
++#target: x86_64-*-*
++
++Relocation section '.rela.plt' at .*
++[ ]+Offset[ ]+Info[ ]+Type[ ]+.*
++[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_JUMP_SLOT[ ]+0+[ ]+ifunc \+ 0
++[0-9a-f]+[ ]+[0-9a-f]+[ ]+R_X86_64_IRELATIVE[ ]+[0-9a-f]*
+diff --git a/ld/testsuite/ld-ifunc/ifunc-16-x86.s b/ld/testsuite/ld-ifunc/ifunc-16-x86.s
+new file mode 100644
+index 0000000..fb38253
+--- /dev/null
++++ b/ld/testsuite/ld-ifunc/ifunc-16-x86.s
+@@ -0,0 +1,17 @@
++	.text
++	.globl	fct
++	.type	fct, @gnu_indirect_function
++	.set	fct,resolve
++	.hidden int_fct
++	.globl	int_fct
++	.set	int_fct,fct
++	.p2align 4,,15
++	.type	resolve, @function
++resolve:
++	call	ifunc@PLT
++	.size	resolve, .-resolve
++	.globl	g
++	.type	g, @function
++g:
++	jmp	int_fct@PLT
++	.size	g, .-g
+diff --git a/ld/testsuite/ld-x86-64/pr13082-5b.d b/ld/testsuite/ld-x86-64/pr13082-5b.d
+index 1c5a5e7..48e37c3 100644
+--- a/ld/testsuite/ld-x86-64/pr13082-5b.d
++++ b/ld/testsuite/ld-x86-64/pr13082-5b.d
+@@ -6,7 +6,7 @@
+ 
+ Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
+-[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
++[0-9a-f]+ +[0-9a-f]+ +R_X86_64_RELATIVE +[0-9a-f]+
+ 
+ Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
+diff --git a/ld/testsuite/ld-x86-64/pr13082-6a.d b/ld/testsuite/ld-x86-64/pr13082-6a.d
+index 9a1a655..de90bb8 100644
+--- a/ld/testsuite/ld-x86-64/pr13082-6a.d
++++ b/ld/testsuite/ld-x86-64/pr13082-6a.d
+@@ -6,7 +6,7 @@
+ 
+ Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
+-[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
++[0-9a-f]+ +[0-9a-f]+ +R_X86_64_RELATIVE +[0-9a-f]+
+ 
+ Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
+diff --git a/ld/testsuite/ld-x86-64/pr13082-6b.d b/ld/testsuite/ld-x86-64/pr13082-6b.d
+index 792c348..66ff59b 100644
+--- a/ld/testsuite/ld-x86-64/pr13082-6b.d
++++ b/ld/testsuite/ld-x86-64/pr13082-6b.d
+@@ -6,7 +6,7 @@
+ 
+ Relocation section '.rela.dyn' at offset 0x[0-9a-f]+ contains 1 entries:
+  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
+-[0-9a-f]+ +[0-9a-f]+ +R_X86_64_IRELATIVE +[0-9a-f]+
++[0-9a-f]+ +[0-9a-f]+ +R_X86_64_RELATIVE +[0-9a-f]+
+ 
+ Relocation section '.rela.plt' at offset 0x[0-9a-f]+ contains 1 entries:
+  Offset     Info    Type                Sym. Value  Symbol's Name \+ Addend
diff -Nru a/patches/binutils/2.22/168_readelf_go.patch b/patches/binutils/2.22/168_readelf_go.patch
--- a/patches/binutils/2.22/168_readelf_go.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/168_readelf_go.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,13 @@
+# DP: Recognize DW_LANG_Go in readelf (backport from trunk)
+
+--- a/binutils/dwarf.c
++++ b/binutils/dwarf.c
+@@ -1599,6 +1599,8 @@ read_and_display_attr_value (unsigned lo
+ 	case DW_LANG_D:			printf ("(D)"); break;
+ 	  /* DWARF 4 values.  */
+ 	case DW_LANG_Python:		printf ("(Python)"); break;
++	  /* DWARF 5 values.  */
++	case DW_LANG_Go:		printf ("(Go)"); break;
+ 	  /* MIPS extension.  */
+ 	case DW_LANG_Mips_Assembler:	printf ("(MIPS assembler)"); break;
+ 	  /* UPC extension.  */
diff -Nru a/patches/binutils/2.22/300-001_ld_makefile_patch.patch b/patches/binutils/2.22/300-001_ld_makefile_patch.patch
--- a/patches/binutils/2.22/300-001_ld_makefile_patch.patch	2012-11-11 17:43:58.000000000 -0300
+++ b/patches/binutils/2.22/300-001_ld_makefile_patch.patch	1969-12-31 21:00:00.000000000 -0300
@@ -1,24 +0,0 @@
-diff -durN binutils-2.22.orig/ld/Makefile.am binutils-2.22/ld/Makefile.am
---- binutils-2.22.orig/ld/Makefile.am	2011-07-22 22:22:37.000000000 +0200
-+++ binutils-2.22/ld/Makefile.am	2011-12-14 19:50:25.760779164 +0100
-@@ -37,7 +37,7 @@
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- 
- EMUL = @EMUL@
- EMULATION_OFILES = @EMULATION_OFILES@
-diff -durN binutils-2.22.orig/ld/Makefile.in binutils-2.22/ld/Makefile.in
---- binutils-2.22.orig/ld/Makefile.in	2011-07-22 22:22:37.000000000 +0200
-+++ binutils-2.22/ld/Makefile.in	2011-12-14 19:50:25.784779163 +0100
-@@ -366,7 +366,7 @@
- # We put the scripts in the directory $(scriptdir)/ldscripts.
- # We can't put the scripts in $(datadir) because the SEARCH_DIR
- # directives need to be different for native and cross linkers.
--scriptdir = $(tooldir)/lib
-+scriptdir = $(libdir)
- BASEDIR = $(srcdir)/..
- BFDDIR = $(BASEDIR)/bfd
- INCDIR = $(BASEDIR)/include
diff -Nru a/patches/binutils/2.22/300-012_check_ldrunpath_length.patch b/patches/binutils/2.22/300-012_check_ldrunpath_length.patch
--- a/patches/binutils/2.22/300-012_check_ldrunpath_length.patch	2012-11-11 17:43:58.000000000 -0300
+++ b/patches/binutils/2.22/300-012_check_ldrunpath_length.patch	1969-12-31 21:00:00.000000000 -0300
@@ -1,21 +0,0 @@
-diff -durN binutils-2.22.orig/ld/emultempl/elf32.em binutils-2.22/ld/emultempl/elf32.em
---- binutils-2.22.orig/ld/emultempl/elf32.em	2011-11-21 10:29:39.000000000 +0100
-+++ binutils-2.22/ld/emultempl/elf32.em	2011-12-14 19:52:12.880783238 +0100
-@@ -1273,6 +1273,8 @@
- 	      && command_line.rpath == NULL)
- 	    {
- 	      lib_path = (const char *) getenv ("LD_RUN_PATH");
-+	      if ((lib_path) && (strlen (lib_path) == 0))
-+	      	lib_path = NULL;
- 	      if (gld${EMULATION_NAME}_search_needed (lib_path, &n,
- 						      force))
- 		break;
-@@ -1500,6 +1502,8 @@
-   rpath = command_line.rpath;
-   if (rpath == NULL)
-     rpath = (const char *) getenv ("LD_RUN_PATH");
-+  if ((rpath) && (strlen (rpath) == 0))
-+  	rpath = NULL;
- 
-   for (abfd = link_info.input_bfds; abfd; abfd = abfd->link_next)
-     if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
diff -Nru a/patches/binutils/2.22/999-libiberty-md5.patch b/patches/binutils/2.22/999-libiberty-md5.patch
--- a/patches/binutils/2.22/999-libiberty-md5.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/999-libiberty-md5.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,32 @@
+# DP: Fix alias warning building libiberty/md5.c
+
+--- a/include/md5.h
++++ a/include/md5.h
+@@ -86,7 +86,11 @@
+ 
+   md5_uint32 total[2];
+   md5_uint32 buflen;
+-  char buffer[128] ATTRIBUTE_ALIGNED_ALIGNOF(md5_uint32);
++  union
++  {
++    char buffer[128];
++    md5_uint32 buffer32[32];
++  };
+ };
+ 
+ /*
+--- a/libiberty/md5.c
++++ b/libiberty/md5.c
+@@ -114,9 +114,9 @@
+   memcpy (&ctx->buffer[bytes], fillbuf, pad);
+ 
+   /* Put the 64-bit file length in *bits* at the end of the buffer.  */
+-  *(md5_uint32 *) &ctx->buffer[bytes + pad] = SWAP (ctx->total[0] << 3);
+-  *(md5_uint32 *) &ctx->buffer[bytes + pad + 4] = SWAP ((ctx->total[1] << 3) |
+-							(ctx->total[0] >> 29));
++  ctx->buffer32[(bytes + pad) / 4] = SWAP (ctx->total[0] << 3);
++  ctx->buffer32[(bytes + pad + 4) / 4] = SWAP ((ctx->total[1] << 3) |
++					       (ctx->total[0] >> 29));
+ 
+   /* Process last bytes.  */
+   md5_process_block (ctx->buffer, bytes + pad + 8, ctx);
diff -Nru a/patches/binutils/2.22/999-ppc-textrels.patch b/patches/binutils/2.22/999-ppc-textrels.patch
--- a/patches/binutils/2.22/999-ppc-textrels.patch	2012-11-11 17:43:58.000000000 -0300
+++ b/patches/binutils/2.22/999-ppc-textrels.patch	1969-12-31 21:00:00.000000000 -0300
@@ -1,72 +0,0 @@
-http://bugs.gentoo.org/392645
-http://sourceware.org/bugzilla/show_bug.cgi?id=13470
-
-2011-12-03  Alan Modra  <amodra@gmail.com>
-
-	PR ld/13470
-	* elf32-ppc.c (ppc_elf_copy_indirect_symbol): Revert substantive
-	change in 2011-07-01 commit.  Comment.
-	* elf64-ppc.c (ppc64_elf_copy_indirect_symbol): Likewise.
-
-diff -durN binutils-2.22.orig/bfd/elf32-ppc.c binutils-2.22/bfd/elf32-ppc.c
---- binutils-2.22.orig/bfd/elf32-ppc.c	2011-11-21 10:29:21.000000000 +0100
-+++ binutils-2.22/bfd/elf32-ppc.c	2011-12-14 19:52:43.308784395 +0100
-@@ -2987,10 +2987,6 @@
-   edir->elf.needs_plt |= eind->elf.needs_plt;
-   edir->elf.pointer_equality_needed |= eind->elf.pointer_equality_needed;
- 
--  /* If we were called to copy over info for a weak sym, that's all.  */
--  if (eind->elf.root.type != bfd_link_hash_indirect)
--    return;
--
-   if (eind->dyn_relocs != NULL)
-     {
-       if (edir->dyn_relocs != NULL)
-@@ -3022,6 +3018,16 @@
-       eind->dyn_relocs = NULL;
-     }
- 
-+  /* If we were called to copy over info for a weak sym, that's all.
-+     You might think dyn_relocs need not be copied over;  After all,
-+     both syms will be dynamic or both non-dynamic so we're just
-+     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
-+     code in ppc_elf_adjust_dynamic_symbol needs to check for
-+     dyn_relocs in read-only sections, and it does so on what is the
-+     DIR sym here.  */
-+  if (eind->elf.root.type != bfd_link_hash_indirect)
-+    return;
-+
-   /* Copy over the GOT refcount entries that we may have already seen to
-      the symbol which just became indirect.  */
-   edir->elf.got.refcount += eind->elf.got.refcount;
-diff -durN binutils-2.22.orig/bfd/elf64-ppc.c binutils-2.22/bfd/elf64-ppc.c
---- binutils-2.22.orig/bfd/elf64-ppc.c	2011-11-21 10:29:24.000000000 +0100
-+++ binutils-2.22/bfd/elf64-ppc.c	2011-12-14 19:52:43.336784395 +0100
-@@ -4435,10 +4435,6 @@
-   edir->elf.ref_regular_nonweak |= eind->elf.ref_regular_nonweak;
-   edir->elf.needs_plt |= eind->elf.needs_plt;
- 
--  /* If we were called to copy over info for a weak sym, that's all.  */
--  if (eind->elf.root.type != bfd_link_hash_indirect)
--    return;
--
-   /* Copy over any dynamic relocs we may have on the indirect sym.  */
-   if (eind->dyn_relocs != NULL)
-     {
-@@ -4471,6 +4467,16 @@
-       eind->dyn_relocs = NULL;
-     }
- 
-+  /* If we were called to copy over info for a weak sym, that's all.
-+     You might think dyn_relocs need not be copied over;  After all,
-+     both syms will be dynamic or both non-dynamic so we're just
-+     moving reloc accounting around.  However, ELIMINATE_COPY_RELOCS 
-+     code in ppc64_elf_adjust_dynamic_symbol needs to check for
-+     dyn_relocs in read-only sections, and it does so on what is the
-+     DIR sym here.  */
-+  if (eind->elf.root.type != bfd_link_hash_indirect)
-+    return;
-+
-   /* Copy over got entries that we may have already seen to the
-      symbol which just became indirect.  */
-   if (eind->elf.got.glist != NULL)
diff -Nru a/patches/binutils/2.22/pr13449.patch b/patches/binutils/2.22/pr13449.patch
--- a/patches/binutils/2.22/pr13449.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr13449.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,20 @@
+2011-12-21  Nick Clifton  <nickc@redhat.com>
+
+	PR gas/13449
+	* config/tc-arm.c (create_unwind_entry): Zero allocated table
+	entries.
+
+ 
+diff --git a/gas/config/tc-arm.c b/gas/config/tc-arm.c
+index 865f430..02a63a6 100644
+--- a/gas/config/tc-arm.c
++++ b/gas/config/tc-arm.c
+@@ -19944,6 +19944,8 @@ create_unwind_entry (int have_data)
+ 
+   /* Allocate the table entry.	*/
+   ptr = frag_more ((size << 2) + 4);
++  /* PR 13449: Zero the table entries in case some of them are not used.  */
++  memset (ptr, 0, (size << 2) + 4);
+   where = frag_now_fix () - ((size << 2) + 4);
+ 
+   switch (unwind.personality_index)
diff -Nru a/patches/binutils/2.22/pr13534-01.patch b/patches/binutils/2.22/pr13534-01.patch
--- a/patches/binutils/2.22/pr13534-01.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr13534-01.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,118 @@
+commit 75bf1d978bc03a07ad59a3f983c806bb5899c28c
+Author: Francois Gouget <fgouget@codeweavers.com>
+Date:   Tue Dec 20 18:37:16 2011 +0100
+
+    bfd: Fix writing the size of 2+GB elements in the archive.
+
+diff --git a/bfd/archive.c b/bfd/archive.c
+index 3e333c7..5c5b3d4 100644
+--- a/bfd/archive.c
++++ b/bfd/archive.c
+@@ -179,6 +179,22 @@ _bfd_ar_spacepad (char *p, size_t n, const char *fmt, long val)
+     memcpy (p, buf, n);
+ }
+ 
++void
++_bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)
++{
++  static char buf[21];
++  size_t len;
++  snprintf (buf, sizeof (buf), "%-10" BFD_VMA_FMT "u", size);
++  len = strlen (buf);
++  if (len < n)
++    {
++      memcpy (p, buf, len);
++      memset (p + len, ' ', n - len);
++    }
++  else
++    memcpy (p, buf, n);
++}
++
+ bfd_boolean
+ _bfd_generic_mkarchive (bfd *abfd)
+ {
+@@ -1770,7 +1786,7 @@ _bfd_bsd44_write_ar_hdr (bfd *archive, bfd *abfd)
+ 
+       BFD_ASSERT (padded_len == arch_eltdata (abfd)->extra_size);
+ 
+-      _bfd_ar_spacepad (hdr->ar_size, sizeof (hdr->ar_size), "%-10ld",
++      _bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),
+                         arch_eltdata (abfd)->parsed_size + padded_len);
+ 
+       if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))
+@@ -1891,7 +1907,7 @@ bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
+                       status.st_gid);
+   _bfd_ar_spacepad (hdr->ar_mode, sizeof (hdr->ar_mode), "%-8lo",
+                     status.st_mode);
+-  _bfd_ar_spacepad (hdr->ar_size, sizeof (hdr->ar_size), "%-10ld",
++  _bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),
+                     status.st_size);
+   memcpy (hdr->ar_fmag, ARFMAG, 2);
+   ared->parsed_size = status.st_size;
+@@ -2132,7 +2148,7 @@ _bfd_write_archive_contents (bfd *arch)
+       memset (&hdr, ' ', sizeof (struct ar_hdr));
+       memcpy (hdr.ar_name, ename, strlen (ename));
+       /* Round size up to even number in archive header.  */
+-      _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld",
++      _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),
+                         (elength + 1) & ~(bfd_size_type) 1);
+       memcpy (hdr.ar_fmag, ARFMAG, 2);
+       if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
+@@ -2409,7 +2425,7 @@ bsd_write_armap (bfd *arch,
+                     bfd_ardata (arch)->armap_timestamp);
+   _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), "%ld", uid);
+   _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), "%ld", gid);
+-  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld", mapsize);
++  _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize);
+   memcpy (hdr.ar_fmag, ARFMAG, 2);
+   if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
+       != sizeof (struct ar_hdr))
+@@ -2564,8 +2580,7 @@ coff_write_armap (bfd *arch,
+ 
+   memset (&hdr, ' ', sizeof (struct ar_hdr));
+   hdr.ar_name[0] = '/';
+-  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld",
+-                    mapsize);
++  _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize);
+   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
+                     ((arch->flags & BFD_DETERMINISTIC_OUTPUT) == 0
+                      ? time (NULL) : 0));
+diff --git a/bfd/archive64.c b/bfd/archive64.c
+index bbc4c3f..a906508 100644
+--- a/bfd/archive64.c
++++ b/bfd/archive64.c
+@@ -169,7 +169,7 @@ bfd_elf64_archive_write_armap (bfd *arch,
+ 
+   memset (&hdr, ' ', sizeof (struct ar_hdr));
+   memcpy (hdr.ar_name, "/SYM64/", strlen ("/SYM64/"));
+-  _bfd_ar_spacepad (hdr.ar_size, sizeof (hdr.ar_size), "%-10ld",
++  _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),
+                     mapsize);
+   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
+                     time (NULL));
+diff --git a/bfd/libbfd-in.h b/bfd/libbfd-in.h
+index 7db09e4..57197ac 100644
+--- a/bfd/libbfd-in.h
++++ b/bfd/libbfd-in.h
+@@ -203,6 +203,8 @@ extern void *_bfd_generic_read_ar_hdr
+   (bfd *);
+ extern void _bfd_ar_spacepad
+   (char *, size_t, const char *, long);
++extern void _bfd_ar_sizepad
++  (char *, size_t, bfd_size_type);
+ 
+ extern void *_bfd_generic_read_ar_hdr_mag
+   (bfd *, const char *);
+diff --git a/bfd/libbfd.h b/bfd/libbfd.h
+index 0beddb6..121e865 100644
+--- a/bfd/libbfd.h
++++ b/bfd/libbfd.h
+@@ -208,6 +208,8 @@ extern void *_bfd_generic_read_ar_hdr
+   (bfd *);
+ extern void _bfd_ar_spacepad
+   (char *, size_t, const char *, long);
++extern void _bfd_ar_sizepad
++  (char *, size_t, bfd_size_type);
+ 
+ extern void *_bfd_generic_read_ar_hdr_mag
+   (bfd *, const char *);
diff -Nru a/patches/binutils/2.22/pr13534-02.patch b/patches/binutils/2.22/pr13534-02.patch
--- a/patches/binutils/2.22/pr13534-02.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr13534-02.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,136 @@
+commit 433cc73f9df08a1435b4d07a7bd3eed20f0c3dcd
+Author: Francois Gouget <fgouget@codeweavers.com>
+Date:   Tue Dec 20 19:39:41 2011 +0100
+
+    bfd: Refuse to create an invalid archive when an archive element is too big.
+    
+    The archive format stores element sizes as a 10 character string and thus cannot handle anything 10GB or more.
+
+diff --git a/bfd/archive.c b/bfd/archive.c
+index 5c5b3d4..05aba6c 100644
+--- a/bfd/archive.c
++++ b/bfd/archive.c
+@@ -179,13 +179,18 @@ _bfd_ar_spacepad (char *p, size_t n, const char *fmt, long val)
+     memcpy (p, buf, n);
+ }
+ 
+-void
++int
+ _bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)
+ {
+   static char buf[21];
+   size_t len;
+   snprintf (buf, sizeof (buf), "%-10" BFD_VMA_FMT "u", size);
+   len = strlen (buf);
++  if (len > n)
++    {
++      bfd_set_error(bfd_error_file_too_big);
++      return 0;
++    }
+   if (len < n)
+     {
+       memcpy (p, buf, len);
+@@ -193,6 +198,7 @@ _bfd_ar_sizepad (char *p, size_t n, bfd_size_type size)
+     }
+   else
+     memcpy (p, buf, n);
++  return 1;
+ }
+ 
+ bfd_boolean
+@@ -1786,8 +1792,9 @@ _bfd_bsd44_write_ar_hdr (bfd *archive, bfd *abfd)
+ 
+       BFD_ASSERT (padded_len == arch_eltdata (abfd)->extra_size);
+ 
+-      _bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),
+-                        arch_eltdata (abfd)->parsed_size + padded_len);
++      if (!_bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),
++                            arch_eltdata (abfd)->parsed_size + padded_len))
++        return FALSE;
+ 
+       if (bfd_bwrite (hdr, sizeof (*hdr), archive) != sizeof (*hdr))
+         return FALSE;
+@@ -1907,8 +1914,8 @@ bfd_ar_hdr_from_filesystem (bfd *abfd, const char *filename, bfd *member)
+                       status.st_gid);
+   _bfd_ar_spacepad (hdr->ar_mode, sizeof (hdr->ar_mode), "%-8lo",
+                     status.st_mode);
+-  _bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size),
+-                    status.st_size);
++  if (!_bfd_ar_sizepad (hdr->ar_size, sizeof (hdr->ar_size), status.st_size))
++    return NULL;
+   memcpy (hdr->ar_fmag, ARFMAG, 2);
+   ared->parsed_size = status.st_size;
+   ared->arch_header = (char *) hdr;
+@@ -2148,8 +2155,9 @@ _bfd_write_archive_contents (bfd *arch)
+       memset (&hdr, ' ', sizeof (struct ar_hdr));
+       memcpy (hdr.ar_name, ename, strlen (ename));
+       /* Round size up to even number in archive header.  */
+-      _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),
+-                        (elength + 1) & ~(bfd_size_type) 1);
++      if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),
++                            (elength + 1) & ~(bfd_size_type) 1))
++        return FALSE;
+       memcpy (hdr.ar_fmag, ARFMAG, 2);
+       if ((bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
+ 	   != sizeof (struct ar_hdr))
+@@ -2425,7 +2433,8 @@ bsd_write_armap (bfd *arch,
+                     bfd_ardata (arch)->armap_timestamp);
+   _bfd_ar_spacepad (hdr.ar_uid, sizeof (hdr.ar_uid), "%ld", uid);
+   _bfd_ar_spacepad (hdr.ar_gid, sizeof (hdr.ar_gid), "%ld", gid);
+-  _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize);
++  if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))
++    return FALSE;
+   memcpy (hdr.ar_fmag, ARFMAG, 2);
+   if (bfd_bwrite (&hdr, sizeof (struct ar_hdr), arch)
+       != sizeof (struct ar_hdr))
+@@ -2580,7 +2589,8 @@ coff_write_armap (bfd *arch,
+ 
+   memset (&hdr, ' ', sizeof (struct ar_hdr));
+   hdr.ar_name[0] = '/';
+-  _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize);
++  if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))
++    return FALSE;
+   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
+                     ((arch->flags & BFD_DETERMINISTIC_OUTPUT) == 0
+                      ? time (NULL) : 0));
+diff --git a/bfd/archive64.c b/bfd/archive64.c
+index a906508..bdbda0a 100644
+--- a/bfd/archive64.c
++++ b/bfd/archive64.c
+@@ -169,8 +169,8 @@ bfd_elf64_archive_write_armap (bfd *arch,
+ 
+   memset (&hdr, ' ', sizeof (struct ar_hdr));
+   memcpy (hdr.ar_name, "/SYM64/", strlen ("/SYM64/"));
+-  _bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size),
+-                    mapsize);
++  if (!_bfd_ar_sizepad (hdr.ar_size, sizeof (hdr.ar_size), mapsize))
++    return FALSE;
+   _bfd_ar_spacepad (hdr.ar_date, sizeof (hdr.ar_date), "%ld",
+                     time (NULL));
+   /* This, at least, is what Intel coff sets the values to.: */
+diff --git a/bfd/libbfd-in.h b/bfd/libbfd-in.h
+index 57197ac..a4ba4b6 100644
+--- a/bfd/libbfd-in.h
++++ b/bfd/libbfd-in.h
+@@ -203,7 +203,7 @@ extern void *_bfd_generic_read_ar_hdr
+   (bfd *);
+ extern void _bfd_ar_spacepad
+   (char *, size_t, const char *, long);
+-extern void _bfd_ar_sizepad
++extern int _bfd_ar_sizepad
+   (char *, size_t, bfd_size_type);
+ 
+ extern void *_bfd_generic_read_ar_hdr_mag
+diff --git a/bfd/libbfd.h b/bfd/libbfd.h
+index 121e865..7f142d0 100644
+--- a/bfd/libbfd.h
++++ b/bfd/libbfd.h
+@@ -208,7 +208,7 @@ extern void *_bfd_generic_read_ar_hdr
+   (bfd *);
+ extern void _bfd_ar_spacepad
+   (char *, size_t, const char *, long);
+-extern void _bfd_ar_sizepad
++extern int _bfd_ar_sizepad
+   (char *, size_t, bfd_size_type);
+ 
+ extern void *_bfd_generic_read_ar_hdr_mag
diff -Nru a/patches/binutils/2.22/pr13534-03.patch b/patches/binutils/2.22/pr13534-03.patch
--- a/patches/binutils/2.22/pr13534-03.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr13534-03.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,29 @@
+commit 23a979dc1779ac63cd799bfa2f6c2aed1f1bff66
+Author: Francois Gouget <fgouget@codeweavers.com>
+Date:   Tue Dec 20 18:41:35 2011 +0100
+
+    bfd: Fix parsing the size of archive elements larger than 2GB.
+
+diff --git a/bfd/archive.c b/bfd/archive.c
+index 05aba6c..01acf98 100644
+--- a/bfd/archive.c
++++ b/bfd/archive.c
+@@ -446,7 +446,7 @@ _bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
+ {
+   struct ar_hdr hdr;
+   char *hdrp = (char *) &hdr;
+-  size_t parsed_size;
++  bfd_size_type parsed_size;
+   struct areltdata *ared;
+   char *filename = NULL;
+   bfd_size_type namelen = 0;
+@@ -470,8 +470,7 @@ _bfd_generic_read_ar_hdr_mag (bfd *abfd, const char *mag)
+     }
+ 
+   errno = 0;
+-  parsed_size = strtol (hdr.ar_size, NULL, 10);
+-  if (errno != 0)
++  if (sscanf(hdr.ar_size, "%" BFD_VMA_FMT "u", &parsed_size) != 1)
+     {
+       bfd_set_error (bfd_error_malformed_archive);
+       return NULL;
diff -Nru a/patches/binutils/2.22/pr13534-04.patch b/patches/binutils/2.22/pr13534-04.patch
--- a/patches/binutils/2.22/pr13534-04.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr13534-04.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,82 @@
+commit 70ed6152e1e163b9ca240fe8b91aa3feb942ac84
+Author: Francois Gouget <fgouget@codeweavers.com>
+Date:   Tue Dec 20 18:45:18 2011 +0100
+
+    bfd: Always use bfd_size_type to manipulate the size of an archive element.
+    
+    Other types may not be able to deal with archive elements larger than 2GB.
+
+diff --git a/bfd/archive.c b/bfd/archive.c
+index 01acf98..c1438ef 100644
+--- a/bfd/archive.c
++++ b/bfd/archive.c
+@@ -748,7 +748,7 @@ bfd_generic_openr_next_archived_file (bfd *archive, bfd *last_file)
+     filestart = bfd_ardata (archive)->first_file_filepos;
+   else
+     {
+-      unsigned int size = arelt_size (last_file);
++      bfd_size_type size = arelt_size (last_file);
+ 
+       filestart = last_file->proxy_origin;
+       if (! bfd_is_thin_archive (archive))
+@@ -946,7 +946,7 @@ do_slurp_coff_armap (bfd *abfd)
+   struct artdata *ardata = bfd_ardata (abfd);
+   char *stringbase;
+   bfd_size_type stringsize;
+-  unsigned int parsed_size;
++  bfd_size_type parsed_size;
+   carsym *carsyms;
+   bfd_size_type nsymz;		/* Number of symbols in armap.  */
+   bfd_vma (*swap) (const void *);
+@@ -2174,7 +2174,7 @@ _bfd_write_archive_contents (bfd *arch)
+        current = current->archive_next)
+     {
+       char buffer[DEFAULT_BUFFERSIZE];
+-      unsigned int remaining = arelt_size (current);
++      bfd_size_type remaining = arelt_size (current);
+ 
+       /* Write ar header.  */
+       if (!_bfd_write_ar_hdr (arch, current))
+diff --git a/bfd/bfdio.c b/bfd/bfdio.c
+index 841c781..5bc8061 100644
+--- a/bfd/bfdio.c
++++ b/bfd/bfdio.c
+@@ -185,7 +185,7 @@ bfd_bread (void *ptr, bfd_size_type size, bfd *abfd)
+      this element.  */
+   if (abfd->arelt_data != NULL)
+     {
+-      size_t maxbytes = ((struct areltdata *) abfd->arelt_data)->parsed_size;
++      bfd_size_type maxbytes = arelt_size (abfd);
+       if (abfd->where + size > maxbytes)
+         {
+           if (abfd->where >= maxbytes)
+diff --git a/bfd/libbfd-in.h b/bfd/libbfd-in.h
+index a4ba4b6..683c1cc 100644
+--- a/bfd/libbfd-in.h
++++ b/bfd/libbfd-in.h
+@@ -90,8 +90,8 @@ struct artdata {
+ /* Goes in bfd's arelt_data slot */
+ struct areltdata {
+   char * arch_header;		/* it's actually a string */
+-  unsigned int parsed_size;	/* octets of filesize not including ar_hdr */
+-  unsigned int extra_size;	/* BSD4.4: extra bytes after the header.  */
++  bfd_size_type parsed_size;	/* octets of filesize not including ar_hdr */
++  bfd_size_type extra_size;	/* BSD4.4: extra bytes after the header.  */
+   char *filename;		/* null-terminated */
+   file_ptr origin;		/* for element of a thin archive */
+ };
+diff --git a/bfd/libbfd.h b/bfd/libbfd.h
+index 7f142d0..6d27901 100644
+--- a/bfd/libbfd.h
++++ b/bfd/libbfd.h
+@@ -95,8 +95,8 @@ struct artdata {
+ /* Goes in bfd's arelt_data slot */
+ struct areltdata {
+   char * arch_header;		/* it's actually a string */
+-  unsigned int parsed_size;	/* octets of filesize not including ar_hdr */
+-  unsigned int extra_size;	/* BSD4.4: extra bytes after the header.  */
++  bfd_size_type parsed_size;	/* octets of filesize not including ar_hdr */
++  bfd_size_type extra_size;	/* BSD4.4: extra bytes after the header.  */
+   char *filename;		/* null-terminated */
+   file_ptr origin;		/* for element of a thin archive */
+ };
diff -Nru a/patches/binutils/2.22/pr13534-05.patch b/patches/binutils/2.22/pr13534-05.patch
--- a/patches/binutils/2.22/pr13534-05.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr13534-05.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,61 @@
+commit 1c9170065b107672a47e467abb6807bba8adf28e
+Author: Francois Gouget <fgouget@codeweavers.com>
+Date:   Tue Dec 20 18:48:52 2011 +0100
+
+    ar: Fix handling of archive elements larger than 2GB.
+
+diff --git a/binutils/ar.c b/binutils/ar.c
+index 0310b6f..e47779f 100644
+--- a/binutils/ar.c
++++ b/binutils/ar.c
+@@ -927,10 +927,10 @@ open_inarch (const char *archive_filename, const char *file)
+ static void
+ print_contents (bfd *abfd)
+ {
+-  size_t ncopied = 0;
++  bfd_size_type ncopied = 0;
+   char *cbuf = (char *) xmalloc (BUFSIZE);
+   struct stat buf;
+-  size_t size;
++  bfd_size_type size;
+   if (bfd_stat_arch_elt (abfd, &buf) != 0)
+     /* xgettext:c-format */
+     fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
+@@ -944,12 +944,12 @@ print_contents (bfd *abfd)
+   while (ncopied < size)
+     {
+ 
+-      size_t nread;
+-      size_t tocopy = size - ncopied;
++      bfd_size_type nread;
++      bfd_size_type tocopy = size - ncopied;
+       if (tocopy > BUFSIZE)
+ 	tocopy = BUFSIZE;
+ 
+-      nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
++      nread = bfd_bread (cbuf, tocopy, abfd);
+       if (nread != tocopy)
+ 	/* xgettext:c-format */
+ 	fatal (_("%s is not a valid archive"),
+@@ -980,9 +980,9 @@ extract_file (bfd *abfd)
+ {
+   FILE *ostream;
+   char *cbuf = (char *) xmalloc (BUFSIZE);
+-  size_t nread, tocopy;
+-  size_t ncopied = 0;
+-  size_t size;
++  bfd_size_type nread, tocopy;
++  bfd_size_type ncopied = 0;
++  bfd_size_type size;
+   struct stat buf;
+ 
+   if (bfd_stat_arch_elt (abfd, &buf) != 0)
+@@ -1017,7 +1017,7 @@ extract_file (bfd *abfd)
+ 	if (tocopy > BUFSIZE)
+ 	  tocopy = BUFSIZE;
+ 
+-	nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
++	nread = bfd_bread (cbuf, tocopy, abfd);
+ 	if (nread != tocopy)
+ 	  /* xgettext:c-format */
+ 	  fatal (_("%s is not a valid archive"),
diff -Nru a/patches/binutils/2.22/pr14069.patch b/patches/binutils/2.22/pr14069.patch
--- a/patches/binutils/2.22/pr14069.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr14069.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,43 @@
+===================================================================
+RCS file: /cvs/src/src/ld/emultempl/elf32.em,v
+retrieving revision 1.226
+retrieving revision 1.227
+diff -u -r1.226 -r1.227
+--- src/ld/emultempl/elf32.em	2012/05/14 19:45:28	1.226
++++ src/ld/emultempl/elf32.em	2012/05/16 10:43:41	1.227
+@@ -72,7 +72,7 @@
+ 
+ if [ "x${USE_LIBPATH}" = xyes ] ; then
+   case ${target} in
+-    *-*-linux-* | *-*-k*bsd*-*)
++    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
+   fragment <<EOF
+ #ifdef HAVE_GLOB
+ #include <glob.h>
+@@ -374,7 +374,7 @@
+ 
+ EOF
+ case ${target} in
+-  *-*-linux-* | *-*-k*bsd*-*)
++  *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
+     fragment <<EOF
+ 	  {
+ 	    struct bfd_link_needed_list *l;
+@@ -620,7 +620,7 @@
+     # FreeBSD
+     ;;
+ 
+-    *-*-linux-* | *-*-k*bsd*-*)
++    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
+       fragment <<EOF
+ /* For a native linker, check the file /etc/ld.so.conf for directories
+    in which we may find shared libraries.  /etc/ld.so.conf is really
+@@ -1310,7 +1310,7 @@
+     # FreeBSD
+     ;;
+ 
+-    *-*-linux-* | *-*-k*bsd*-*)
++    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
+     # Linux
+       fragment <<EOF
+ 	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
diff -Nru a/patches/binutils/2.22/pr14319.patch b/patches/binutils/2.22/pr14319.patch
--- a/patches/binutils/2.22/pr14319.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/binutils/2.22/pr14319.patch	2013-01-31 18:03:17.903973938 -0300
@@ -0,0 +1,60 @@
+# base code: http://sourceware.org/git/?p=binutils.git;a=commitdiff_plain;h=9fd0b9a622aaa64017f232611120ff7fa828b67a
+# backport to 2.22.
+
+diff --git a/bfd/elf.c b/bfd/elf.c
+index 9e23bee..a9cbe21 100644
+--- a/bfd/elf.c
++++ b/bfd/elf.c
+@@ -1025,7 +1025,7 @@ _bfd_elf_make_section_from_shdr (bfd *abfd,
+       else
+ 	{
+ 	  /* Normal section.  Check if we should compress.  */
+-	  if ((abfd->flags & BFD_COMPRESS))
++	  if ((abfd->flags & BFD_COMPRESS) && newsect->size != 0)
+ 	    action = compress;
+ 	}
+ 
+diff --git a/binutils/testsuite/binutils-all/compress.exp b/binutils/testsuite/binutils-all/compress.exp
+index 91ed7e4..8c40595 100644
+--- a/binutils/testsuite/binutils-all/compress.exp
++++ b/binutils/testsuite/binutils-all/compress.exp
+@@ -133,3 +133,32 @@ if ![string match "" $got] then {
+ 	pass "$testname"
+     }
+ }
++
++set testfile tmpdir/dw2-emty.o
++
++if { ![binutils_assemble_flags $srcdir/$subdir/dw2-empty.S $testfile --nocompress-debug-sections] } then {
++    unsupported "compressed debug sections"
++    return
++}
++
++set testname "objcopy compress empty debug sections"
++set got [binutils_run $OBJCOPY "--compress-debug-sections $testfile ${copyfile}.o"]
++if ![string match "" $got] then {
++    fail "objcopy ($testname)"
++} else {
++    send_log "cmp $testfile ${copyfile}.o\n"
++    verbose "cmp $testfile ${copyfile}.o"
++    set src1 ${testfile}
++    set src2 ${copyfile}.o
++    set status [remote_exec build cmp "${src1} ${src2}"]
++    set exec_output [lindex $status 1]
++    set exec_output [prune_warnings $exec_output]
++
++    if [string match "" $exec_output] then {
++    pass "objcopy ($testname)"
++    } else {
++    send_log "$exec_output\n"
++    verbose "$exec_output" 1
++    fail "objcopy ($testname)"
++    }
++}
+diff --git a/binutils/testsuite/binutils-all/dw2-empty.S b/binutils/testsuite/binutils-all/dw2-empty.S
+new file mode 100644
+index 0000000..1ff5f88
+--- /dev/null
++++ b/binutils/testsuite/binutils-all/dw2-empty.S
+@@ -0,0 +1 @@
++  .section .debug_line
diff -Nru a/patches/eglibc/ports-2_13/submitted-armhf-triplet.patch b/patches/eglibc/ports-2_13/submitted-armhf-triplet.patch
--- a/patches/eglibc/ports-2_13/submitted-armhf-triplet.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/eglibc/ports-2_13/submitted-armhf-triplet.patch	2013-01-31 20:17:22.568004818 -0300
@@ -0,0 +1,25 @@
+---
+ ports/sysdeps/arm/preconfigure   |    2 +-
+ ports/sysdeps/arm/shlib-versions |    4 ++--
+ 2 files changed, 3 insertions(+), 3 deletions(-)
+
+--- a/ports/sysdeps/arm/preconfigure
++++ b/ports/sysdeps/arm/preconfigure
+@@ -2,7 +2,7 @@
+ arm*)
+ 	base_machine=arm
+ 	case $config_os in
+-	linux-gnueabi)
++	linux-gnueabi*)
+ 		machine=arm/eabi/$machine
+ 		if [ "${CFLAGS+set}" != "set" ]; then
+ 		  CFLAGS="-g -O2"
+--- a/ports/sysdeps/arm/shlib-versions
++++ b/ports/sysdeps/arm/shlib-versions
+@@ -1,4 +1,4 @@
+-arm.*-.*-linux-gnueabi	DEFAULT			GLIBC_2.4
++arm.*-.*-linux-gnueabi.*	DEFAULT			GLIBC_2.4
+ 
+-arm.*-.*-linux-gnueabi	ld=ld-linux.so.3
++arm.*-.*-linux-gnueabi.*	ld=ld-linux.so.3
+ arm.*-.*-linux.*	ld=ld-linux.so.2
diff -Nru a/patches/eglibc/ports-2_13/unsubmitted-armhf-linker.patch b/patches/eglibc/ports-2_13/unsubmitted-armhf-linker.patch
--- a/patches/eglibc/ports-2_13/unsubmitted-armhf-linker.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/eglibc/ports-2_13/unsubmitted-armhf-linker.patch	2013-01-31 20:17:22.568004818 -0300
@@ -0,0 +1,12 @@
+---
+ ports/sysdeps/arm/shlib-versions |    1 +
+ 1 file changed, 1 insertion(+)
+
+--- a/ports/sysdeps/arm/shlib-versions
++++ b/ports/sysdeps/arm/shlib-versions
+@@ -1,4 +1,5 @@
+ arm.*-.*-linux-gnueabi.*	DEFAULT			GLIBC_2.4
+ 
++arm.*-.*-linux-gnueabihf	ld=ld-linux-armhf.so.3
+ arm.*-.*-linux-gnueabi.*	ld=ld-linux.so.3
+ arm.*-.*-linux.*	ld=ld-linux.so.2
diff -Nru a/patches/gcc/linaro-4.6-2012.10/ada-mips.patch b/patches/gcc/linaro-4.6-2012.10/ada-mips.patch
--- a/patches/gcc/linaro-4.6-2012.10/ada-mips.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/ada-mips.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,29 @@
+# DP: Improve support for mips.
+
+--- a/gcc/ada/gcc-interface/Makefile.in
++++ b/gcc/ada/gcc-interface/Makefile.in
+@@ -1682,10 +1682,15 @@
+   s-taprop.adb<s-taprop-linux.adb \
+   s-tasinf.ads<s-tasinf-linux.ads \
+   s-tasinf.adb<s-tasinf-linux.adb \
+-  s-taspri.ads<s-taspri-posix.ads \
++  s-taspri.ads<s-taspri-posix-noaltstack.ads \
+   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
+   system.ads<system-linux-mips.ads
+ 
++  TOOLS_TARGET_PAIRS =  \
++    mlib-tgt-specific.adb<mlib-tgt-specific-linux.adb \
++    indepsw.adb<indepsw-gnu.adb
++
++  EXTRA_GNATRTL_TASKING_OBJS=s-linux.o
+   EH_MECHANISM=-gcc
+   THREADSLIB = -lpthread
+   GNATLIB_SHARED = gnatlib-shared-dual
+--- a/config/bootstrap-debug.mk
++++ b/config/bootstrap-debug.mk
+@@ -9,4 +9,5 @@
+ # For more thorough testing, see bootstrap-debug-lean.mk
+ 
+ STAGE2_CFLAGS += -gtoggle
++STAGE3_CFLAGS += -gtoggle
+ do-compare = $(SHELL) $(srcdir)/contrib/compare-debug $$f1 $$f2
diff -Nru a/patches/gcc/linaro-4.6-2012.10/alpha-no-ev4-directive.patch b/patches/gcc/linaro-4.6-2012.10/alpha-no-ev4-directive.patch
--- a/patches/gcc/linaro-4.6-2012.10/alpha-no-ev4-directive.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/alpha-no-ev4-directive.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,30 @@
+# DP: never emit .ev4 directive.
+
+---
+ gcc/config/alpha/alpha.c |    7 +++----
+ 1 files changed, 3 insertions(+), 4 deletions(-)
+
+--- a/gcc/config/alpha/alpha.c
++++ b/gcc/config/alpha/alpha.c
+@@ -9733,7 +9733,7 @@
+     fputs ("\t.set nomacro\n", asm_out_file);
+   if (TARGET_SUPPORT_ARCH | TARGET_BWX | TARGET_MAX | TARGET_FIX | TARGET_CIX)
+     {
+-      const char *arch;
++      const char *arch = NULL;
+ 
+       if (alpha_cpu == PROCESSOR_EV6 || TARGET_FIX || TARGET_CIX)
+ 	arch = "ev6";
+@@ -9743,10 +9743,9 @@
+ 	arch = "ev56";
+       else if (alpha_cpu == PROCESSOR_EV5)
+ 	arch = "ev5";
+-      else
+-	arch = "ev4";
+ 
+-      fprintf (asm_out_file, "\t.arch %s\n", arch);
++      if (arch)
++        fprintf (asm_out_file, "\t.arch %s\n", arch);
+     }
+ }
+ #endif
diff -Nru a/patches/gcc/linaro-4.6-2012.10/armhf-triplet.patch b/patches/gcc/linaro-4.6-2012.10/armhf-triplet.patch
--- a/patches/gcc/linaro-4.6-2012.10/armhf-triplet.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/armhf-triplet.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,104 @@
+# DP: add support for arm-linux-*eabi* triplets; useful for armhf
+
+--- a/libjava/configure.ac
++++ b/libjava/configure.ac
+@@ -926,7 +926,7 @@
+     # on Darwin -single_module speeds up loading of the dynamic libraries.
+     extra_ldflags_libjava=-Wl,-single_module
+     ;;
+-arm*linux*eabi)
++arm*-*-linux-*eabi*)
+     # Some of the ARM unwinder code is actually in libstdc++.  We
+     # could in principle replicate it in libgcj, but it's better to
+     # have a dependency on libstdc++.
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -826,7 +826,7 @@
+ 	esac
+ 	tmake_file="${tmake_file} t-linux arm/t-arm"
+ 	case ${target} in
+-	arm*-*-linux-*eabi)
++	arm*-*-linux-*eabi*)
+ 	    tm_file="$tm_file arm/bpabi.h arm/linux-eabi.h"
+ 	    tm_file="$tm_file ../../libgcc/config/arm/bpabi-lib.h"
+ 	    tmake_file="$tmake_file arm/t-arm-elf arm/t-bpabi arm/t-linux-eabi t-slibgcc-libgcc"
+@@ -854,7 +854,7 @@
+ 	tm_file="dbxelf.h elfos.h arm/unknown-elf.h arm/elf.h arm/linux-gas.h arm/uclinux-elf.h glibc-stdint.h"
+ 	tmake_file="arm/t-arm arm/t-arm-elf"
+ 	case ${target} in
+-	arm*-*-uclinux*eabi)
++	arm*-*-uclinux*eabi*)
+ 	    tm_file="$tm_file arm/bpabi.h arm/uclinux-eabi.h"
+ 	    tm_file="$tm_file ../../libgcc/config/arm/bpabi-lib.h"
+ 	    tmake_file="$tmake_file arm/t-bpabi"
+--- a/gcc/testsuite/lib/target-supports.exp
++++ b/gcc/testsuite/lib/target-supports.exp
+@@ -3265,7 +3265,7 @@
+ 	     || [istarget i?86-*-*]
+ 	     || [istarget x86_64-*-*]
+ 	     || [istarget alpha*-*-*] 
+-	     || [istarget arm*-*-linux-gnueabi] 
++	     || [istarget arm*-*-linux-*eabi*] 
+ 	     || [istarget bfin*-*linux*]
+ 	     || [istarget hppa*-*linux*]
+ 	     || [istarget s390*-*-*] 
+@@ -3296,7 +3296,7 @@
+ 	     || [istarget i?86-*-*]
+ 	     || [istarget x86_64-*-*]
+ 	     || [istarget alpha*-*-*] 
+-	     || [istarget arm*-*-linux-gnueabi] 
++	     || [istarget arm*-*-linux-*eabi*] 
+ 	     || [istarget hppa*-*linux*]
+ 	     || [istarget s390*-*-*] 
+ 	     || [istarget powerpc*-*-*]
+--- a/gcc/ada/gcc-interface/Makefile.in
++++ b/gcc/ada/gcc-interface/Makefile.in
+@@ -1841,7 +1841,7 @@
+   LIBRARY_VERSION := $(LIB_VERSION)
+ endif
+ 
+-ifeq ($(strip $(filter-out arm% linux-gnueabi,$(arch) $(osys)-$(word 4,$(targ)))),)
++ifeq ($(strip $(filter-out arm%-linux,$(arch)-$(osys)) $(if $(findstring eabi,$(word 4,$(targ))),,$(word 4,$(targ)))),)
+   LIBGNAT_TARGET_PAIRS = \
+   a-intnam.ads<a-intnam-linux.ads \
+   s-inmaop.adb<s-inmaop-posix.adb \
+--- a/configure.ac
++++ b/configure.ac
+@@ -680,7 +680,7 @@
+     noconfigdirs="$noconfigdirs target-libffi target-qthreads"
+     libgloss_dir=arm
+     ;;
+-  arm*-*-linux-gnueabi)
++  arm*-*-linux-*eabi*)
+     noconfigdirs="$noconfigdirs target-qthreads"
+     case ${with_newlib} in
+       no) noconfigdirs="$noconfigdirs target-newlib target-libgloss"
+--- a/libstdc++-v3/configure.host
++++ b/libstdc++-v3/configure.host
+@@ -322,7 +322,7 @@
+         fi
+     esac
+     case "${host}" in
+-      arm*-*-linux-*eabi)
++      arm*-*-linux-*eabi*)
+ 	port_specific_symbol_files="\$(srcdir)/../config/os/gnu-linux/arm-eabi-extra.ver"
+ 	;;
+     esac
+--- a/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs-2.cc
++++ b/libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs-2.cc
+@@ -1,5 +1,5 @@
+ // { dg-options "-std=gnu++0x -funsigned-char -fshort-enums" }
+-// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux*eabi } }
++// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux-*eabi* } }
+ 
+ // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>
+ //
+--- a/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs-2.cc
++++ b/libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs-2.cc
+@@ -1,5 +1,5 @@
+ // { dg-options "-std=gnu++0x -funsigned-char -fshort-enums" }
+-// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux*eabi } }
++// { dg-options "-std=gnu++0x -funsigned-char -fshort-enums -Wl,--no-enum-size-warning" { target arm*-*-linux-*eabi* } }
+ 
+ // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>
+ //
diff -Nru a/patches/gcc/linaro-4.6-2012.10/arm-multilib-defaults.patch b/patches/gcc/linaro-4.6-2012.10/arm-multilib-defaults.patch
--- a/patches/gcc/linaro-4.6-2012.10/arm-multilib-defaults.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/arm-multilib-defaults.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,103 @@
+# DP: Set MULTILIB_DEFAULTS for ARM multilib builds
+
+--- a/gcc/config.gcc
++++ a/gcc/config.gcc
+@@ -3013,10 +3013,18 @@
+ 		esac
+ 
+ 		case "$with_float" in
+-		"" \
+-		| soft | hard | softfp)
++		"")
+ 			# OK
+ 			;;
++		soft)
++			tm_defines="${tm_defines} TARGET_CONFIGURED_FLOAT_ABI=0"
++			;;
++		softfp)
++			tm_defines="${tm_defines} TARGET_CONFIGURED_FLOAT_ABI=1"
++			;;
++		hard)
++			tm_defines="${tm_defines} TARGET_CONFIGURED_FLOAT_ABI=2"
++			;;
+ 		*)
+ 			echo "Unknown floating point type used in --with-float=$with_float" 1>&2
+ 			exit 1
+@@ -3060,6 +3068,9 @@
+ 		"" \
+ 		| arm | thumb )
+ 			#OK
++			if test "$with_mode" = thumb; then
++				tm_defines="${tm_defines} TARGET_CONFIGURED_THUMB_MODE=1"
++			fi
+ 			;;
+ 		*)
+ 			echo "Unknown mode used in --with-mode=$with_mode"
+--- a/gcc/config/arm/linux-eabi.h
++++ b/gcc/config/arm/linux-eabi.h
+@@ -35,7 +35,21 @@
+    target hardware.  If you override this to use the hard-float ABI then
+    change the setting of GLIBC_DYNAMIC_LINKER_DEFAULT as well.  */
+ #undef  TARGET_DEFAULT_FLOAT_ABI
++#ifdef TARGET_CONFIGURED_FLOAT_ABI
++#if TARGET_CONFIGURED_FLOAT_ABI == 2
++#define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_HARD
++#define MULTILIB_DEFAULT_FLOAT_ABI "mfloat-abi=hard"
++#elif TARGET_CONFIGURED_FLOAT_ABI == 1
++#define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFTFP
++#define MULTILIB_DEFAULT_FLOAT_ABI "mfloat-abi=softfp"
++#else
+ #define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
++#define MULTILIB_DEFAULT_FLOAT_ABI "mfloat-abi=soft"
++#endif
++#else
++#define TARGET_DEFAULT_FLOAT_ABI ARM_FLOAT_ABI_SOFT
++#define MULTILIB_DEFAULT_FLOAT_ABI "mfloat-abi=soft"
++#endif
+ 
+ /* We default to the "aapcs-linux" ABI so that enums are int-sized by
+    default.  */
+@@ -71,13 +85,43 @@
+ #undef  GLIBC_DYNAMIC_LINKER
+ #define GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "/lib/ld-linux.so.3"
+ #define GLIBC_DYNAMIC_LINKER_HARD_FLOAT "/lib/ld-linux-armhf.so.3"
++#ifdef TARGET_CONFIGURED_FLOAT_ABI
++#if TARGET_CONFIGURED_FLOAT_ABI == 2
++#define GLIBC_DYNAMIC_LINKER_DEFAULT GLIBC_DYNAMIC_LINKER_HARD_FLOAT
++#else
+ #define GLIBC_DYNAMIC_LINKER_DEFAULT GLIBC_DYNAMIC_LINKER_SOFT_FLOAT
++#endif
++#else
++#define GLIBC_DYNAMIC_LINKER_DEFAULT GLIBC_DYNAMIC_LINKER_SOFT_FLOAT
++#endif
+ 
+ #define GLIBC_DYNAMIC_LINKER \
+    "%{mfloat-abi=hard:" GLIBC_DYNAMIC_LINKER_HARD_FLOAT "} \
+     %{mfloat-abi=soft*:" GLIBC_DYNAMIC_LINKER_SOFT_FLOAT "} \
+     %{!mfloat-abi=*:" GLIBC_DYNAMIC_LINKER_DEFAULT "}"
+ 
++/* Set the multilib defaults according the configuration, needed to
++   let gcc -print-multi-dir do the right thing.  */
++
++#if TARGET_BIG_ENDIAN_DEFAULT
++#define MULTILIB_DEFAULT_ENDIAN "mbig-endian"
++#else
++#define MULTILIB_DEFAULT_ENDIAN "mlittle-endian"
++#endif
++
++#ifndef TARGET_CONFIGURED_THUMB_MODE
++#define MULTILIB_DEFAULT_MODE "marm"
++#elif TARGET_CONFIGURED_THUMB_MODE == 1
++#define MULTILIB_DEFAULT_MODE "mthumb"
++#else
++#define MULTILIB_DEFAULT_MODE "marm"
++#endif
++
++#undef  MULTILIB_DEFAULTS
++#define MULTILIB_DEFAULTS \
++	{ MULTILIB_DEFAULT_MODE, MULTILIB_DEFAULT_ENDIAN, \
++	  MULTILIB_DEFAULT_FLOAT_ABI, "mno-thumb-interwork" }
++
+ /* At this point, bpabi.h will have clobbered LINK_SPEC.  We want to
+    use the GNU/Linux version, not the generic BPABI version.  */
+ #undef  LINK_SPEC
diff -Nru a/patches/gcc/linaro-4.6-2012.10/boehm-gc-getnprocs.patch b/patches/gcc/linaro-4.6-2012.10/boehm-gc-getnprocs.patch
--- a/patches/gcc/linaro-4.6-2012.10/boehm-gc-getnprocs.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/boehm-gc-getnprocs.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,18 @@
+# DP: boehm-gc/pthread_support.c (GC_get_nprocs): Use sysconf as fallback.
+
+---
+ boehm-gc/pthread_support.c |    3 ++-
+ 1 files changed, 2 insertions(+), 1 deletions(-)
+
+--- a/boehm-gc/pthread_support.c
++++ b/boehm-gc/pthread_support.c
+@@ -724,7 +724,8 @@
+     f = open("/proc/stat", O_RDONLY);
+     if (f < 0 || (len = STAT_READ(f, stat_buf, STAT_BUF_SIZE)) < 100) {
+ 	WARN("Couldn't read /proc/stat\n", 0);
+-	return -1;
++	/* Fallback to sysconf after the warning */
++	return sysconf(_SC_NPROCESSORS_ONLN);
+     }
+     for (i = 0; i < len - 100; ++i) {
+         if (stat_buf[i] == '\n' && stat_buf[i+1] == 'c'
diff -Nru a/patches/gcc/linaro-4.6-2012.10/config-ml.patch b/patches/gcc/linaro-4.6-2012.10/config-ml.patch
--- a/patches/gcc/linaro-4.6-2012.10/config-ml.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/config-ml.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,160 @@
+# DP: - Disable some biarch libraries for biarch builds.
+# DP: - Fix multilib builds on kernels which don't support all multilibs.
+
+Index: b/config-ml.in
+===================================================================
+--- a/config-ml.in
++++ b/config-ml.in
+@@ -467,6 +467,25 @@
+ 	;;
+ esac
+ 
++if [ -z "$biarch_multidir_names" ]; then
++  biarch_multidir_names="libiberty libstdc++-v3 libgfortran libmudflap libssp libffi libobjc libgomp"
++  echo "WARNING: biarch_multidir_names is unset. Use default value:"
++  echo "  $biarch_multidir_names"
++fi
++ml_srcbase=`basename $ml_realsrcdir`
++old_multidirs="${multidirs}"
++multidirs=""
++for x in ${old_multidirs}; do
++    case " $x " in
++	" 32 "|" n32 "|" x32 "|" 64 "|" hf "|" sf ")
++	case "$biarch_multidir_names" in
++	    *"$ml_srcbase"*) multidirs="${multidirs} ${x}" ;;
++	esac
++	;;
++	*) multidirs="${multidirs} ${x}" ;;
++    esac
++done
++
+ # Remove extraneous blanks from multidirs.
+ # Tests like `if [ -n "$multidirs" ]' require it.
+ multidirs=`echo "$multidirs" | sed -e 's/^[ ][ ]*//' -e 's/[ ][ ]*$//' -e 's/[ ][ ]*/ /g'`
+@@ -654,6 +673,35 @@
+ 
+   for ml_dir in ${multidirs}; do
+ 
++    # a native build fails if the running kernel doesn't support the multilib
++    # variant; force cross compilation for these cases.
++    ml_host_arg=
++    case "${host}" in
++    i[34567]86-*-linux*)
++        case "${ml_dir}" in
++	  64) ml_host_arg="--host=x86_64-linux-gnu";;
++	  x32) ml_host_arg="--host=x86_64-linux-gnux32";;
++	esac
++	;;
++    powerpc-*-linux*)
++	case "${ml_dir}" in
++	  64) ml_host_arg="--host=powerpc64-linux-gnu"
++	esac
++	;;
++    s390-*-linux*)
++	case "${ml_dir}" in
++	  64) ml_host_arg="--host=s390x-linux-gnu"
++	esac
++	;;
++    x86_64-*-linux*)
++	case "${ml_dir}" in
++	  x32) ml_host_arg="--host=x86_64-linux-gnux32"
++	esac
++    esac
++    if [ -n "${ml_host_arg}" ]; then
++       ml_host_arg="${ml_host_arg} --with-default-host-alias=${host_alias}"
++    fi
++
+     if [ "${ml_verbose}" = --verbose ]; then
+       echo "Running configure in multilib subdir ${ml_dir}"
+       echo "pwd: `${PWDCMD-pwd}`"
+@@ -858,9 +906,20 @@
+ 	fi
+     fi
+ 
++    ml_configure_args=
++    for arg in ${ac_configure_args}
++    do
++      case $arg in
++      *CC=*)  ml_configure_args=${ml_config_env} ;;
++      *CXX=*) ml_configure_args=${ml_config_env} ;;
++      *GCJ=*) ml_configure_args=${ml_config_env} ;;
++      *) ;;
++      esac
++    done
++
+     if eval ${ml_config_env} ${ml_config_shell} ${ml_recprog} \
+ 	--with-multisubdir=${ml_dir} --with-multisrctop=${multisrctop} \
+-	${ac_configure_args} ${ml_config_env} ${ml_srcdiroption} ; then
++	${ac_configure_args} ${ml_configure_args} ${ml_host_arg} ${ml_srcdiroption} ; then
+       true
+     else
+       exit 1
+Index: b/libstdc++-v3/include/Makefile.am
+===================================================================
+--- a/libstdc++-v3/include/Makefile.am
++++ b/libstdc++-v3/include/Makefile.am
+@@ -829,8 +829,9 @@
+ endif
+ 
+ host_srcdir = ${glibcxx_srcdir}/$(OS_INC_SRCDIR)
+-host_builddir = ./${host_alias}/bits
+-host_installdir = ${gxx_include_dir}/${host_alias}$(MULTISUBDIR)/bits
++default_host_alias = @default_host_alias@
++host_builddir = ./${default_host_alias}/bits
++host_installdir = ${gxx_include_dir}/${default_host_alias}$(MULTISUBDIR)/bits
+ host_headers = \
+ 	${host_srcdir}/ctype_base.h \
+ 	${host_srcdir}/ctype_inline.h \
+@@ -1050,6 +1051,7 @@
+ 
+ stamp-${host_alias}:
+ 	@-mkdir -p ${host_builddir}
++	@test ${default_host_alias} = ${host_alias} || ln -sf ${default_host_alias} ${host_alias}
+ 	@$(STAMP) stamp-${host_alias}
+ 
+ # Host includes static.
+Index: b/libstdc++-v3/include/Makefile.in
+===================================================================
+--- a/libstdc++-v3/include/Makefile.in
++++ b/libstdc++-v3/include/Makefile.in
+@@ -1082,8 +1082,9 @@
+ # For --enable-cheaders=c_std
+ @GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE@c_compatibility_headers_extra = ${c_compatibility_headers}
+ host_srcdir = ${glibcxx_srcdir}/$(OS_INC_SRCDIR)
+-host_builddir = ./${host_alias}/bits
+-host_installdir = ${gxx_include_dir}/${host_alias}$(MULTISUBDIR)/bits
++default_host_alias = @default_host_alias@
++host_builddir = ./${default_host_alias}/bits
++host_installdir = ${gxx_include_dir}/${default_host_alias}$(MULTISUBDIR)/bits
+ host_headers = \
+ 	${host_srcdir}/ctype_base.h \
+ 	${host_srcdir}/ctype_inline.h \
+@@ -1461,6 +1462,7 @@
+ 
+ stamp-${host_alias}:
+ 	@-mkdir -p ${host_builddir}
++	@test ${default_host_alias} = ${host_alias} || ln -sf ${default_host_alias} ${host_alias}
+ 	@$(STAMP) stamp-${host_alias}
+ 
+ # Host includes static.
+Index: b/libstdc++-v3/configure.ac
+===================================================================
+--- a/libstdc++-v3/configure.ac
++++ b/libstdc++-v3/configure.ac
+@@ -458,6 +458,16 @@
+   multilib_arg=
+ fi
+ 
++AC_ARG_WITH(default-host-alias,
++[AS_HELP_STRING([--with-default-host-alias=TRIPLET],
++                [specifies host triplet used for the default multilib build])],
++[case "${withval}" in
++yes)    AC_MSG_ERROR(bad value ${withval} given for default host triplet) ;;
++no)     default_host_alias='${host_alias}' ;;
++*)      default_host_alias=${withval} ;;
++esac],[default_host_alias='${host_alias}'])
++AC_SUBST(default_host_alias)
++
+ # Export all the install information.
+ GLIBCXX_EXPORT_INSTALL_INFO
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-base-version.patch b/patches/gcc/linaro-4.6-2012.10/gcc-base-version.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-base-version.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-base-version.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,164 @@
+# DP: Set base version to 4.6, introduce full version 4.6.x.
+
+--- a/gcc/BASE-VER
++++ b/gcc/BASE-VER
+@@ -1 +1 @@
+-4.6.4
++4.6
+--- /dev/null
++++ b/gcc/FULL-VER
+@@ -0,0 +1 @@
++4.6.3
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -832,11 +832,13 @@
+ TM_H      = $(GTM_H) insn-flags.h $(OPTIONS_H)
+ 
+ # Variables for version information.
+-BASEVER     := $(srcdir)/BASE-VER  # 4.x.y
++FULLVER     := $(srcdir)/FULL-VER  # 4.x.y
++BASEVER     := $(srcdir)/BASE-VER  # 4.x
+ DEVPHASE    := $(srcdir)/DEV-PHASE # experimental, prerelease, ""
+ DATESTAMP   := $(srcdir)/DATESTAMP # YYYYMMDD or empty
+ REVISION    := $(srcdir)/REVISION  # [BRANCH revision XXXXXX]
+ 
++FULLVER_c   := $(shell cat $(FULLVER))
+ BASEVER_c   := $(shell cat $(BASEVER))
+ DEVPHASE_c  := $(shell cat $(DEVPHASE))
+ DATESTAMP_c := $(shell cat $(DATESTAMP))
+@@ -855,7 +857,7 @@
+ # development phase collapsed to the empty string in release mode
+ # (i.e. if DEVPHASE_c is empty).  The space immediately after the
+ # comma in the $(if ...) constructs is significant - do not remove it.
+-BASEVER_s   := "\"$(BASEVER_c)\""
++FULLVER_s   := "\"$(FULLVER_c)\""
+ DEVPHASE_s  := "\"$(if $(DEVPHASE_c), ($(DEVPHASE_c)))\""
+ DATESTAMP_s := "\"$(if $(DEVPHASE_c), $(DATESTAMP_c))\""
+ PKGVERSION_s:= "\"@PKGVERSION@\""
+@@ -2184,9 +2186,9 @@
+ 		$(MACHMODE_H)
+ 
+ prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) prefix.h \
+-	Makefile $(BASEVER)
++	Makefile $(FULLVER)
+ 	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+-	-DPREFIX=\"$(prefix)\" -DBASEVER=$(BASEVER_s) \
++	-DPREFIX=\"$(prefix)\" -DBASEVER=$(FULLVER_s) \
+ 	  -c $(srcdir)/prefix.c $(OUTPUT_OPTION)
+ 
+ # Language-independent files.
+@@ -2257,9 +2259,9 @@
+ 
+ dumpvers: dumpvers.c
+ 
+-version.o: version.c version.h $(REVISION) $(DATESTAMP) $(BASEVER) $(DEVPHASE)
++version.o: version.c version.h $(REVISION) $(DATESTAMP) $(FULLVER) $(DEVPHASE)
+ 	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+-	-DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \
++	-DBASEVER=$(FULLVER_s) -DDATESTAMP=$(DATESTAMP_s) \
+ 	-DREVISION=$(REVISION_s) \
+ 	-DDEVPHASE=$(DEVPHASE_s) -DPKGVERSION=$(PKGVERSION_s) \
+ 	-DBUGURL=$(BUGURL_s) -c $(srcdir)/version.c $(OUTPUT_OPTION)
+@@ -2798,10 +2800,10 @@
+    tree-ssa-alias.h $(TREE_FLOW_H)
+ 
+ bversion.h: s-bversion; @true
+-s-bversion: BASE-VER
+-	echo "#define BUILDING_GCC_MAJOR `echo $(BASEVER_c) | sed -e 's/^\([0-9]*\).*$$/\1/'`" > bversion.h
+-	echo "#define BUILDING_GCC_MINOR `echo $(BASEVER_c) | sed -e 's/^[0-9]*\.\([0-9]*\).*$$/\1/'`" >> bversion.h
+-	echo "#define BUILDING_GCC_PATCHLEVEL `echo $(BASEVER_c) | sed -e 's/^[0-9]*\.[0-9]*\.\([0-9]*\)$$/\1/'`" >> bversion.h
++s-bversion: FULL-VER
++	echo "#define BUILDING_GCC_MAJOR `echo $(FULLVER_c) | sed -e 's/^\([0-9]*\).*$$/\1/'`" > bversion.h
++	echo "#define BUILDING_GCC_MINOR `echo $(FULLVER_c) | sed -e 's/^[0-9]*\.\([0-9]*\).*$$/\1/'`" >> bversion.h
++	echo "#define BUILDING_GCC_PATCHLEVEL `echo $(FULLVER_c) | sed -e 's/^[0-9]*\.[0-9]*\.\([0-9]*\)$$/\1/'`" >> bversion.h
+ 	echo "#define BUILDING_GCC_VERSION (BUILDING_GCC_MAJOR * 1000 + BUILDING_GCC_MINOR)" >> bversion.h
+ 	$(STAMP) s-bversion
+ 
+@@ -3802,9 +3804,9 @@
+ ## build/version.o is compiled by the $(COMPILER_FOR_BUILD) but needs
+ ## several C macro definitions, just like version.o
+ build/version.o:  version.c version.h \
+-                  $(REVISION) $(DATESTAMP) $(BASEVER) $(DEVPHASE)
++                  $(REVISION) $(DATESTAMP) $(FULLVER) $(DEVPHASE)
+ 	$(COMPILER_FOR_BUILD) -c $(BUILD_COMPILERFLAGS) $(BUILD_CPPFLAGS) \
+-	-DBASEVER=$(BASEVER_s) -DDATESTAMP=$(DATESTAMP_s) \
++	-DBASEVER=$(FULLVER_s) -DDATESTAMP=$(DATESTAMP_s) \
+ 	-DREVISION=$(REVISION_s) \
+ 	-DDEVPHASE=$(DEVPHASE_s) -DPKGVERSION=$(PKGVERSION_s) \
+ 	-DBUGURL=$(BUGURL_s) -o $@ $<
+@@ -3965,7 +3967,7 @@
+ cppbuiltin.o: cppbuiltin.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+ 	cppbuiltin.h Makefile
+ 	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+-	  $(PREPROCESSOR_DEFINES) -DBASEVER=$(BASEVER_s) \
++	  $(PREPROCESSOR_DEFINES) -DBASEVER=$(FULLVER_s) \
+ 	  -c $(srcdir)/cppbuiltin.c $(OUTPUT_OPTION)
+ 
+ cppdefault.o: cppdefault.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
+@@ -3986,8 +3988,8 @@
+ 		build/gcov-iov.o -o $@
+ 
+ gcov-iov.h: s-iov
+-s-iov: build/gcov-iov$(build_exeext) $(BASEVER) $(DEVPHASE)
+-	build/gcov-iov$(build_exeext) '$(BASEVER_c)' '$(DEVPHASE_c)' \
++s-iov: build/gcov-iov$(build_exeext) $(FULLVER) $(DEVPHASE)
++	build/gcov-iov$(build_exeext) '$(FULLVER_c)' '$(DEVPHASE_c)' \
+ 	    > tmp-gcov-iov.h
+ 	$(SHELL) $(srcdir)/../move-if-change tmp-gcov-iov.h gcov-iov.h
+ 	$(STAMP) s-iov
+@@ -4211,8 +4213,8 @@
+ TEXI_CPPINT_FILES = cppinternals.texi gcc-common.texi gcc-vers.texi
+ 
+ # gcc-vers.texi is generated from the version files.
+-gcc-vers.texi: $(BASEVER) $(DEVPHASE)
+-	(echo "@set version-GCC $(BASEVER_c)"; \
++gcc-vers.texi: $(FULLVER) $(DEVPHASE)
++	(echo "@set version-GCC $(FULLVER_c)"; \
+ 	 if [ "$(DEVPHASE_c)" = "experimental" ]; \
+ 	 then echo "@set DEVELOPMENT"; \
+ 	 else echo "@clear DEVELOPMENT"; \
+@@ -4579,9 +4581,11 @@
+ install-driver: installdirs xgcc$(exeext)
+ 	-rm -f $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
+ 	-$(INSTALL_PROGRAM) xgcc$(exeext) $(DESTDIR)$(bindir)/$(GCC_INSTALL_NAME)$(exeext)
++ifneq ($(GCC_INSTALL_NAME),$(target_noncanonical)-gcc-$(version))
+ 	-rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-$(version)$(exeext)
+ 	-( cd $(DESTDIR)$(bindir) && \
+ 	   $(LN) $(GCC_INSTALL_NAME)$(exeext) $(target_noncanonical)-gcc-$(version)$(exeext) )
++endif
+ 	-if [ -f gcc-cross$(exeext) ] ; then \
+ 	  if [ -d $(DESTDIR)$(gcc_tooldir)/bin/. ] ; then \
+ 	    rm -f $(DESTDIR)$(gcc_tooldir)/bin/gcc$(exeext); \
+--- a/libjava/Makefile.am
++++ b/libjava/Makefile.am
+@@ -775,7 +775,7 @@
+ install-data-local:
+ 	$(PRE_INSTALL)
+ ## Install the .pc file.
+-	@pc_version=`echo $(GCJVERSION) | sed -e 's/[.][^.]*$$//'`; \
++	@pc_version=$(GCJVERSION); \
+ 	file="libgcj-$${pc_version}.pc"; \
+ 	$(mkinstalldirs) $(DESTDIR)$(pkgconfigdir); \
+ 	echo "  $(INSTALL_DATA) libgcj.pc $(DESTDIR)$(pkgconfigdir)/$$file"; \
+--- a/libjava/Makefile.in
++++ b/libjava/Makefile.in
+@@ -12412,7 +12412,7 @@
+ @BUILD_ECJ1_TRUE@	mv $(DESTDIR)$(libexecsubdir)/`echo ecjx | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` $(DESTDIR)$(libexecsubdir)/ecj1$(host_exeext)
+ install-data-local:
+ 	$(PRE_INSTALL)
+-	@pc_version=`echo $(GCJVERSION) | sed -e 's/[.][^.]*$$//'`; \
++	@pc_version=$(GCJVERSION); \
+ 	file="libgcj-$${pc_version}.pc"; \
+ 	$(mkinstalldirs) $(DESTDIR)$(pkgconfigdir); \
+ 	echo "  $(INSTALL_DATA) libgcj.pc $(DESTDIR)$(pkgconfigdir)/$$file"; \
+--- a/libgcc/Makefile.in
++++ b/libgcc/Makefile.in
+@@ -201,7 +201,7 @@
+ export toolexecdir
+ export toolexeclibdir
+ 
+-version := $(shell $(CC) -dumpversion)
++version := $(shell cat $(srcdir)/../gcc/BASE-VER)
+ 
+ ifeq ($(decimal_float),yes)
+ ifeq ($(enable_decimal_float),bid)
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-cloog-dl.patch b/patches/gcc/linaro-4.6-2012.10/gcc-cloog-dl.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-cloog-dl.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-cloog-dl.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,464 @@
+# DP: Link against -ldl instead of -lcloog -lppl. Exit with an error when using
+# DP: the Graphite loop transformation infrastructure without having the
+# DP: libcloog-ppl0 package installed. Packages using these optimizations
+# DP: should build-depend on libcloog-ppl0.
+
+2011-01-04  Jakub Jelinek  <jakub@redhat.com>
+
+	* Makefile.in (BACKENDLIBS): Link against -ldl instead of
+	-lcloog -lppl.
+	(graphite.o, graphite%.o): Force -O, remove -fkeep-inline-functions.
+	(GRAPHITE_CLOOG_UTIL_H, GRAPHITE_POLY_H): New.
+	(graphite*.o): Adjust dependencies.
+	* graphite-cloog-compat.h: Include <dlfcn.h>.  Reference libcloog and
+	libppl symbols through pointers in cloog_pointers__ variable.
+	* graphite.c (init_cloog_pointers): New function.
+	(graphite_transform_loops): Call init_cloog_pointers.
+	* graphite-clast-to-gimple.c (gcc_type_for_iv_of_clast_loop): Rename
+	stmt_for argument to stmt_fora.
+	* graphite-poly.h: Include graphite-cloog-util.h.
+
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -984,6 +984,8 @@
+ PLUGIN_H = plugin.h $(GCC_PLUGIN_H)
+ PLUGIN_VERSION_H = plugin-version.h configargs.h
+ LIBFUNCS_H = libfuncs.h $(HASHTAB_H)
++GRAPHITE_CLOOG_UTIL_H = graphite-cloog-util.h graphite-cloog-compat.h
++GRAPHITE_POLY_H = graphite-poly.h $(GRAPHITE_CLOOG_UTIL_H)
+ 
+ #
+ # Now figure out from those variables how to compile and link.
+@@ -1037,7 +1039,7 @@
+ # and the system's installed libraries.
+ LIBS = @LIBS@ $(CPPLIB) $(LIBINTL) $(LIBICONV) $(LIBIBERTY) $(LIBDECNUMBER) \
+ 	$(HOST_LIBS)
+-BACKENDLIBS = $(CLOOGLIBS) $(PPLLIBS) $(GMPLIBS) $(PLUGINLIBS) $(HOST_LIBS) \
++BACKENDLIBS = $(GMPLIBS) $(if $(CLOOGLIBS),-ldl) $(PLUGINLIBS) $(HOST_LIBS) \
+ 	$(ZLIB)
+ # Any system libraries needed just for GNAT.
+ SYSLIBS = @GNAT_LIBEXC@
+@@ -2668,40 +2670,40 @@
+    $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) tree-pass.h value-prof.h
+ graphite.o : graphite.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) \
+    $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h \
+-   $(DBGCNT_H) graphite-ppl.h graphite-poly.h graphite-scop-detection.h \
++   $(DBGCNT_H) graphite-ppl.h $(GRAPHITE_POLY_H) graphite-scop-detection.h \
+    graphite-clast-to-gimple.h graphite-sese-to-poly.h
+ graphite-blocking.o : graphite-blocking.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \
+-   sese.h graphite-ppl.h graphite-poly.h
++   sese.h graphite-ppl.h $(GRAPHITE_POLY_H)
+ graphite-clast-to-gimple.o : graphite-clast-to-gimple.c $(CONFIG_H) \
+    $(SYSTEM_H) coretypes.h $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) $(TREE_DUMP_H) \
+-   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h graphite-cloog-util.h \
+-   graphite-ppl.h graphite-poly.h graphite-clast-to-gimple.h \
++   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h $(GRAPHITE_CLOOG_UTIL_H) \
++   graphite-ppl.h $(GRAPHITE_POLY_H) graphite-clast-to-gimple.h \
+    graphite-dependences.h graphite-cloog-compat.h
+ graphite-cloog-util.o : graphite-cloog-util.c $(CONFIG_H) $(SYSTEM_H) \
+-   coretypes.h graphite-cloog-util.h graphite-cloog-compat.h
++   coretypes.h $(GRAPHITE_CLOOG_UTIL_H) graphite-cloog-compat.h
+ graphite-dependences.o : graphite-dependences.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \
+-   sese.h graphite-ppl.h graphite-poly.h graphite-dependences.h \
+-   graphite-cloog-util.h
++   sese.h graphite-ppl.h $(GRAPHITE_POLY_H) graphite-dependences.h \
++   $(GRAPHITE_CLOOG_UTIL_H)
+ graphite-flattening.o : graphite-flattening.c $(CONFIG_H) $(SYSTEM_H)	\
+    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \
+-   sese.h graphite-ppl.h graphite-poly.h
++   sese.h graphite-ppl.h $(GRAPHITE_POLY_H)
+ graphite-interchange.o : graphite-interchange.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) \
+-   sese.h graphite-ppl.h graphite-poly.h
++   sese.h graphite-ppl.h $(GRAPHITE_POLY_H)
+ graphite-poly.o : graphite-poly.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+    $(DIAGNOSTIC_CORE_H) $(TREE_FLOW_H) $(TREE_DUMP_H) gimple-pretty-print.h \
+-   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h graphite-ppl.h graphite-poly.h \
+-   graphite-dependences.h graphite-cloog-util.h
++   $(CFGLOOP_H) $(TREE_DATA_REF_H) sese.h graphite-ppl.h $(GRAPHITE_POLY_H) \
++   graphite-dependences.h $(GRAPHITE_CLOOG_UTIL_H)
+ graphite-ppl.o : graphite-ppl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+-   graphite-cloog-util.h graphite-ppl.h
++   $(GRAPHITE_CLOOG_UTIL_H) graphite-ppl.h
+ graphite-scop-detection.o : graphite-scop-detection.c $(CONFIG_H) $(SYSTEM_H) \
+    coretypes.h $(TREE_FLOW_H) $(CFGLOOP_H) $(TREE_DATA_REF_H) $(TREE_PASS_H) \
+-   sese.h graphite-ppl.h graphite-poly.h graphite-scop-detection.h
++   sese.h graphite-ppl.h $(GRAPHITE_POLY_H) graphite-scop-detection.h
+ graphite-sese-to-poly.o : graphite-sese-to-poly.c $(CONFIG_H) \
+    $(SYSTEM_H) coretypes.h $(TREE_FLOW_H) $(TREE_DUMP_H) $(CFGLOOP_H) \
+-   $(TREE_DATA_REF_H) domwalk.h sese.h graphite-ppl.h graphite-poly.h \
++   $(TREE_DATA_REF_H) domwalk.h sese.h graphite-ppl.h $(GRAPHITE_POLY_H) \
+    graphite-sese-to-poly.h
+ tree-vect-loop.o: tree-vect-loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+    $(TM_H) $(GGC_H) $(TREE_H) $(BASIC_BLOCK_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \
+@@ -3483,6 +3485,11 @@
+ 	$(COMPILER) -c $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+ 		$(out_file) $(OUTPUT_OPTION)
+ 
++graphite%.o : \
++  ALL_CFLAGS := -O $(filter-out -fkeep-inline-functions, $(ALL_CFLAGS))
++graphite.o : \
++  ALL_CFLAGS := -O $(filter-out -fkeep-inline-functions, $(ALL_CFLAGS))
++
+ # Build auxiliary files that support ecoff format.
+ mips-tfile: mips-tfile.o version.o $(LIBDEPS)
+ 	$(LINKER) $(LINKERFLAGS) $(LDFLAGS) -o $@ \
+--- a/gcc/graphite-cloog-compat.h
++++ b/gcc/graphite-cloog-compat.h
+@@ -272,4 +272,277 @@
+    return m->NbRows;
+ }
+ #endif /* CLOOG_ORG  */
++
++#include <dlfcn.h>
++#if PPL_VERSION_MAJOR == 0 && PPL_VERSION_MINOR < 11
++#define DYNSYMS_PPL11
++#else
++#define DYNSYMS_PPL11 \
++  DYNSYM (ppl_new_PIP_Problem_from_constraints); \
++  DYNSYM (ppl_PIP_Problem_is_satisfiable); \
++  DYNSYM (ppl_delete_PIP_Problem);
++#endif
++#define DYNSYMS \
++  DYNSYM (cloog_block_alloc); \
++  DYNSYM (cloog_block_list_free); \
++  DYNSYM (cloog_block_list_malloc); \
++  DYNSYM (cloog_clast_create); \
++  DYNSYM (cloog_clast_free); \
++  DYNSYM (cloog_domain_free); \
++  DYNSYM (cloog_domain_matrix2domain); \
++  DYNSYM (cloog_initialize); \
++  DYNSYM (cloog_loop_malloc); \
++  DYNSYM (cloog_matrix_alloc); \
++  DYNSYM (cloog_matrix_copy); \
++  DYNSYM (cloog_matrix_free); \
++  DYNSYM (cloog_matrix_print); \
++  DYNSYM (cloog_names_malloc); \
++  DYNSYM (cloog_names_scalarize); \
++  DYNSYM (cloog_options_free); \
++  DYNSYM (cloog_options_malloc); \
++  DYNSYM (cloog_program_dump_cloog); \
++  DYNSYM (cloog_program_extract_scalars); \
++  DYNSYM (cloog_program_free); \
++  DYNSYM (cloog_program_generate); \
++  DYNSYM (cloog_program_malloc); \
++  DYNSYM (cloog_program_print); \
++  DYNSYM (cloog_program_scatter); \
++  DYNSYM (cloog_statement_alloc); \
++  DYNSYM (cloog_domain_union); \
++  DYNSYM (cloog_matrix_read); \
++  DYNSYM (cloog_new_pol); \
++  DYNSYM (cloog_vector_gcd); \
++  DYNSYM (ppl_finalize); \
++  DYNSYM (ppl_assign_Coefficient_from_mpz_t); \
++  DYNSYM (ppl_assign_Linear_Expression_from_Linear_Expression); \
++  DYNSYM (ppl_Coefficient_to_mpz_t); \
++  DYNSYM (ppl_Constraint_coefficient); \
++  DYNSYM (ppl_Constraint_inhomogeneous_term); \
++  DYNSYM (ppl_Constraint_space_dimension); \
++  DYNSYM (ppl_Constraint_System_begin); \
++  DYNSYM (ppl_Constraint_System_const_iterator_dereference); \
++  DYNSYM (ppl_Constraint_System_const_iterator_equal_test); \
++  DYNSYM (ppl_Constraint_System_const_iterator_increment); \
++  DYNSYM (ppl_Constraint_System_end); \
++  DYNSYM (ppl_Constraint_System_insert_Constraint); \
++  DYNSYM (ppl_Constraint_System_space_dimension); \
++  DYNSYM (ppl_Constraint_type); \
++  DYNSYM (ppl_delete_Coefficient); \
++  DYNSYM (ppl_delete_Constraint); \
++  DYNSYM (ppl_delete_Constraint_System_const_iterator); \
++  DYNSYM (ppl_delete_Linear_Expression); \
++  DYNSYM (ppl_delete_Pointset_Powerset_C_Polyhedron); \
++  DYNSYM (ppl_delete_Pointset_Powerset_C_Polyhedron_iterator); \
++  DYNSYM (ppl_delete_Polyhedron); \
++  DYNSYM (ppl_Linear_Expression_add_to_coefficient); \
++  DYNSYM (ppl_Linear_Expression_add_to_inhomogeneous); \
++  DYNSYM (ppl_Linear_Expression_coefficient); \
++  DYNSYM (ppl_Linear_Expression_inhomogeneous_term); \
++  DYNSYM (ppl_Linear_Expression_space_dimension); \
++  DYNSYM (ppl_new_Coefficient); \
++  DYNSYM (ppl_new_Coefficient_from_mpz_t); \
++  DYNSYM (ppl_new_Constraint); \
++  DYNSYM (ppl_new_Constraint_System); \
++  DYNSYM (ppl_new_Constraint_System_const_iterator); \
++  DYNSYM (ppl_new_C_Polyhedron_from_C_Polyhedron); \
++  DYNSYM (ppl_new_C_Polyhedron_from_space_dimension); \
++  DYNSYM (ppl_new_C_Polyhedron_recycle_Constraint_System); \
++  DYNSYM (ppl_new_Linear_Expression); \
++  DYNSYM (ppl_new_Linear_Expression_from_Constraint); \
++  DYNSYM (ppl_new_Linear_Expression_from_Linear_Expression); \
++  DYNSYM (ppl_new_Linear_Expression_with_dimension); \
++  DYNSYM (ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron); \
++  DYNSYM (ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron); \
++  DYNSYM (ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension); \
++  DYNSYM (ppl_new_Pointset_Powerset_C_Polyhedron_iterator); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_add_constraint); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_difference_assign); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_intersection_assign); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_is_empty); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_iterator_begin); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_iterator_end); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_iterator_increment); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_maximize); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_minimize); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_size); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_space_dimension); \
++  DYNSYM (ppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign); \
++  DYNSYM (ppl_Polyhedron_add_constraint); \
++  DYNSYM (ppl_Polyhedron_add_constraints); \
++  DYNSYM (ppl_Polyhedron_add_space_dimensions_and_embed); \
++  DYNSYM (ppl_Polyhedron_get_constraints); \
++  DYNSYM (ppl_Polyhedron_map_space_dimensions); \
++  DYNSYM (ppl_Polyhedron_remove_space_dimensions); \
++  DYNSYM (ppl_Polyhedron_space_dimension); \
++  DYNSYM (ppl_subtract_Linear_Expression_from_Linear_Expression); \
++  DYNSYM (pprint); \
++  DYNSYM (stmt_block); \
++  DYNSYM (stmt_for); \
++  DYNSYM (stmt_guard); \
++  DYNSYM (stmt_root); \
++  DYNSYM (stmt_user); \
++  DYNSYM (ppl_delete_Constraint_System); \
++  DYNSYM (ppl_initialize); \
++  DYNSYM (ppl_new_Constraint_System_from_Constraint); \
++  DYNSYM (ppl_new_C_Polyhedron_from_Constraint_System); \
++  DYNSYM (ppl_Polyhedron_affine_image); \
++  DYNSYM (ppl_io_fprint_Pointset_Powerset_C_Polyhedron); \
++  DYNSYMS_PPL11
++extern struct
++{
++  bool inited;
++  void *h;
++#define DYNSYM(x) __typeof (x) *p_##x
++  DYNSYMS
++#undef DYNSYM
++} cloog_pointers__;
++
++#define cloog_block_alloc (*cloog_pointers__.p_cloog_block_alloc)
++#define cloog_block_list_free (*cloog_pointers__.p_cloog_block_list_free)
++#define cloog_block_list_malloc (*cloog_pointers__.p_cloog_block_list_malloc)
++#define cloog_clast_create (*cloog_pointers__.p_cloog_clast_create)
++#define cloog_clast_free (*cloog_pointers__.p_cloog_clast_free)
++#define cloog_domain_free (*cloog_pointers__.p_cloog_domain_free)
++#define cloog_domain_matrix2domain (*cloog_pointers__.p_cloog_domain_matrix2domain)
++#define cloog_initialize (*cloog_pointers__.p_cloog_initialize)
++#ifndef CLOOG_ORG
++#undef cloog_loop_malloc
++#define cloog_loop_malloc(STATE) (*cloog_pointers__.p_cloog_loop_malloc) ()
++#else
++#define cloog_loop_malloc (*cloog_pointers__.p_cloog_loop_malloc)
++#endif
++#define cloog_matrix_alloc (*cloog_pointers__.p_cloog_matrix_alloc)
++#define cloog_matrix_copy (*cloog_pointers__.p_cloog_matrix_copy)
++#define cloog_matrix_free (*cloog_pointers__.p_cloog_matrix_free)
++#define cloog_matrix_print (*cloog_pointers__.p_cloog_matrix_print)
++#define cloog_names_malloc (*cloog_pointers__.p_cloog_names_malloc)
++#define cloog_names_scalarize (*cloog_pointers__.p_cloog_names_scalarize)
++#define cloog_options_free (*cloog_pointers__.p_cloog_options_free)
++#ifndef CLOOG_ORG
++#undef cloog_options_malloc
++#define cloog_options_malloc(STATE) (*cloog_pointers__.p_cloog_options_malloc) ()
++#undef cloog_program_dump_cloog
++#define cloog_program_dump_cloog(DUMPFILE, PROGRAM, SCATTERINGLIST) \
++  (*cloog_pointers__.p_cloog_program_dump_cloog) (DUMPFILE, PROGRAM)
++#undef cloog_program_extract_scalars
++#define cloog_program_extract_scalars(PROG, SCATT, OPT) \
++  (*cloog_pointers__.p_cloog_program_extract_scalars) (PROG, SCATT)
++#else
++#define cloog_options_malloc (*cloog_pointers__.p_cloog_options_malloc)
++#define cloog_program_dump_cloog (*cloog_pointers__.p_cloog_program_dump_cloog)
++#define cloog_program_extract_scalars (*cloog_pointers__.p_cloog_program_extract_scalars)
++#endif
++#define cloog_program_free (*cloog_pointers__.p_cloog_program_free)
++#define cloog_program_generate (*cloog_pointers__.p_cloog_program_generate)
++#define cloog_program_malloc (*cloog_pointers__.p_cloog_program_malloc)
++#define cloog_program_print (*cloog_pointers__.p_cloog_program_print)
++#ifndef CLOOG_ORG
++#undef cloog_program_scatter
++#define cloog_program_scatter(PROG, SCATT, OPT) \
++  (*cloog_pointers__.p_cloog_program_scatter) (PROG, SCATT)
++#undef cloog_statement_alloc
++#define cloog_statement_alloc(STATE, INDEX) \
++  (*cloog_pointers__.p_cloog_statement_alloc) (INDEX)
++#else
++#define cloog_program_scatter (*cloog_pointers__.p_cloog_program_scatter)
++#define cloog_statement_alloc (*cloog_pointers__.p_cloog_statement_alloc)
++#endif
++#define cloog_domain_union (*cloog_pointers__.p_cloog_domain_union)
++#define cloog_matrix_read (*cloog_pointers__.p_cloog_matrix_read)
++#define cloog_new_pol (*cloog_pointers__.p_cloog_new_pol)
++#define cloog_vector_gcd (*cloog_pointers__.p_cloog_vector_gcd)
++#define ppl_finalize (*cloog_pointers__.p_ppl_finalize)
++#define ppl_assign_Coefficient_from_mpz_t (*cloog_pointers__.p_ppl_assign_Coefficient_from_mpz_t)
++#define ppl_assign_Linear_Expression_from_Linear_Expression (*cloog_pointers__.p_ppl_assign_Linear_Expression_from_Linear_Expression)
++#define ppl_Coefficient_to_mpz_t (*cloog_pointers__.p_ppl_Coefficient_to_mpz_t)
++#define ppl_Constraint_coefficient (*cloog_pointers__.p_ppl_Constraint_coefficient)
++#define ppl_Constraint_inhomogeneous_term (*cloog_pointers__.p_ppl_Constraint_inhomogeneous_term)
++#define ppl_Constraint_space_dimension (*cloog_pointers__.p_ppl_Constraint_space_dimension)
++#define ppl_Constraint_System_begin (*cloog_pointers__.p_ppl_Constraint_System_begin)
++#define ppl_Constraint_System_const_iterator_dereference (*cloog_pointers__.p_ppl_Constraint_System_const_iterator_dereference)
++#define ppl_Constraint_System_const_iterator_equal_test (*cloog_pointers__.p_ppl_Constraint_System_const_iterator_equal_test)
++#define ppl_Constraint_System_const_iterator_increment (*cloog_pointers__.p_ppl_Constraint_System_const_iterator_increment)
++#define ppl_Constraint_System_end (*cloog_pointers__.p_ppl_Constraint_System_end)
++#define ppl_Constraint_System_insert_Constraint (*cloog_pointers__.p_ppl_Constraint_System_insert_Constraint)
++#define ppl_Constraint_System_space_dimension (*cloog_pointers__.p_ppl_Constraint_System_space_dimension)
++#define ppl_Constraint_type (*cloog_pointers__.p_ppl_Constraint_type)
++#define ppl_delete_Coefficient (*cloog_pointers__.p_ppl_delete_Coefficient)
++#define ppl_delete_Constraint (*cloog_pointers__.p_ppl_delete_Constraint)
++#define ppl_delete_Constraint_System_const_iterator (*cloog_pointers__.p_ppl_delete_Constraint_System_const_iterator)
++#define ppl_delete_Linear_Expression (*cloog_pointers__.p_ppl_delete_Linear_Expression)
++#define ppl_delete_Pointset_Powerset_C_Polyhedron (*cloog_pointers__.p_ppl_delete_Pointset_Powerset_C_Polyhedron)
++#define ppl_delete_Pointset_Powerset_C_Polyhedron_iterator (*cloog_pointers__.p_ppl_delete_Pointset_Powerset_C_Polyhedron_iterator)
++#define ppl_delete_Polyhedron (*cloog_pointers__.p_ppl_delete_Polyhedron)
++#define ppl_Linear_Expression_add_to_coefficient (*cloog_pointers__.p_ppl_Linear_Expression_add_to_coefficient)
++#define ppl_Linear_Expression_add_to_inhomogeneous (*cloog_pointers__.p_ppl_Linear_Expression_add_to_inhomogeneous)
++#define ppl_Linear_Expression_coefficient (*cloog_pointers__.p_ppl_Linear_Expression_coefficient)
++#define ppl_Linear_Expression_inhomogeneous_term (*cloog_pointers__.p_ppl_Linear_Expression_inhomogeneous_term)
++#define ppl_Linear_Expression_space_dimension (*cloog_pointers__.p_ppl_Linear_Expression_space_dimension)
++#define ppl_new_Coefficient (*cloog_pointers__.p_ppl_new_Coefficient)
++#define ppl_new_Coefficient_from_mpz_t (*cloog_pointers__.p_ppl_new_Coefficient_from_mpz_t)
++#define ppl_new_Constraint (*cloog_pointers__.p_ppl_new_Constraint)
++#define ppl_new_Constraint_System (*cloog_pointers__.p_ppl_new_Constraint_System)
++#define ppl_new_Constraint_System_const_iterator (*cloog_pointers__.p_ppl_new_Constraint_System_const_iterator)
++#define ppl_new_C_Polyhedron_from_C_Polyhedron (*cloog_pointers__.p_ppl_new_C_Polyhedron_from_C_Polyhedron)
++#define ppl_new_C_Polyhedron_from_space_dimension (*cloog_pointers__.p_ppl_new_C_Polyhedron_from_space_dimension)
++#define ppl_new_C_Polyhedron_recycle_Constraint_System (*cloog_pointers__.p_ppl_new_C_Polyhedron_recycle_Constraint_System)
++#define ppl_new_Linear_Expression (*cloog_pointers__.p_ppl_new_Linear_Expression)
++#define ppl_new_Linear_Expression_from_Constraint (*cloog_pointers__.p_ppl_new_Linear_Expression_from_Constraint)
++#define ppl_new_Linear_Expression_from_Linear_Expression (*cloog_pointers__.p_ppl_new_Linear_Expression_from_Linear_Expression)
++#define ppl_new_Linear_Expression_with_dimension (*cloog_pointers__.p_ppl_new_Linear_Expression_with_dimension)
++#define ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron (*cloog_pointers__.p_ppl_new_Pointset_Powerset_C_Polyhedron_from_C_Polyhedron)
++#define ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron (*cloog_pointers__.p_ppl_new_Pointset_Powerset_C_Polyhedron_from_Pointset_Powerset_C_Polyhedron)
++#define ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension (*cloog_pointers__.p_ppl_new_Pointset_Powerset_C_Polyhedron_from_space_dimension)
++#define ppl_new_Pointset_Powerset_C_Polyhedron_iterator (*cloog_pointers__.p_ppl_new_Pointset_Powerset_C_Polyhedron_iterator)
++#define ppl_Pointset_Powerset_C_Polyhedron_add_constraint (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_add_constraint)
++#define ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_add_space_dimensions_and_embed)
++#define ppl_Pointset_Powerset_C_Polyhedron_difference_assign (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_difference_assign)
++#define ppl_Pointset_Powerset_C_Polyhedron_intersection_assign (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_intersection_assign)
++#define ppl_Pointset_Powerset_C_Polyhedron_is_empty (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_is_empty)
++#define ppl_Pointset_Powerset_C_Polyhedron_iterator_begin (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_iterator_begin)
++#define ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_iterator_dereference)
++#define ppl_Pointset_Powerset_C_Polyhedron_iterator_end (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_iterator_end)
++#define ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_iterator_equal_test)
++#define ppl_Pointset_Powerset_C_Polyhedron_iterator_increment (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_iterator_increment)
++#define ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_map_space_dimensions)
++#define ppl_Pointset_Powerset_C_Polyhedron_maximize (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_maximize)
++#define ppl_Pointset_Powerset_C_Polyhedron_minimize (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_minimize)
++#define ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_remove_space_dimensions)
++#define ppl_Pointset_Powerset_C_Polyhedron_size (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_size)
++#define ppl_Pointset_Powerset_C_Polyhedron_space_dimension (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_space_dimension)
++#define ppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign (*cloog_pointers__.p_ppl_Pointset_Powerset_C_Polyhedron_upper_bound_assign)
++#define ppl_Polyhedron_add_constraint (*cloog_pointers__.p_ppl_Polyhedron_add_constraint)
++#define ppl_Polyhedron_add_constraints (*cloog_pointers__.p_ppl_Polyhedron_add_constraints)
++#define ppl_Polyhedron_add_space_dimensions_and_embed (*cloog_pointers__.p_ppl_Polyhedron_add_space_dimensions_and_embed)
++#define ppl_Polyhedron_get_constraints (*cloog_pointers__.p_ppl_Polyhedron_get_constraints)
++#define ppl_Polyhedron_map_space_dimensions (*cloog_pointers__.p_ppl_Polyhedron_map_space_dimensions)
++#define ppl_Polyhedron_remove_space_dimensions (*cloog_pointers__.p_ppl_Polyhedron_remove_space_dimensions)
++#define ppl_Polyhedron_space_dimension (*cloog_pointers__.p_ppl_Polyhedron_space_dimension)
++#define ppl_subtract_Linear_Expression_from_Linear_Expression (*cloog_pointers__.p_ppl_subtract_Linear_Expression_from_Linear_Expression)
++#define pprint (*cloog_pointers__.p_pprint)
++#define stmt_block (*cloog_pointers__.p_stmt_block)
++#define stmt_for (*cloog_pointers__.p_stmt_for)
++#define stmt_guard (*cloog_pointers__.p_stmt_guard)
++#define stmt_root (*cloog_pointers__.p_stmt_root)
++#define stmt_user (*cloog_pointers__.p_stmt_user)
++#define ppl_delete_Constraint_System (*cloog_pointers__.p_ppl_delete_Constraint_System)
++#define ppl_initialize (*cloog_pointers__.p_ppl_initialize)
++#define ppl_new_Constraint_System_from_Constraint (*cloog_pointers__.p_ppl_new_Constraint_System_from_Constraint)
++#define ppl_new_C_Polyhedron_from_Constraint_System (*cloog_pointers__.p_ppl_new_C_Polyhedron_from_Constraint_System)
++#define ppl_Polyhedron_affine_image (*cloog_pointers__.p_ppl_Polyhedron_affine_image)
++#define ppl_io_fprint_Pointset_Powerset_C_Polyhedron (*cloog_pointers__.p_ppl_io_fprint_Pointset_Powerset_C_Polyhedron)
++#if !(PPL_VERSION_MAJOR == 0 && PPL_VERSION_MINOR < 11)
++#define ppl_new_PIP_Problem_from_constraints (*cloog_pointers__.p_ppl_new_PIP_Problem_from_constraints)
++#define ppl_PIP_Problem_is_satisfiable (*cloog_pointers__.p_ppl_PIP_Problem_is_satisfiable)
++#define ppl_delete_PIP_Problem (*cloog_pointers__.p_ppl_delete_PIP_Problem)
++#endif
++
++#define cloog_finalize (*cloog_pointers__.p_ppl_finalize)
++
++
+ #endif /* GRAPHITE_CLOOG_COMPAT_H  */
+--- a/gcc/graphite.c
++++ b/gcc/graphite.c
+@@ -56,6 +56,35 @@
+ 
+ CloogState *cloog_state;
+ 
++__typeof (cloog_pointers__) cloog_pointers__;
++
++static bool
++init_cloog_pointers (void)
++{
++  void *h;
++
++  if (cloog_pointers__.inited)
++    return cloog_pointers__.h != NULL;
++  h = dlopen ("libcloog-ppl.so.0", RTLD_LAZY);
++  cloog_pointers__.h = h;
++  if (h == NULL)
++    return false;
++#define DYNSYM(x) \
++  do \
++    { \
++      union { __typeof (cloog_pointers__.p_##x) p; void *q; } u; \
++      u.q = dlsym (h, #x); \
++      if (u.q == NULL) \
++	return false; \
++      cloog_pointers__.p_##x = u.p; \
++    } \
++  while (0)
++  DYNSYMS
++#undef DYNSYM
++  return true;
++}
++
++
+ /* Print global statistics to FILE.  */
+ 
+ static void
+@@ -201,6 +230,12 @@
+       return false;
+     }
+ 
++  if (!init_cloog_pointers ())
++    {
++      sorry ("Graphite loop optimizations can only be used if the libcloog-ppl0 package is installed");
++      return false;
++    }
++
+   scev_reset ();
+   recompute_all_dominators ();
+   initialize_original_copy_tables ();
+--- a/gcc/graphite-clast-to-gimple.c
++++ b/gcc/graphite-clast-to-gimple.c
+@@ -738,10 +738,10 @@
+    from STMT_FOR.  */
+ 
+ static tree
+-gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_for, int level,
++gcc_type_for_iv_of_clast_loop (struct clast_for *stmt_fora, int level,
+ 			       tree lb_type, tree ub_type)
+ {
+-  struct clast_stmt *stmt = (struct clast_stmt *) stmt_for;
++  struct clast_stmt *stmt = (struct clast_stmt *) stmt_fora;
+   struct clast_user_stmt *body = clast_get_body_of_loop (stmt);
+   CloogStatement *cs = body->statement;
+   poly_bb_p pbb = (poly_bb_p) cloog_statement_usr (cs);
+--- a/gcc/graphite-poly.h
++++ b/gcc/graphite-poly.h
+@@ -22,6 +22,8 @@
+ #ifndef GCC_GRAPHITE_POLY_H
+ #define GCC_GRAPHITE_POLY_H
+ 
++#include "graphite-cloog-util.h"
++
+ typedef struct poly_dr *poly_dr_p;
+ DEF_VEC_P(poly_dr_p);
+ DEF_VEC_ALLOC_P (poly_dr_p, heap);
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-d-lang.patch b/patches/gcc/linaro-4.6-2012.10/gcc-d-lang.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-d-lang.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-d-lang.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,304 @@
+# DP: Add D options and specs for the gcc driver.
+
+--- /dev/null
++++ b/gcc/d/lang-specs.h
+@@ -0,0 +1,53 @@
++/* GDC -- D front-end for GCC
++   Copyright (C) 2004 David Friedman
++
++   This program is free software; you can redistribute it and/or modify
++   it under the terms of the GNU General Public License as published by
++   the Free Software Foundation; either version 2 of the License, or
++   (at your option) any later version.
++
++   This program is distributed in the hope that it will be useful,
++   but WITHOUT ANY WARRANTY; without even the implied warranty of
++   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++   GNU General Public License for more details.
++
++   You should have received a copy of the GNU General Public License
++   along with this program; if not, write to the Free Software
++   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++*/
++
++#ifndef D_D_SPEC
++#define D_D_SPEC 0
++#endif
++
++/* %{!M} probably doesn't make sense because we would need
++   to do that -- -MD and -MMD doesn't sound like a plan for D.... */
++
++/* %(d_options) ? */
++
++#if D_DRIVER_ONLY
++{".html", "@d", 0, 1, 0 },
++{".HTML", "@d", 0, 1, 0 },
++{".htm", "@d", 0, 1, 0 },
++{".HTM", "@d", 0, 1, 0 },
++{".xhtml", "@d", 0, 1, 0 },
++{".XHTML", "@d", 0, 1, 0 },
++{".d", "@d", 0, 1, 0 },
++{".D", "@d", 0, 1, 0 },
++{".dd", "@d", 0, 1, 0 },
++{".DD", "@d", 0, 1, 0 },
++{".di", "@d", 0, 1, 0 },
++{".DI", "@d", 0, 1, 0 },
++{"@d",
++     "%{!E:cc1d %i %(cc1_options) %(cc1d) %I %N %{nostdinc*} %{+e*} %{I*} %{J*}\
++      %{M} %{MM} %{!fsyntax-only:%(invoke_as)}}", D_D_SPEC, 1, 0 },
++#else
++{".d", "@d", 0, 1, 0 },
++{".D", "@d", 0, 1, 0 },
++{".di", "@d", 0, 1, 0 },
++{".DI", "@d", 0, 1, 0 },
++{"@d",
++     "%{!E:cc1d %i %(cc1_options) %(cc1d) %I %N %{nostdinc*} %{+e*} %{I*} %{J*}\
++      %{M} %{MM} %{!fsyntax-only:%(invoke_as)}}", D_D_SPEC, 1, 0 },
++#endif
++
+--- /dev/null
++++ b/gcc/d/lang.opt
+@@ -0,0 +1,215 @@
++; GDC -- D front-end for GCC
++; Copyright (C) 2004 David Friedman
++;
++; This program is free software; you can redistribute it and/or modify
++; it under the terms of the GNU General Public License as published by
++; the Free Software Foundation; either version 2 of the License, or
++; (at your option) any later version.
++;
++; This program is distributed in the hope that it will be useful,
++; but WITHOUT ANY WARRANTY; without even the implied warranty of
++; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++; GNU General Public License for more details.
++;
++; You should have received a copy of the GNU General Public License
++; along with this program; if not, write to the Free Software
++; Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
++
++; This is used in GCC 3.4+
++; %% TODO cleanup in ASCII collating order.
++
++Language
++D
++
++I
++D Joined Separate
++-I <dir>	Add <dir> to the end of the main include path.
++
++J
++D Joined Separate
++-J <dir>	Add <dir> to the end of the string import path.
++
++fdeprecated
++D
++Allow use of deprecated features
++
++fassert
++D
++Generate runtime code for assert()'s
++
++frelease
++D
++Compile release version
++
++; For D: defaults to on
++fbounds-check
++D
++Generate code to check bounds before indexing arrays
++
++funittest
++D
++Compile in unittest code
++
++fversion=
++D Joined RejectNegative
++-fversion=<level|ident> Compile in version code >= <level> or identified by <ident>
++
++fdebug=
++D Joined RejectNegative
++-fdebug,-fdebug=<level>,-fdebug=<ident> Compile in debug code, code <= level, or code identified by ident
++
++fdebug
++D
++Compile in debug code
++
++fdebug-c
++D
++With -g, generate C debug information for debugger compatibility
++
++fdeps=
++D Joined RejectNegative
++-fdeps=<filename> Write module dependencies to filename
++
++fd-verbose
++D
++Print information about D language processing to stdout
++
++fd-vtls
++D
++List all variables going into thread local storage
++
++fd-version=1
++D RejectNegative
++Compile as D language version 1
++
++femit-templates=
++D Joined RejectNegative
++-femit-templates=[normal|private|all|none|auto]	Control template emission
++
++femit-templates
++D
++-femit-templates Emit templates code and data even if the linker cannot merge multiple copies
++
++nostdinc
++D
++Do not search standard system include directories
++
++fonly=
++D Joined RejectNegative
++Process all modules specified on the command line, but only generate code for the module specified by the argument.
++
++fignore-unknown-pragmas
++D
++Ignore unsupported pragmas
++
++fproperty
++D
++Enforce property syntax
++
++fintfc
++Generate D interface files
++
++fintfc-dir=
++D Joined RejectNegative
++-fintfc-dir=<dir> Write D interface files to directory <dir>
++
++fintfc-file=
++D Joined RejectNegative
++-fintfc-file=<filename> Write D interface file to <filename>
++
++fdoc
++D
++Generate documentation
++
++fdoc-dir=
++D Joined RejectNegative
++-fdoc-dir=<docdir> Write documentation file to docdir directory
++
++fdoc-file=
++D Joined RejectNegative
++-fdoc-file=<filename> Write documentation file to filename
++
++fdoc-inc=
++D Joined RejectNegative
++-fdoc-inc=<filename> Include a Ddoc macro file
++
++fmultilib-dir=
++D Joined RejectNegative
++-fmultilib-dir=<dir> Select header multilib subdirectory
++
++Wsign-compare
++D
++Warn about signed-unsigned comparisons
++
++fdump-source
++D RejectNegative
++Dump decoded UTF-8 text and source from HTML
++
++fasm
++D
++Recognize the \"asm\" keyword
++
++fbuiltin
++D
++Recognize built-in functions
++
++funsigned-char
++D
++Make \"char\" unsigned by default (silently ignored in D)
++
++fsigned-char
++D
++Make \"char\" signed by default (silently ignored in D)
++
++imultilib
++D Joined Separate
++-imultilib <dir> Set <dir> to be the multilib include subdirectory
++
++iprefix
++D Joined Separate
++-iprefix <path>	Specify <path> as a prefix for next two options
++
++isysroot
++D Joined Separate
++-isysroot <dir>	Set <dir> to be the system root directory
++
++isystem
++D Joined Separate
++-isystem <dir>	Add <dir> to the start of the system include path
++
++Wall
++D
++Enable most warning messages
++
++Werror
++D
++Error out the compiler on warnings
++
++fXf=
++D Joined RejectNegative
++-fXf=<filename> Write JSON file to <filename>
++
++
++; Everything below this line is used in 4.6+
++
++debuglib=
++Driver Joined
++Debug library to use instead of phobos
++
++defaultlib=
++Driver Joined
++Default library to use instead of phobos
++
++fod=
++Driver Joined
++-fod=<directory> Specify the object output directory.
++
++fop
++Driver
++Specify that the source file's parent directories should be appended to the object output directory.
++
++nophoboslib
++Driver
++
++static_libphobos
++Driver
+--- a/gcc/gcc.c
++++ b/gcc/gcc.c
+@@ -373,6 +373,7 @@
+ 	assembler has done its job.
+  %D	Dump out a -L option for each directory in startfile_prefixes.
+ 	If multilib_dir is set, extra entries are generated with it affixed.
++ %N	Output the currently selected multilib directory name.
+  %l     process LINK_SPEC as a spec.
+  %L     process LIB_SPEC as a spec.
+  %G     process LIBGCC_SPEC as a spec.
+@@ -5095,6 +5096,17 @@
+ 	      return value;
+ 	    break;
+ 
++          case 'N':
++	    if (multilib_dir)
++	      {
++		arg_going = 1;
++		obstack_grow (&obstack, "-fmultilib-dir=",
++			      strlen ("-fmultilib-dir="));
++		obstack_grow (&obstack, multilib_dir,
++			      strlen (multilib_dir));
++	      }
++	    break;
++
+ 	    /* Here we define characters other than letters and digits.  */
+ 
+ 	  case '{':
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-driver-extra-langs.patch b/patches/gcc/linaro-4.6-2012.10/gcc-driver-extra-langs.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-driver-extra-langs.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-driver-extra-langs.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,20 @@
+# DP: Add options and specs for languages that are not built from a source
+# DP: (but built from separate sources).
+
+---
+ gcc/Makefile.in |    4 ++--
+ 1 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -503,8 +503,8 @@
+ 		      compile.exp dg.exp \
+ 		      dg-torture.exp,builtins.exp \
+ 		      struct-layout-1.exp,unsorted.exp,stackalign.exp,i386.exp
+-lang_opt_files=@lang_opt_files@ $(srcdir)/c-family/c.opt $(srcdir)/common.opt
+-lang_specs_files=@lang_specs_files@
++lang_opt_files=$(sort @lang_opt_files@ $(srcdir)/c-family/c.opt $(srcdir)/common.opt $(foreach lang,$(subst ada,ada/gcc-interface,$(debian_extra_langs)),$(srcdir)/$(lang)/lang.opt))
++lang_specs_files=$(sort @lang_specs_files@ $(foreach lang,$(subst ada,ada/gcc-interface,$(debian_extra_langs)),$(srcdir)/$(lang)/lang-specs.h))
+ lang_tree_files=@lang_tree_files@
+ target_cpu_default=@target_cpu_default@
+ GCC_THREAD_FILE=@thread_file@
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix1.patch b/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix1.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix1.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix1.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,46 @@
+# DP: Backport patch from the 4.7 branch, fixing gengtype memory issue.
+
+gcc/
+
+2011-04-21  Dimitrios Apostolou  <jimis@gmx.net>
+	    Jeff Law  <law@redhat.com>
+
+	* gengtype-state.c (read_a_state_token): Fix argument to 
+	obstack_free.
+	* gengtype.c (matching_file_name_substitute): Likewise.
+
+Index: gcc/gengtype-state.c
+===================================================================
+--- a/gcc/gengtype-state.c	(revision 172831)
++++ b/gcc/gengtype-state.c	(revision 172832)
+@@ -303,7 +303,7 @@
+       obstack_1grow (&id_obstack, (char) 0);
+       ids = XOBFINISH (&id_obstack, char *);
+       sid = state_ident_by_name (ids, INSERT);
+-      obstack_free (&id_obstack, ids);
++      obstack_free (&id_obstack, NULL);
+       ids = NULL;
+       tk = XCNEW (struct state_token_st);
+       tk->stok_kind = STOK_NAME;
+@@ -408,7 +408,7 @@
+       tk->stok_file = state_path;
+       tk->stok_next = NULL;
+       strcpy (tk->stok_un.stok_string, cstr);
+-      obstack_free (&bstring_obstack, cstr);
++      obstack_free (&bstring_obstack, NULL);
+ 
+       return tk;
+     }
+Index: gcc/gengtype.c
+===================================================================
+--- a/gcc/gengtype.c	(revision 172831)
++++ b/gcc/gengtype.c	(revision 172832)
+@@ -1943,7 +1943,7 @@
+   obstack_1grow (&str_obstack, '\0');
+   rawstr = XOBFINISH (&str_obstack, char *);
+   str = xstrdup (rawstr);
+-  obstack_free (&str_obstack, rawstr);
++  obstack_free (&str_obstack, NULL);
+   DBGPRINTF ("matched replacement %s", str);
+   rawstr = NULL;
+   return str;
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix2.patch b/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix2.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix2.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-gengtype-fix2.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,16 @@
+# DP: Write gengtype output to a temporary file before using it
+
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -3780,9 +3780,10 @@
+ 	 gtyp-input.list
+ # First, parse all files and save a state file.
+ 	$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \
+-                    -S $(srcdir) -I gtyp-input.list -w gtype.state
++                    -S $(srcdir) -I gtyp-input.list -w tmp-gtype.state
+ # Second, read the state file and generate all files.  This ensure that
+ # gtype.state is correctly read:
++	$(SHELL) $(srcdir)/../move-if-change tmp-gtype.state gtype.state
+ 	$(RUN_GEN) build/gengtype$(build_exeext) $(GENGTYPE_FLAGS) \
+                     -r gtype.state
+ 	$(STAMP) s-gtype
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-gfdl-build.patch b/patches/gcc/linaro-4.6-2012.10/gcc-gfdl-build.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-gfdl-build.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-gfdl-build.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,34 @@
+# DP: Build a dummy s-tm-texi without access to the texinfo sources
+
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -3681,27 +3681,9 @@
+ # \r is not portable to Solaris tr, therefore we have a special
+ # case for ASCII.  We use \r for other encodings like EBCDIC.
+ s-tm-texi: build/genhooks$(build_exeext) $(srcdir)/doc/tm.texi.in
+-	$(RUN_GEN) build/genhooks$(build_exeext) \
+-			$(srcdir)/doc/tm.texi.in > tmp-tm.texi
+-	case `echo X|tr X '\101'` in \
+-	  A) tr -d '\015' < tmp-tm.texi > tmp2-tm.texi ;; \
+-	  *) tr -d '\r' < tmp-tm.texi > tmp2-tm.texi ;; \
+-	esac
+-	mv tmp2-tm.texi tmp-tm.texi
++	cat $(srcdir)/doc/tm.texi.in > tmp-tm.texi
+ 	$(SHELL) $(srcdir)/../move-if-change tmp-tm.texi tm.texi
+-	@if cmp -s $(srcdir)/doc/tm.texi tm.texi; then \
+-	  $(STAMP) $@; \
+-	elif test $(srcdir)/doc/tm.texi -nt $(srcdir)/doc/tm.texi.in \
+-	  && test $(srcdir)/doc/tm.texi -nt $(srcdir)/target.def; then \
+-	  echo >&2 ; \
+-	  echo You should edit $(srcdir)/doc/tm.texi.in rather than $(srcdir)/doc/tm.texi . >&2 ; \
+-	  false; \
+-	else \
+-	  echo >&2 ; \
+-	  echo Verify that you have permission to grant a GFDL license for all >&2 ; \
+-	  echo new text in tm.texi, then copy it to $(srcdir)/doc/tm.texi. >&2 ; \
+-	  false; \
+-	fi
++	$(STAMP) $@
+ 
+ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \
+   $(srcdir)/vecprim.h $(srcdir)/vecir.h \
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gccgo-version.patch b/patches/gcc/linaro-4.6-2012.10/gccgo-version.patch
--- a/patches/gcc/linaro-4.6-2012.10/gccgo-version.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gccgo-version.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,61 @@
+# DP: Omit the subminor number from the go libdir
+
+--- a/gcc/go/Make-lang.in
++++ b/gcc/go/Make-lang.in
+@@ -223,13 +223,15 @@
+ go/go-backend.o: go/go-backend.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \
+ 	$(TM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(TARGET_H)
+ 
++short_version := $(shell echo $(version) | sed -r 's/([0-9]+\.[0-9]+).*/\1/')
++
+ go/go-lang.o: go/go-lang.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(OPTS_H) \
+ 		$(TREE_H) $(GIMPLE_H) $(GGC_H) $(TOPLEV_H) debug.h options.h \
+ 		$(FLAGS_H) convert.h $(DIAGNOSTIC_H) langhooks.h \
+ 		$(LANGHOOKS_DEF_H) $(EXCEPT_H) $(TARGET_H) $(GO_C_H) \
+ 		gt-go-go-lang.h gtype-go.h
+ 	$(COMPILER) $(ALL_COMPILERFLAGS) $(ALL_CPPFLAGS) \
+-	  -DDEFAULT_TARGET_VERSION=\"$(version)\" \
++	  -DDEFAULT_TARGET_VERSION=\"$(short_version)\" \
+ 	  -DDEFAULT_TARGET_MACHINE=\"$(target_noncanonical)\" \
+ 	  -c $< $(OUTPUT_OPTION)
+ 
+--- a/libgo/Makefile.in
++++ b/libgo/Makefile.in
+@@ -469,7 +469,7 @@
+ SUFFIXES = .c .go .gox .o .obj .lo .a
+ @LIBGO_IS_RTEMS_TRUE@subdirs = testsuite
+ SUBDIRS = ${subdirs}
+-gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
++short_version := $(shell sed -r 's/([0-9]+\.[0-9]+)\..*/\1/' $(top_srcdir)/../gcc/BASE-VER)
+ MAINT_CHARSET = latin1
+ mkinstalldirs = $(SHELL) $(toplevel_srcdir)/mkinstalldirs
+ PWD_COMMAND = $${PWDCMD-pwd}
+@@ -539,7 +539,7 @@
+ FLAGS_TO_PASS = $(AM_MAKEFLAGS)
+ toolexeclib_LTLIBRARIES = libgo.la
+ toolexeclib_LIBRARIES = libgobegin.a
+-toolexeclibgodir = $(toolexeclibdir)/go/$(gcc_version)/$(target_alias)
++toolexeclibgodir = $(toolexeclibdir)/go/$(short_version)
+ toolexeclibgo_DATA = \
+ 	asn1.gox \
+ 	big.gox \
+--- a/libgo/Makefile.am
++++ b/libgo/Makefile.am
+@@ -15,7 +15,7 @@
+ 
+ SUBDIRS = ${subdirs}
+ 
+-gcc_version := $(shell cat $(top_srcdir)/../gcc/BASE-VER)
++short_version := $(shell sed -r 's/([0-9]+\.[0-9]+)\..*/\1/' $(top_srcdir)/../gcc/BASE-VER)
+ 
+ MAINT_CHARSET = latin1
+ 
+@@ -97,7 +97,7 @@
+ toolexeclib_LTLIBRARIES = libgo.la
+ toolexeclib_LIBRARIES = libgobegin.a
+ 
+-toolexeclibgodir = $(toolexeclibdir)/go/$(gcc_version)/$(target_alias)
++toolexeclibgodir = $(toolexeclibdir)/go/$(short_version)
+ 
+ toolexeclibgo_DATA = \
+ 	asn1.gox \
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-hash-style-both.patch b/patches/gcc/linaro-4.6-2012.10/gcc-hash-style-both.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-hash-style-both.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-hash-style-both.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,134 @@
+# DP: Link using --hash-style=both (alpha, amd64, armel, armhf, ia64, i386, powerpc, ppc64, s390, sparc)
+
+2006-07-11  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/i386/linux.h (LINK_SPEC): Add --hash-style=both.
+	* config/i386/linux64.h (LINK_SPEC): Likewise.
+	* config/rs6000/sysv4.h (LINK_OS_LINUX_SPEC): Likewise.
+	* config/rs6000/linux64.h (LINK_OS_LINUX_SPEC32,
+	LINK_OS_LINUX_SPEC64): Likewise.
+	* config/s390/linux.h (LINK_SPEC): Likewise.
+	* config/ia64/linux.h (LINK_SPEC): Likewise.
+	* config/sparc/linux.h (LINK_SPEC): Likewise.
+	* config/sparc/linux64.h (LINK_SPEC, LINK_ARCH32_SPEC,
+	LINK_ARCH64_SPEC): Likewise.
+	* config/alpha/linux-elf.h (LINK_SPEC): Likewise.
+
+2009-12-21  Matthias Klose  <doko@ubuntu.com>
+
+	* config/arm/linux-elf.h (LINK_SPEC): Add --hash-style=both.
+	
+---
+ gcc/config/alpha/linux-elf.h |    2 +-
+ gcc/config/i386/linux.h      |    2 +-
+ gcc/config/i386/linux64.h    |    2 +-
+ gcc/config/ia64/linux.h      |    2 +-
+ gcc/config/rs6000/linux64.h  |    4 ++--
+ gcc/config/rs6000/sysv4.h    |    2 +-
+ gcc/config/s390/linux.h      |    2 +-
+ gcc/config/sparc/linux.h     |    2 +-
+ 8 files changed, 9 insertions(+), 9 deletions(-)
+
+--- a/gcc/config/alpha/linux-elf.h
++++ b/gcc/config/alpha/linux-elf.h
+@@ -41,7 +41,7 @@
+ 
+ #define ELF_DYNAMIC_LINKER	LINUX_DYNAMIC_LINKER
+ 
+-#define LINK_SPEC "-m elf64alpha %{G*} %{relax:-relax}		\
++#define LINK_SPEC "-m elf64alpha --hash-style=both %{G*} %{relax:-relax}	\
+   %{O*:-O3} %{!O*:-O1}						\
+   %{shared:-shared}						\
+   %{!shared:							\
+--- a/gcc/config/i386/linux.h
++++ b/gcc/config/i386/linux.h
+@@ -104,7 +104,7 @@
+   { "dynamic_linker", LINUX_DYNAMIC_LINKER }
+ 
+ #undef	LINK_SPEC
+-#define LINK_SPEC "-m %(link_emulation) %{shared:-shared} \
++#define LINK_SPEC "-m %(link_emulation) --hash-style=both %{shared:-shared} \
+   %{!shared: \
+     %{!static: \
+       %{rdynamic:-export-dynamic} \
+--- a/gcc/config/i386/linux64.h
++++ b/gcc/config/i386/linux64.h
+@@ -78,7 +78,7 @@
+  %{!mno-sse2avx:%{mavx:-msse2avx}} %{msse2avx:%{!mavx:-msse2avx}}"
+ 
+ #undef	LINK_SPEC
+-#define LINK_SPEC "%{" SPEC_64 ":-m elf_x86_64} %{" SPEC_32 ":-m elf_i386} \
++#define LINK_SPEC "%{" SPEC_64 ":-m elf_x86_64} %{" SPEC_32 ":-m elf_i386} --hash-style=both \
+   %{shared:-shared} \
+   %{!shared: \
+     %{!static: \
+--- a/gcc/config/ia64/linux.h
++++ b/gcc/config/ia64/linux.h
+@@ -64,7 +64,7 @@
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux-ia64.so.2"
+ 
+ #undef LINK_SPEC
+-#define LINK_SPEC "\
++#define LINK_SPEC " --hash-style=both \
+   %{shared:-shared} \
+   %{!shared: \
+     %{!static: \
+--- a/gcc/config/rs6000/linux64.h
++++ b/gcc/config/rs6000/linux64.h
+@@ -389,11 +389,11 @@
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER64, UCLIBC_DYNAMIC_LINKER64)
+ 
+ 
+-#define LINK_OS_LINUX_SPEC32 "-m elf32ppclinux %{!shared: %{!static: \
++#define LINK_OS_LINUX_SPEC32 "-m elf32ppclinux --hash-style=both %{!shared: %{!static: \
+   %{rdynamic:-export-dynamic} \
+   -dynamic-linker " LINUX_DYNAMIC_LINKER32 "}}"
+ 
+-#define LINK_OS_LINUX_SPEC64 "-m elf64ppc %{!shared: %{!static: \
++#define LINK_OS_LINUX_SPEC64 "-m elf64ppc --hash-style=both %{!shared: %{!static: \
+   %{rdynamic:-export-dynamic} \
+   -dynamic-linker " LINUX_DYNAMIC_LINKER64 "}}"
+ 
+--- a/gcc/config/rs6000/sysv4.h
++++ b/gcc/config/rs6000/sysv4.h
+@@ -830,7 +830,7 @@
+ #define LINUX_DYNAMIC_LINKER \
+   CHOOSE_DYNAMIC_LINKER (GLIBC_DYNAMIC_LINKER, UCLIBC_DYNAMIC_LINKER)
+ 
+-#define LINK_OS_LINUX_SPEC "-m elf32ppclinux %{!shared: %{!static: \
++#define LINK_OS_LINUX_SPEC "-m elf32ppclinux --hash-style=both %{!shared: %{!static: \
+   %{rdynamic:-export-dynamic} \
+   -dynamic-linker " LINUX_DYNAMIC_LINKER "}}"
+ 
+--- a/gcc/config/s390/linux.h
++++ b/gcc/config/s390/linux.h
+@@ -77,7 +77,7 @@
+ 
+ #undef  LINK_SPEC
+ #define LINK_SPEC \
+-  "%{m31:-m elf_s390}%{m64:-m elf64_s390} \
++  "%{m31:-m elf_s390}%{m64:-m elf64_s390} --hash-style=both \
+    %{shared:-shared} \
+    %{!shared: \
+       %{static:-static} \
+--- a/gcc/config/sparc/linux.h
++++ b/gcc/config/sparc/linux.h
+@@ -74,7 +74,7 @@
+ #define GLIBC_DYNAMIC_LINKER "/lib/ld-linux.so.2"
+ 
+ #undef  LINK_SPEC
+-#define LINK_SPEC "-m elf32_sparc -Y P,/usr/lib %{shared:-shared} \
++#define LINK_SPEC "-m elf32_sparc --hash-style=both -Y P,/usr/lib %{shared:-shared} \
+   %{!mno-relax:%{!r:-relax}} \
+   %{!shared: \
+     %{!static: \
+--- a/gcc/config/arm/linux-elf.h
++++ b/gcc/config/arm/linux-elf.h
+@@ -71,6 +71,7 @@
+    %{rdynamic:-export-dynamic} \
+    -dynamic-linker " LINUX_DYNAMIC_LINKER " \
+    -X \
++   --hash-style=both \
+    %{mbig-endian:-EB} %{mlittle-endian:-EL}" \
+    SUBTARGET_EXTRA_LINK_SPEC
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-ice-hack.patch b/patches/gcc/linaro-4.6-2012.10/gcc-ice-hack.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-ice-hack.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-ice-hack.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,311 @@
+# DP: Retry the build on an ice, save the calling options and preprocessed
+# DP: source when the ice is reproducible.
+
+2004-01-23  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.c (execute): Don't free first string early, but at the end
+	of the function.  Call retry_ice if compiler exited with
+	ICE_EXIT_CODE.
+	(retry_ice): New function.
+	* diagnostic.c (diagnostic_count_diagnostic,
+	diagnostic_action_after_output, error_recursion): Exit with
+	ICE_EXIT_CODE instead of FATAL_EXIT_CODE.
+
+#--- a/gcc/Makefile.in
+#+++ b/gcc/Makefile.in
+#@@ -181,6 +181,8 @@ SYSCALLS.c.X-warn = -Wno-strict-prototypes -Wno-error
+# dfp.o-warn = -Wno-error
+# # mips-tfile.c contains -Wcast-qual warnings.
+# mips-tfile.o-warn = -Wno-error
+#+# gcc-ice-hack
+#+gcc.o-warn = -Wno-error
+# 
+# # All warnings have to be shut off in stage1 if the compiler used then
+# # isn't gcc; configure determines that.  WARN_CFLAGS will be either
+--- a/gcc/gcc.c
++++ b/gcc/gcc.c
+@@ -250,6 +250,9 @@
+ #if defined(HAVE_TARGET_OBJECT_SUFFIX) || defined(HAVE_TARGET_EXECUTABLE_SUFFIX)
+ static const char *convert_filename (const char *, int, int);
+ #endif
++#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS))
++static void retry_ice (const char *prog, const char **argv);
++#endif
+ 
+ static const char *getenv_spec_function (int, const char **);
+ static const char *if_exists_spec_function (int, const char **);
+@@ -2639,7 +2642,7 @@
+ 	    }
+ 	}
+ 
+-      if (string != commands[i].prog)
++      if (i && string != commands[i].prog)
+ 	free (CONST_CAST (char *, string));
+     }
+ 
+@@ -2692,6 +2695,16 @@
+ 	else if (WIFEXITED (status)
+ 		 && WEXITSTATUS (status) >= MIN_FATAL_STATUS)
+ 	  {
++#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS))
++	    /* For ICEs in cc1, cc1obj, cc1plus see if it is
++	       reproducible or not.  */
++	    const char *p;
++	    if (WEXITSTATUS (status) == ICE_EXIT_CODE
++		&& i == 0
++		&& (p = strrchr (commands[0].argv[0], DIR_SEPARATOR))
++		&& ! strncmp (p + 1, "cc1", 3))
++	      retry_ice (commands[0].prog, commands[0].argv);
++#endif
+ 	    if (WEXITSTATUS (status) > greatest_status)
+ 	      greatest_status = WEXITSTATUS (status);
+ 	    ret_code = -1;
+@@ -2749,6 +2762,9 @@
+ 	  }
+       }
+ 
++    if (commands[0].argv[0] != commands[0].prog)
++      free (CONST_CAST (char *, commands[0].argv[0]));
++
+     return ret_code;
+   }
+ }
+@@ -5886,6 +5902,227 @@
+   switches[switchnum].validated = 1;
+ }
+ 
++#if !(defined (__MSDOS__) || defined (OS2) || defined (VMS))
++#define RETRY_ICE_ATTEMPTS 2
++
++static void
++retry_ice (const char *prog, const char **argv)
++{
++  int nargs, out_arg = -1, quiet = 0, attempt;
++  int pid, retries, sleep_interval;
++  const char **new_argv;
++  char *temp_filenames[RETRY_ICE_ATTEMPTS * 2 + 2];
++
++  if (gcc_input_filename == NULL || ! strcmp (gcc_input_filename, "-"))
++    return;
++
++  for (nargs = 0; argv[nargs] != NULL; ++nargs)
++    /* Only retry compiler ICEs, not preprocessor ones.  */
++    if (! strcmp (argv[nargs], "-E"))
++      return;
++    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')
++      {
++	if (out_arg == -1)
++	  out_arg = nargs;
++	else
++	  return;
++      }
++    /* If the compiler is going to output any time information,
++       it might varry between invocations.  */
++    else if (! strcmp (argv[nargs], "-quiet"))
++      quiet = 1;
++    else if (! strcmp (argv[nargs], "-ftime-report"))
++      return;
++
++  if (out_arg == -1 || !quiet)
++    return;
++
++  memset (temp_filenames, '\0', sizeof (temp_filenames));
++  new_argv = XALLOCAVEC (const char *, nargs + 3);
++  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));
++  new_argv[nargs++] = "-frandom-seed=0";
++  new_argv[nargs] = NULL;
++  if (new_argv[out_arg][2] == '\0')
++    new_argv[out_arg + 1] = "-";
++  else
++    new_argv[out_arg] = "-o-";
++
++  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS + 1; ++attempt)
++    {
++      int fd = -1;
++      int status;
++
++      temp_filenames[attempt * 2] = make_temp_file (".out");
++      temp_filenames[attempt * 2 + 1] = make_temp_file (".err");
++
++      if (attempt == RETRY_ICE_ATTEMPTS)
++        {
++	  int i;
++	  int fd1, fd2;
++	  struct stat st1, st2;
++	  size_t n, len;
++	  char *buf;
++
++	  buf = XNEWVEC (char, 8192);
++
++	  for (i = 0; i < 2; ++i)
++	    {
++	      fd1 = open (temp_filenames[i], O_RDONLY);
++	      fd2 = open (temp_filenames[2 + i], O_RDONLY);
++
++	      if (fd1 < 0 || fd2 < 0)
++		{
++		  i = -1;
++		  close (fd1);
++		  close (fd2);
++		  break;
++		}
++
++	      if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)
++		{
++		  i = -1;
++		  close (fd1);
++		  close (fd2);
++		  break;
++		}
++
++	      if (st1.st_size != st2.st_size)
++		{
++		  close (fd1);
++		  close (fd2);
++		  break;
++		}
++
++	      len = 0;
++	      for (n = st1.st_size; n; n -= len)
++		{
++		  len = n;
++		  if (len > 4096)
++		    len = 4096;
++
++		  if (read (fd1, buf, len) != (int) len
++		      || read (fd2, buf + 4096, len) != (int) len)
++		    {
++		      i = -1;
++		      break;
++		    }
++
++		  if (memcmp (buf, buf + 4096, len) != 0)
++		    break;
++		}
++
++	      close (fd1);
++	      close (fd2);
++
++	      if (n)
++		break;
++	    }
++
++	  free (buf);
++	  if (i == -1)
++	    break;
++
++	  if (i != 2)
++	    {
++	      fnotice (stderr, "The bug is not reproducible, so it is"
++			       " likely a hardware or OS problem.\n");
++	      break;
++	    }
++
++          fd = open (temp_filenames[attempt * 2], O_RDWR);
++	  if (fd < 0)
++	    break;
++	  write (fd, "//", 2);
++	  for (i = 0; i < nargs; i++)
++	    {
++	      write (fd, " ", 1);
++	      write (fd, new_argv[i], strlen (new_argv[i]));
++	    }
++	  write (fd, "\n", 1);
++	  new_argv[nargs] = "-E";
++	  new_argv[nargs + 1] = NULL;
++        }
++
++      /* Fork a subprocess; wait and retry if it fails.  */
++      sleep_interval = 1;
++      pid = -1;
++      for (retries = 0; retries < 4; retries++)
++	{
++	  pid = fork ();
++	  if (pid >= 0)
++	    break;
++	  sleep (sleep_interval);
++	  sleep_interval *= 2;
++	}
++
++      if (pid < 0)
++	break;
++      else if (pid == 0)
++	{
++	  if (attempt != RETRY_ICE_ATTEMPTS)
++	    fd = open (temp_filenames[attempt * 2], O_RDWR);
++	  if (fd < 0)
++	    exit (-1);
++	  if (fd != 1)
++	    {
++	      close (1);
++	      dup (fd);
++	      close (fd);
++	    }
++
++	  fd = open (temp_filenames[attempt * 2 + 1], O_RDWR);
++	  if (fd < 0)
++	    exit (-1);
++	  if (fd != 2)
++	    {
++	      close (2);
++	      dup (fd);
++	      close (fd);
++	    }
++
++	  if (prog == new_argv[0])
++	    execvp (prog, CONST_CAST2 (char *const *, const char **, new_argv));
++	  else
++	    execv (new_argv[0], CONST_CAST2 (char *const *, const char **, new_argv));
++	  exit (-1);
++	}
++
++      if (waitpid (pid, &status, 0) < 0)
++	break;
++
++      if (attempt < RETRY_ICE_ATTEMPTS
++	  && (! WIFEXITED (status) || WEXITSTATUS (status) != ICE_EXIT_CODE))
++	{
++	  fnotice (stderr, "The bug is not reproducible, so it is"
++			   " likely a hardware or OS problem.\n");
++	  break;
++	}
++      else if (attempt == RETRY_ICE_ATTEMPTS)
++	{
++	  close (fd);
++	  if (WIFEXITED (status)
++	      && WEXITSTATUS (status) == SUCCESS_EXIT_CODE)
++	    {
++	      fnotice (stderr, "Preprocessed source stored into %s file,"
++			       " please attach this to your bugreport.\n",
++		       temp_filenames[attempt * 2]);
++	      /* Make sure it is not deleted.  */
++	      free (temp_filenames[attempt * 2]);
++	      temp_filenames[attempt * 2] = NULL;
++	      break;
++	    }
++	}
++    }
++
++  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS * 2 + 2; attempt++)
++    if (temp_filenames[attempt])
++      {
++	unlink (temp_filenames[attempt]);
++	free (temp_filenames[attempt]);
++      }
++}
++#endif
++
+ /* Search for a file named NAME trying various prefixes including the
+    user's -B prefix and some standard ones.
+    Return the absolute file name found.  If nothing is found, return NAME.  */
+--- a/gcc/diagnostic.c
++++ b/gcc/diagnostic.c
+@@ -247,7 +247,7 @@
+ 	real_abort ();
+       diagnostic_finish (context);
+       fnotice (stderr, "compilation terminated.\n");
+-      exit (FATAL_EXIT_CODE);
++      exit (ICE_EXIT_CODE);
+ 
+     default:
+       gcc_unreachable ();
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-multiarch.patch b/patches/gcc/linaro-4.6-2012.10/gcc-multiarch.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-multiarch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-multiarch.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,28 @@
+# DP: Add multiarch support to GCC (chunks not yet applied upstream).
+
+--- a/gcc/config/sh/t-linux
++++ b/gcc/config/sh/t-linux
+@@ -6,3 +6,5 @@
+ MULTILIB_MATCHES = 
+ 
+ EXTRA_MULTILIB_PARTS= crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
++
++MULTILIB_OSDIRNAMES = sh4-linux-gnu:sh4-linux-gnu sh4_nofpu-linux-gnu:sh4-linux-gnu
+--- /dev/null
++++ b/gcc/config/s390/t-linux
+@@ -0,0 +1 @@
++MULTIARCH_DIRNAME = s390-linux-gnu
+--- a/libstdc++-v3/python/hook.in
++++ b/libstdc++-v3/python/hook.in
+@@ -47,7 +47,10 @@
+     libdir = libdir[len (prefix):]
+ 
+     # Compute the ".."s needed to get from libdir to the prefix.
+-    dotdots = ('..' + os.sep) * len (libdir.split (os.sep))
++    backdirs = len (libdir.split (os.sep))
++    if not os.path.basename(os.path.dirname(__file__)).startswith('lib'):
++        backdirs += 1 # multiarch subdir
++    dotdots = ('..' + os.sep) * backdirs
+ 
+     objfile = gdb.current_objfile ().filename
+     dir_ = os.path.join (os.path.dirname (objfile), dotdots, pythondir)
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-multiarch-upstream.patch b/patches/gcc/linaro-4.6-2012.10/gcc-multiarch-upstream.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-multiarch-upstream.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-multiarch-upstream.patch	2013-01-31 18:02:24.059973728 -0300
@@ -0,0 +1,782 @@
+# DP: Add multiarch support to GCC (upstreamed chunks).
+
+2012-11-20  Matthias Klose  <doko@ubuntu.com>
+
+	* doc/invoke.texi: Document -print-multiarch.
+	* doc/install.texi: Document --enable-multiarch.
+	* doc/fragments.texi: Document MULTILIB_OSDIRNAMES, MULTIARCH_DIRNAME.
+	* configure.ac: Add --enable-multiarch option.
+	Substitute with_cpu, with_float.
+	* configure: Regenerate.
+	* Makefile.in (s-mlib): Pass MULTIARCH_DIRNAME to genmultilib.
+	enable_multiarch, with_cpu, with_float: New macros.
+	if_multiarch: New macro, define in terms of enable_multiarch.
+	* genmultilib: Add new argument for the multiarch name.
+	* gcc.c (multiarch_dir): Define.
+	(for_each_path): Search for multiarch suffixes.
+	(driver_handle_option): Handle multiarch option.
+	(do_spec_1): Pass -imultiarch if defined.
+	(main): Print multiarch.
+	(set_multilib_dir): Separate multilib and multiarch names
+	from multilib_select.
+	(print_multilib_info): Ignore multiarch names in multilib_select.
+	* incpath.c (add_standard_paths): Search the multiarch include dirs.
+	* cppdefault.h (default_include): Document multiarch in multilib
+	member.
+	* cppdefault.c: [LOCAL_INCLUDE_DIR, STANDARD_INCLUDE_DIR] Add an
+        include directory for multiarch directories.
+	* common.opt: New options --print-multiarch and -imultilib.
+
+	* config.gcc <i[34567]86-*-gnu*> (tmake_file): Include i386/t-gnu.
+	<i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu> (tmake_file):
+	Include i386/t-kfreebsd.
+	* config/i386/t-linux64: Add multiarch names in
+	MULTILIB_OSDIRNAMES, define MULTIARCH_DIRNAME.
+	* config/i386/t-linux: Define MULTIARCH_DIRNAME.
+	* config/i386/t-gnu: New file.
+	* config/i386/t-kfreebsd: Likewise.
+
+	* config/sparc/t-linux64: Add multiarch names in MULTILIB_OSDIRNAMES.
+	* config/sparc/t-linux: Define MULTIARCH_DIRNAME.
+
+	* config/pa/t-linux, config/pa/t-linux64: Define MULTIARCH_DIRNAME.
+
+	* config/mips/t-linux64: Add multiarch names in MULTILIB_OSDIRNAMES.
+
+	* config/arm/t-linux-eabi: Define MULTIARCH_DIRNAME for linux target.
+
+	* config/rs6000/t-linux64: Add multiarch names in MULTILIB_OSDIRNAMES.
+	* config/rs6000/t-linux: New file; define MULTIARCH_DIRNAME.
+	* config/rs6000/t-fprules (SOFT_FLOAT_CPUS): New macro. Add e300c2
+	to the list.
+	(MULTILIB_MATCHES_FLOAT): Define in terms of SOFT_FLOAT_CPUS.
+	* config/rs6000/t-spe: Define MULTIARCH_DIRNAME.
+	* config.gcc <powerpc-*-linux* | powerpc64-*-linux*> (tmake_file):
+	Include rs6000/t-linux for 32bit non-biarch configurations.
+
+--- a/gcc/Makefile.in	(Revision 193700)
++++ b/gcc/Makefile.in	(Arbeitskopie)
+@@ -514,6 +514,21 @@
+ extra_opt_files=@extra_opt_files@
+ host_hook_obj=@out_host_hook_obj@
+ 
++# Multiarch support
++enable_multiarch = @enable_multiarch@
++with_cpu = @with_cpu@
++with_float = @with_float@
++ifeq ($(enable_multiarch),yes)
++  if_multiarch = $(1)
++else
++  ifeq ($(enable_multiarch),auto)
++    # SYSTEM_HEADER_DIR is makefile syntax, cannot be evaluated in configure.ac
++    if_multiarch = $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib/*/crti.o),$(1))
++  else
++    if_multiarch =
++  endif
++endif
++
+ # ------------------------
+ # Installation directories
+ # ------------------------
+@@ -1941,10 +1956,11 @@
+ 	    "$(MULTILIB_EXTRA_OPTS)" \
+ 	    "$(MULTILIB_EXCLUSIONS)" \
+ 	    "$(MULTILIB_OSDIRNAMES)" \
++	    "$(MULTIARCH_DIRNAME)" \
+ 	    "@enable_multilib@" \
+ 	    > tmp-mlib.h; \
+ 	else \
+-	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' no \
++	  $(SHELL) $(srcdir)/genmultilib '' '' '' '' '' '' '' "$(MULTIARCH_DIRNAME)" no \
+ 	    > tmp-mlib.h; \
+ 	fi
+ 	$(SHELL) $(srcdir)/../move-if-change tmp-mlib.h multilib.h
+--- a/gcc/config.gcc	(Revision 193700)
++++ b/gcc/config.gcc	(Arbeitskopie)
+@@ -2172,6 +2172,7 @@
+ 		;;
+ 	    *)
+ 		tm_file="${tm_file} rs6000/linux.h glibc-stdint.h"
++		tmake_file="$tmake_file rs6000/t-linux"
+ 		;;
+ 	esac
+ 	tmake_file="${tmake_file} t-slibgcc-libgcc rs6000/t-fprules-softfp soft-fp/t-softfp"
+@@ -3659,11 +3660,15 @@
+ 	i[34567]86-*-darwin* | x86_64-*-darwin*)
+ 		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
+ 		;;
+-	i[34567]86-*-linux* | x86_64-*-linux* | \
+-	  i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu | \
+-	  i[34567]86-*-gnu*)
++	i[34567]86-*-linux* | x86_64-*-linux*)
+ 		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp i386/t-linux"
+ 		;;
++	i[34567]86-*-kfreebsd*-gnu | x86_64-*-kfreebsd*-gnu)
++		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp i386/t-linux i386/t-kfreebsd"
++		;;
++	i[34567]86-*-gnu*)
++		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp i386/t-linux i386/t-gnu"
++		;;
+ 	i[34567]86-*-solaris2*)
+ 		tmake_file="${tmake_file} i386/t-fprules-softfp soft-fp/t-softfp"
+ 		;;
+--- a/gcc/config/alpha/t-linux	(Revision 193700)
++++ b/gcc/config/alpha/t-linux	(Arbeitskopie)
+@@ -1 +1,2 @@
++MULTIARCH_DIRNAME = $(call if_multiarch,alpha-linux-gnu)
+ SHLIB_MAPFILES += $(srcdir)/config/alpha/libgcc-alpha-ldbl.ver
+--- a/gcc/config/sparc/t-linux64	(Revision 193700)
++++ b/gcc/config/sparc/t-linux64	(Arbeitskopie)
+@@ -1,5 +1,5 @@
+ # Copyright (C) 1998, 1999, 2000, 2001, 2002, 2004,
+-# 2006, 2010 Free Software Foundation, Inc.
++# 2006, 2010, 2012 Free Software Foundation, Inc.
+ #
+ # This file is part of GCC.
+ #
+@@ -26,7 +26,8 @@
+ 
+ MULTILIB_OPTIONS = m64/m32
+ MULTILIB_DIRNAMES = 64 32
+-MULTILIB_OSDIRNAMES = ../lib64 $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)
++MULTILIB_OSDIRNAMES = ../lib64$(call if_multiarch,:sparc64-linux-gnu)
++MULTILIB_OSDIRNAMES += $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:sparc-linux-gnu)
+ 
+ LIBGCC = stmp-multilib
+ INSTALL_LIBGCC = install-multilib
+--- a/gcc/config/sparc/t-linux	(Revision 193700)
++++ b/gcc/config/sparc/t-linux	(Arbeitskopie)
+@@ -3,3 +3,5 @@
+ # Avoid the t-linux version file.
+ SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \
+ 		 $(srcdir)/config/sparc/libgcc-sparc-glibc.ver
++
++MULTIARCH_DIRNAME = $(call if_multiarch,sparc-linux-gnu)
+--- a/gcc/config/s390/t-linux64	(Revision 193700)
++++ b/gcc/config/s390/t-linux64	(Arbeitskopie)
+@@ -7,4 +7,5 @@
+ 
+ MULTILIB_OPTIONS = m64/m31
+ MULTILIB_DIRNAMES = 64 32
+-MULTILIB_OSDIRNAMES = ../lib64 $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)
++MULTILIB_OSDIRNAMES = ../lib64$(call if_multiarch,:s390x-linux-gnu)
++MULTILIB_OSDIRNAMES += $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:s390-linux-gnu)
+--- a/gcc/config/i386/t-gnu	(Revision 0)
++++ b/gcc/config/i386/t-gnu	(Arbeitskopie)
+@@ -0,0 +1 @@
++MULTIARCH_DIRNAME = $(call if_multiarch,i386-gnu)
+--- a/gcc/config/i386/t-linux	(Revision 193700)
++++ b/gcc/config/i386/t-linux	(Arbeitskopie)
+@@ -3,3 +3,7 @@
+ # t-slibgcc-elf-ver and t-linux
+ SHLIB_MAPFILES = $(srcdir)/libgcc-std.ver \
+ 		 $(srcdir)/config/i386/libgcc-glibc.ver
++
++ifneq (,$(findstring -linux,$(target)))
++MULTIARCH_DIRNAME = $(call if_multiarch,i386-linux-gnu)
++endif
+--- a/gcc/config/i386/t-kfreebsd	(Revision 0)
++++ b/gcc/config/i386/t-kfreebsd	(Arbeitskopie)
+@@ -0,0 +1,5 @@
++MULTIARCH_DIRNAME = $(call if_multiarch,i386-kfreebsd-gnu)
++
++# MULTILIB_OSDIRNAMES are set in t-linux64.
++KFREEBSD_OS = $(filter kfreebsd%, $(word 3, $(subst -, ,$(target))))
++MULTILIB_OSDIRNAMES := $(subst linux,$(KFREEBSD_OS),$(MULTILIB_OSDIRNAMES))
+--- a/gcc/config/i386/t-linux64	(Revision 193700)
++++ b/gcc/config/i386/t-linux64	(Arbeitskopie)
+@@ -25,7 +25,8 @@
+ 
+ MULTILIB_OPTIONS = m64/m32
+ MULTILIB_DIRNAMES = 64 32 
+-MULTILIB_OSDIRNAMES = ../lib64 $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)
++MULTILIB_OSDIRNAMES = ../lib64$(call if_multiarch,:x86_64-linux-gnu) \
++	$(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:i386-linux-gnu)
+ 
+ LIBGCC = stmp-multilib
+ INSTALL_LIBGCC = install-multilib
+--- a/gcc/config/rs6000/t-fprules	(Revision 193700)
++++ b/gcc/config/rs6000/t-fprules	(Arbeitskopie)
+@@ -16,17 +16,8 @@
+ # along with GCC; see the file COPYING3.  If not see
+ # <http://www.gnu.org/licenses/>.
+ 
+-MULTILIB_MATCHES_FLOAT	= msoft-float=mcpu?401 \
+-			  msoft-float=mcpu?403 \
+-			  msoft-float=mcpu?405 \
+-			  msoft-float=mcpu?440 \
+-			  msoft-float=mcpu?464 \
+-			  msoft-float=mcpu?476 \
+-			  msoft-float=mcpu?ec603e \
+-			  msoft-float=mcpu?801 \
+-			  msoft-float=mcpu?821 \
+-			  msoft-float=mcpu?823 \
+-			  msoft-float=mcpu?860
++SOFT_FLOAT_CPUS = e300c2 401 403 405 440 464 476 ec603e 801 821 823 860
++MULTILIB_MATCHES_FLOAT = $(foreach cpu, $(SOFT_FLOAT_CPUS), msoft-float=mcpu?$(cpu))
+ 
+ # Build the libraries for both hard and soft floating point by default
+ 
+--- a/gcc/config/rs6000/t-spe	(Revision 193700)
++++ b/gcc/config/rs6000/t-spe	(Arbeitskopie)
+@@ -84,3 +84,7 @@
+ 			  mabi=altivec/mlittle \
+ 			  maltivec/mlittle \
+ 			  maltivec/mabi=altivec/mlittle
++
++ifneq (,$(findstring linux, $(target)))
++MULTIARCH_DIRNAME = powerpc-linux-gnuspe$(if $(findstring rs6000/e500-double.h, $(tm_file)),,v1)
++endif
+--- a/gcc/config/rs6000/t-linux	(Revision 0)
++++ b/gcc/config/rs6000/t-linux	(Arbeitskopie)
+@@ -0,0 +1,5 @@
++# do not define the multiarch name if configured for a soft-float cpu
++# or soft-float.
++ifeq (,$(filter $(with_cpu),$(SOFT_FLOAT_CPUS))$(findstring soft,$(with_float)))
++MULTIARCH_DIRNAME = powerpc-linux-gnu
++endif
+--- a/gcc/config/rs6000/t-linux64	(Revision 193700)
++++ b/gcc/config/rs6000/t-linux64	(Arbeitskopie)
+@@ -36,7 +36,9 @@
+ MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
+ MULTILIB_EXCEPTIONS     = m64/msoft-float
+ MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
+-MULTILIB_OSDIRNAMES	= ../lib64 $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib) nof
++MULTILIB_OSDIRNAMES	= ../lib64$(call if_multiarch,:powerpc64-linux-gnu)
++MULTILIB_OSDIRNAMES    += $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:powerpc-linux-gnu)
++MULTILIB_OSDIRNAMES    += nof
+ MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
+ 
+ softfp_wrap_start := '\#ifndef __powerpc64__'
+--- a/gcc/config/m68k/t-linux	(Revision 193700)
++++ b/gcc/config/m68k/t-linux	(Arbeitskopie)
+@@ -21,6 +21,10 @@
+ # Only include multilibs for 680x0 CPUs with an MMU.
+ M68K_MLIB_CPU += && (CPU ~ "^m680") && (FLAGS ~ "FL_MMU")
+ 
++ifeq ($(M68K_ARCH),m68k)
++MULTIARCH_DIRNAME = $(call if_multiarch,m68k-linux-gnu)
++endif
++
+ # This rule uses MULTILIB_MATCHES to generate a definition of
+ # SYSROOT_SUFFIX_SPEC.
+ sysroot-suffix.h: $(srcdir)/config/m68k/print-sysroot-suffix.sh
+--- a/gcc/config/mips/t-linux64	(Revision 193700)
++++ b/gcc/config/mips/t-linux64	(Arbeitskopie)
+@@ -1,4 +1,4 @@
+-# Copyright (C) 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
++# Copyright (C) 2003, 2004, 2005, 2006, 2012 Free Software Foundation, Inc.
+ #
+ # This file is part of GCC.
+ #
+@@ -18,7 +18,12 @@
+ 
+ MULTILIB_OPTIONS = mabi=n32/mabi=32/mabi=64
+ MULTILIB_DIRNAMES = n32 32 64
+-MULTILIB_OSDIRNAMES = ../lib32 ../lib ../lib64
++MIPS_EL = $(if $(filter %el, $(firstword $(subst -, ,$(target)))),el)
++MIPS_SOFT = $(if $(strip $(filter MASK_SOFT_FLOAT_ABI, $(target_cpu_default)) $(filter soft, $(with_float))),soft)
++MULTILIB_OSDIRNAMES = \
++	../lib32$(call if_multiarch,:mips64$(MIPS_EL)-linux-gnuabin32$(MIPS_SOFT)) \
++	../lib$(call if_multiarch,:mips$(MIPS_EL)-linux-gnu$(MIPS_SOFT)) \
++	../lib64$(call if_multiarch,:mips64$(MIPS_EL)-linux-gnuabi64$(MIPS_SOFT))
+ 
+ EXTRA_MULTILIB_PARTS=crtbegin.o crtend.o crtbeginS.o crtendS.o crtbeginT.o
+ 
+--- a/gcc/config/pa/t-linux	(Revision 193700)
++++ b/gcc/config/pa/t-linux	(Arbeitskopie)
+@@ -35,3 +35,5 @@
+ 
+ # Compile crtbeginS.o and crtendS.o as PIC.
+ CRTSTUFF_T_CFLAGS_S = -fPIC
++
++MULTIARCH_DIRNAME = $(call if_multiarch,hppa-linux-gnu)
+--- a/gcc/config/pa/t-linux64	(Revision 193700)
++++ b/gcc/config/pa/t-linux64	(Arbeitskopie)
+@@ -30,3 +30,5 @@
+ 
+ # Compile libgcc2.a as PIC.
+ TARGET_LIBGCC2_CFLAGS = -fPIC -Dpa64=1 -DELF=1
++
++MULTIARCH_DIRNAME = $(call if_multiarch,hppa-linux-gnu)
+--- a/gcc/config/ia64/t-glibc	(Revision 193700)
++++ b/gcc/config/ia64/t-glibc	(Arbeitskopie)
+@@ -3,3 +3,5 @@
+   $(srcdir)/unwind-compat.c
+ 
+ SHLIB_MAPFILES += $(srcdir)/config/ia64/libgcc-glibc.ver
++
++MULTIARCH_DIRNAME = $(call if_multiarch,ia64-linux-gnu)
+--- a/gcc/config/arm/t-linux-eabi	(Revision 193700)
++++ b/gcc/config/arm/t-linux-eabi	(Arbeitskopie)
+@@ -1,4 +1,4 @@
+-# Copyright (C) 2005, 2009, 2010 Free Software Foundation, Inc.
++# Copyright (C) 2005, 2009, 2010, 2012 Free Software Foundation, Inc.
+ #
+ # This file is part of GCC.
+ #
+@@ -28,6 +28,11 @@
+ #MULTILIB_DIRNAMES    += fa606te fa626te fmp626 fa726te
+ #MULTILIB_EXCEPTIONS  += *mthumb/*mcpu=fa606te *mthumb/*mcpu=fa626te *mthumb/*mcpu=fmp626 *mthumb/*mcpu=fa726te*
+ 
++ifneq (,$(findstring gnueabi,$(target)))
++ARM_EB = $(if $(findstring TARGET_BIG_ENDIAN_DEFAULT=1, $(tm_defines)),eb)
++MULTIARCH_DIRNAME = $(call if_multiarch,arm$(ARM_EB)-linux-gnueabi$(if $(filter hard,$(with_float)),hf))
++endif
++
+ # Use a version of div0 which raises SIGFPE, and a special __clear_cache.
+ LIB1ASMFUNCS := $(filter-out _dvmd_tls,$(LIB1ASMFUNCS)) _dvmd_lnx _clear_cache
+ 
+--- a/gcc/incpath.c	(Revision 193700)
++++ b/gcc/incpath.c	(Arbeitskopie)
+@@ -150,8 +150,14 @@
+ 	      if (!strncmp (p->fname, cpp_GCC_INCLUDE_DIR, len))
+ 		{
+ 		  char *str = concat (iprefix, p->fname + len, NULL);
+-		  if (p->multilib && imultilib)
++		  if (p->multilib == 1 && imultilib)
+ 		    str = concat (str, dir_separator_str, imultilib, NULL);
++		  else if (p->multilib == 2)
++		    {
++		      if (!imultiarch)
++			continue;
++		      str = concat (str, dir_separator_str, imultiarch, NULL);
++		    }
+ 		  add_path (str, SYSTEM, p->cxx_aware, false);
+ 		}
+ 	    }
+@@ -195,8 +201,14 @@
+ 	  else
+ 	    str = update_path (p->fname, p->component);
+ 
+-	  if (p->multilib && imultilib)
++	  if (p->multilib == 1 && imultilib)
+ 	    str = concat (str, dir_separator_str, imultilib, NULL);
++	  else if (p->multilib == 2)
++	    {
++	      if (!imultiarch)
++		continue;
++	      str = concat (str, dir_separator_str, imultiarch, NULL);
++	    }
+ 
+ 	  add_path (str, SYSTEM, p->cxx_aware, false);
+ 	}
+--- a/gcc/configure	(Revision 193700)
++++ b/gcc/configure	(Arbeitskopie)
+@@ -762,6 +762,9 @@
+ enable_shared
+ enable_fixed_point
+ enable_decimal_float
++with_float
++with_cpu
++enable_multiarch
+ enable_multilib
+ ENABLE_BUILD_WITH_CXX
+ coverage_flags
+@@ -871,6 +874,7 @@
+ enable_build_with_cxx
+ with_stabs
+ enable_multilib
++enable_multiarch
+ enable___cxa_atexit
+ enable_decimal_float
+ enable_fixed_point
+@@ -1572,6 +1576,7 @@
+   --enable-gather-detailed-mem-stats         enable detailed memory allocation stats gathering
+   --enable-build-with-cxx build with C++ compiler instead of C compiler
+   --enable-multilib       enable library support for multiple ABIs
++  --enable-multiarch      enable support for multiarch paths
+   --enable-__cxa_atexit   enable __cxa_atexit for C++
+   --enable-decimal-float={no,yes,bid,dpd}
+ 			enable decimal float extension to C.  Selecting 'bid'
+@@ -6874,6 +6879,37 @@
+ 
+ 
+ 
++# Determine whether or not multiarch is enabled.
++# Check whether --enable-multiarch was given.
++if test "${enable_multiarch+set}" = set; then :
++  enableval=$enable_multiarch; case "${enableval}" in
++yes|no|auto) enable_multiarch=$enableval;;
++*) as_fn_error "bad value ${enableval} given for --enable-multiarch option" "$LINENO" 5 ;;
++esac
++else
++  enable_multiarch=auto
++fi
++
++if test x${enable_multiarch} = xauto; then
++  if test x${with_native_system_header_dir} != x; then
++    ma_msg_suffix=", disabled auto check (configured with --native-system-header-dir)"
++    enable_multiarch=no
++  fi
++  if test x$host != x$target && test "x$with_sysroot" = x; then
++    ma_msg_suffix=", disabled auto check (cross build configured without --with-sysroot)"
++    enable_multiarch=no
++  fi
++fi
++{ $as_echo "$as_me:${as_lineno-$LINENO}: checking for multiarch configuration" >&5
++$as_echo_n "checking for multiarch configuration... " >&6; }
++
++{ $as_echo "$as_me:${as_lineno-$LINENO}: result: $enable_multiarch$ma_msg_suffix" >&5
++$as_echo "$enable_multiarch$ma_msg_suffix" >&6; }
++
++# needed for setting the multiarch name for soft-float/hard-float ABIs
++
++
++
+ # Enable __cxa_atexit for C++.
+ # Check whether --enable-__cxa_atexit was given.
+ if test "${enable___cxa_atexit+set}" = set; then :
+@@ -17495,7 +17531,7 @@
+   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+   lt_status=$lt_dlunknown
+   cat > conftest.$ac_ext <<_LT_EOF
+-#line 17499 "configure"
++#line 17535 "configure"
+ #include "confdefs.h"
+ 
+ #if HAVE_DLFCN_H
+@@ -17601,7 +17637,7 @@
+   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2
+   lt_status=$lt_dlunknown
+   cat > conftest.$ac_ext <<_LT_EOF
+-#line 17605 "configure"
++#line 17641 "configure"
+ #include "confdefs.h"
+ 
+ #if HAVE_DLFCN_H
+--- a/gcc/cppdefault.c	(Revision 193700)
++++ b/gcc/cppdefault.c	(Arbeitskopie)
+@@ -64,6 +64,7 @@
+ #endif
+ #ifdef LOCAL_INCLUDE_DIR
+     /* /usr/local/include comes before the fixincluded header files.  */
++    { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 2 },
+     { LOCAL_INCLUDE_DIR, 0, 0, 1, 1, 0 },
+ #endif
+ #ifdef PREFIX_INCLUDE_DIR
+@@ -95,6 +96,7 @@
+ #endif
+ #ifdef STANDARD_INCLUDE_DIR
+     /* /usr/include comes dead last.  */
++    { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0, 1, 2 },
+     { STANDARD_INCLUDE_DIR, STANDARD_INCLUDE_COMPONENT, 0, 0, 1, 0 },
+ #endif
+     { 0, 0, 0, 0, 0, 0 }
+--- a/gcc/cppdefault.h	(Revision 193700)
++++ b/gcc/cppdefault.h	(Arbeitskopie)
+@@ -43,9 +43,11 @@
+ 				   C++.  */
+   const char add_sysroot;	/* FNAME should be prefixed by
+ 				   cpp_SYSROOT.  */
+-  const char multilib;		/* FNAME should have the multilib path
+-				   specified with -imultilib
+-				   appended.  */
++  const char multilib;		/* FNAME should have appended
++				   - the multilib path specified with -imultilib
++				     when set to 1,
++				   - the multiarch path specified with
++				     -imultiarch, when set to 2.  */
+ };
+ 
+ extern const struct default_include cpp_include_defaults[];
+--- a/gcc/genmultilib	(Revision 193700)
++++ b/gcc/genmultilib	(Arbeitskopie)
+@@ -73,6 +73,8 @@
+ # the os directory names are used exclusively.  Use the mapping when
+ # there is no one-to-one equivalence between GCC levels and the OS.
+ 
++# The optional eighth argument is the multiarch name.
++
+ # The last option should be "yes" if multilibs are enabled.  If it is not
+ # "yes", all GCC multilib dir names will be ".".
+ 
+@@ -121,7 +123,8 @@
+ extra=$5
+ exclusions=$6
+ osdirnames=$7
+-enable_multilib=$8
++multiarch=$8
++enable_multilib=$9
+ 
+ echo "static const char *const multilib_raw[] = {"
+ 
+@@ -222,6 +225,9 @@
+ # names.
+ toosdirnames=
+ defaultosdirname=
++if [ -n "${multiarch}" ]; then
++  defaultosdirname=::${multiarch}
++fi
+ if [ -n "${osdirnames}" ]; then
+   set x ${osdirnames}
+   shift
+@@ -229,6 +235,9 @@
+     case "$1" in
+       .=*)
+         defaultosdirname=`echo $1 | sed 's|^.=|:|'`
++	if [ -n "${multiarch}" ]; then
++	  defaultosdirname=${defaultosdirname}:${multiarch}
++	fi
+ 	shift
+ 	;;
+       *=*)
+@@ -314,13 +323,13 @@
+     dirout=`echo ${combo} | sed -e 's/=/-/g'`
+   fi
+   # Remove the leading and trailing slashes.
+-  dirout=`echo ${dirout} | sed -e 's|^/||' -e 's|/$||g'`
++  dirout=`echo ${dirout} | sed -e 's|^/||' -e 's|/*:/*|:|' -e 's|/$||g'`
+ 
+   # Use the OS directory names rather than the option names.
+   if [ -n "${toosdirnames}" ]; then
+     osdirout=`echo ${combo} | sed ${toosdirnames}`
+     # Remove the leading and trailing slashes.
+-    osdirout=`echo ${osdirout} | sed -e 's|^/||' -e 's|/$||g'`
++    osdirout=`echo ${osdirout} | sed -e 's|^/||' -e 's|/*:/*|:|' -e 's|/$||g'`
+     if [ "x${enable_multilib}" != xyes ]; then
+       dirout=".:${osdirout}"
+       disable_multilib=yes
+--- a/gcc/configure.ac	(Revision 193700)
++++ b/gcc/configure.ac	(Arbeitskopie)
+@@ -606,6 +606,28 @@
+ [], [enable_multilib=yes])
+ AC_SUBST(enable_multilib)
+ 
++# Determine whether or not multiarch is enabled.
++AC_ARG_ENABLE(multiarch,
++[AS_HELP_STRING([--enable-multiarch],
++		[enable support for multiarch paths])],
++[case "${enableval}" in
++yes|no|auto) enable_multiarch=$enableval;;
++*) AC_MSG_ERROR(bad value ${enableval} given for --enable-multiarch option) ;;
++esac], [enable_multiarch=auto])
++if test x${enable_multiarch} = xauto; then
++  if test x$host != x$target && test "x$with_sysroot" = x; then
++    ma_msg_suffix=", disabled auto check (cross build configured without --with-sysroot)"
++    enable_multiarch=no
++  fi
++fi
++AC_MSG_CHECKING(for multiarch configuration)
++AC_SUBST(enable_multiarch)
++AC_MSG_RESULT($enable_multiarch$ma_msg_suffix)
++
++# needed for setting the multiarch name for soft-float/hard-float ABIs
++AC_SUBST(with_cpu)
++AC_SUBST(with_float)
++
+ # Enable __cxa_atexit for C++.
+ AC_ARG_ENABLE(__cxa_atexit,
+ [  --enable-__cxa_atexit   enable __cxa_atexit for C++],
+--- a/gcc/gcc.c	(Revision 193700)
++++ b/gcc/gcc.c	(Arbeitskopie)
+@@ -1132,6 +1132,11 @@
+    set_multilib_dir based on the compilation options.  */
+ 
+ static const char *multilib_os_dir;
++
++/* Subdirectory to use for locating libraries in multiarch conventions.  Set by
++   set_multilib_dir based on the compilation options.  */
++
++static const char *multiarch_dir;
+ 
+ /* Structure to keep track of the specs that have been defined so far.
+    These are accessed using %(specname) or %[specname] in a compiler
+@@ -2045,6 +2050,7 @@
+   struct prefix_list *pl;
+   const char *multi_dir = NULL;
+   const char *multi_os_dir = NULL;
++  const char *multiarch_suffix = NULL;
+   const char *multi_suffix;
+   const char *just_multi_suffix;
+   char *path = NULL;
+@@ -2062,11 +2068,14 @@
+     }
+   if (do_multi && multilib_os_dir && strcmp (multilib_os_dir, ".") != 0)
+     multi_os_dir = concat (multilib_os_dir, dir_separator_str, NULL);
++  if (multiarch_dir)
++    multiarch_suffix = concat (multiarch_dir, dir_separator_str, NULL);
+ 
+   while (1)
+     {
+       size_t multi_dir_len = 0;
+       size_t multi_os_dir_len = 0;
++      size_t multiarch_len = 0;
+       size_t suffix_len;
+       size_t just_suffix_len;
+       size_t len;
+@@ -2075,16 +2084,15 @@
+ 	multi_dir_len = strlen (multi_dir);
+       if (multi_os_dir)
+ 	multi_os_dir_len = strlen (multi_os_dir);
++      if (multiarch_suffix)
++	multiarch_len = strlen (multiarch_suffix);
+       suffix_len = strlen (multi_suffix);
+       just_suffix_len = strlen (just_multi_suffix);
+ 
+       if (path == NULL)
+ 	{
+ 	  len = paths->max_len + extra_space + 1;
+-	  if (suffix_len > multi_os_dir_len)
+-	    len += suffix_len;
+-	  else
+-	    len += multi_os_dir_len;
++	  len += MAX (MAX (suffix_len, multi_os_dir_len), multiarch_len);
+ 	  path = XNEWVEC (char, len);
+ 	}
+ 
+@@ -2113,6 +2121,16 @@
+ 		break;
+ 	    }
+ 
++	  /* Now try the multiarch path.  */
++	  if (!skip_multi_dir
++	      && !pl->require_machine_suffix && multiarch_dir)
++	    {
++	      memcpy (path + len, multiarch_suffix, multiarch_len + 1);
++	      ret = callback (path, callback_info);
++	      if (ret)
++		break;
++	    }
++
+ 	  /* Now try the base path.  */
+ 	  if (!pl->require_machine_suffix
+ 	      && !(pl->os_multilib ? skip_multi_os_dir : skip_multi_dir))
+@@ -2929,6 +2947,9 @@
+   fputs (_("  -print-libgcc-file-name  Display the name of the compiler's companion library\n"), stdout);
+   fputs (_("  -print-file-name=<lib>   Display the full path to library <lib>\n"), stdout);
+   fputs (_("  -print-prog-name=<prog>  Display the full path to compiler component <prog>\n"), stdout);
++  fputs (_("\
++  -print-multiarch         Display the target's normalized GNU triplet, used as\n\
++                           a component in the library path\n"), stdout);
+   fputs (_("  -print-multi-directory   Display the root directory for versions of libgcc\n"), stdout);
+   fputs (_("\
+   -print-multi-lib         Display the mapping between command line options and\n\
+@@ -3201,6 +3222,7 @@
+     case OPT_print_multi_directory:
+     case OPT_print_sysroot:
+     case OPT_print_multi_os_directory:
++    case OPT_print_multiarch:
+     case OPT_print_sysroot_headers_suffix:
+     case OPT_time:
+     case OPT_wrapper:
+@@ -4851,6 +4873,15 @@
+ 		  do_spec_1 (" ", 0, NULL);
+ 		}
+ 
++	      if (multiarch_dir)
++		{
++		  do_spec_1 ("-imultiarch", 1, NULL);
++		  /* Make this a separate argument.  */
++		  do_spec_1 (" ", 0, NULL);
++		  do_spec_1 (multiarch_dir, 1, NULL);
++		  do_spec_1 (" ", 0, NULL);
++		}
++
+ 	      if (gcc_exec_prefix)
+ 		{
+ 		  do_spec_1 ("-iprefix", 1, NULL);
+@@ -6497,6 +6528,15 @@
+       return (0);
+     }
+ 
++  if (print_multiarch)
++    {
++      if (multiarch_dir == NULL)
++	printf ("\n");
++      else
++	printf ("%s\n", multiarch_dir);
++      return (0);
++    }
++
+   if (print_sysroot)
+     {
+       if (target_system_root)
+@@ -7260,7 +7300,9 @@
+    options are present, then we will ignore this completely. Passing
+    that, gcc will consider each multilib_select in turn using the same
+    rules for matching the options. If a match is found, that subdirectory
+-   will be used.  */
++   will be used.
++   A subdirectory name is optionally followed by a colon and the corresponding
++   multiarch name.  */
+ 
+ static void
+ set_multilib_dir (void)
+@@ -7472,10 +7514,25 @@
+ 	    q++;
+ 	  if (q < end)
+ 	    {
+-	      char *new_multilib_os_dir = XNEWVEC (char, end - q);
+-	      memcpy (new_multilib_os_dir, q + 1, end - q - 1);
+-	      new_multilib_os_dir[end - q - 1] = '\0';
+-	      multilib_os_dir = new_multilib_os_dir;
++	      const char *q2 = q + 1, *ml_end = end;
++	      char *new_multilib_os_dir;
++
++	      while (q2 < end && *q2 != ':')
++		q2++;
++	      if (*q2 == ':')
++		ml_end = q2;
++	      new_multilib_os_dir = XNEWVEC (char, ml_end - q);
++	      memcpy (new_multilib_os_dir, q + 1, ml_end - q - 1);
++	      new_multilib_os_dir[ml_end - q - 1] = '\0';
++	      multilib_os_dir = *new_multilib_os_dir ? new_multilib_os_dir : ".";
++
++	      if (q2 < end && *q2 == ':')
++		{
++		  char *new_multiarch_dir = XNEWVEC (char, end - q2);
++		  memcpy (new_multiarch_dir, q2 + 1, end - q2 - 1);
++		  new_multiarch_dir[end - q2 - 1] = '\0';
++		  multiarch_dir = new_multiarch_dir;
++		}
+ 	      break;
+ 	    }
+ 	}
+@@ -7535,9 +7592,10 @@
+ 	}
+ 
+       /* When --disable-multilib was used but target defines
+-	 MULTILIB_OSDIRNAMES, entries starting with .: are there just
+-	 to find multilib_os_dir, so skip them from output.  */
+-      if (this_path[0] == '.' && this_path[1] == ':')
++	 MULTILIB_OSDIRNAMES, entries starting with .: (and not starting
++         with .:: for multiarch configurations) are there just to find
++         multilib_os_dir, so skip them from output.  */
++      if (this_path[0] == '.' && this_path[1] == ':' && this_path[2] != ':')
+ 	skip = 1;
+ 
+       /* Check for matches with the multilib_exclusions. We don't bother
+--- a/gcc/common.opt	(Revision 193700)
++++ b/gcc/common.opt	(Arbeitskopie)
+@@ -334,6 +334,9 @@
+ -print-multi-os-directory
+ Driver Alias(print-multi-os-directory)
+ 
++-print-multiarch
++Driver Alias(print-multiarch)
++
+ -print-prog-name
+ Driver Separate Alias(print-prog-name=)
+ 
+@@ -2190,6 +2193,10 @@
+ Common Joined Var(plugindir_string) Init(0)
+ -iplugindir=<dir>	Set <dir> to be the default plugin directory
+ 
++imultiarch
++Common Joined Separate RejectDriver Var(imultiarch) Init(0)
++-imultiarch <dir>	Set <dir> to be the multiarch include subdirectory
++
+ l
+ Driver Joined Separate
+ 
+@@ -2247,6 +2254,9 @@
+ 
+ print-multi-os-directory
+ Driver Var(print_multi_os_directory)
++ 
++print-multiarch
++Driver Var(print_multiarch)
+ 
+ print-prog-name=
+ Driver JoinedOrMissing Var(print_prog_name)
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-no-add-needed.patch b/patches/gcc/linaro-4.6-2012.10/gcc-no-add-needed.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-no-add-needed.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-no-add-needed.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,45 @@
+# DP: On linux targets pass --no-add-needed to the linker.
+
+2010-02-08  Roland McGrath  <roland@redhat.com>
+
+	* config/rs6000/sysv4.h (LINK_EH_SPEC): Pass --no-add-needed to the
+	linker.
+	* config/linux.h (LINK_EH_SPEC): Likewise.
+	* config/alpha/elf.h (LINK_EH_SPEC): Likewise.
+	* config/ia64/linux.h (LINK_EH_SPEC): Likewise.
+
+--- a/gcc/config/gnu-user.h
++++ b/gcc/config/gnu-user.h
+@@ -82,7 +82,9 @@
+ #define LIB_SPEC GNU_USER_TARGET_LIB_SPEC
+ 
+ #if defined(HAVE_LD_EH_FRAME_HDR)
+-#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
++#define LINK_EH_SPEC "--no-add-needed %{!static:--eh-frame-hdr} "
++#else
++#define LINK_EH_SPEC "--no-add-needed "
+ #endif
+ 
+ #undef LINK_GCC_C_SEQUENCE_SPEC
+--- a/gcc/config/alpha/elf.h
++++ b/gcc/config/alpha/elf.h
+@@ -438,7 +438,7 @@
+    I imagine that other systems will catch up.  In the meantime, it
+    doesn't harm to make sure that the data exists to be used later.  */
+ #if defined(HAVE_LD_EH_FRAME_HDR)
+-#define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
++#define LINK_EH_SPEC "--no-add-needed %{!static:--eh-frame-hdr} "
+ #endif
+ 
+ /* A C statement (sans semicolon) to output to the stdio stream STREAM
+--- a/gcc/config/ia64/linux.h
++++ b/gcc/config/ia64/linux.h
+@@ -82,7 +82,7 @@
+    Signalize that because we have fde-glibc, we don't need all C shared libs
+    linked against -lgcc_s.  */
+ #undef LINK_EH_SPEC
+-#define LINK_EH_SPEC ""
++#define LINK_EH_SPEC "--no-add-needed "
+ 
+ #define MD_UNWIND_SUPPORT "config/ia64/linux-unwind.h"
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-nof.patch b/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-nof.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-nof.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-nof.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,23 @@
+# DP: Don't build nof multlib on powerpc.
+
+Index: b/gcc/config/rs6000/t-linux64
+===================================================================
+--- a/gcc/config/rs6000/t-linux64
++++ b/gcc/config/rs6000/t-linux64
+@@ -31,14 +31,11 @@
+ # it doesn't tell anything about the 32bit libraries on those systems.  Set
+ # MULTILIB_OSDIRNAMES according to what is found on the target.
+ 
+-MULTILIB_OPTIONS        = m64/m32 msoft-float
+-MULTILIB_DIRNAMES       = 64 32 nof
++MULTILIB_OPTIONS        = m64/m32
++MULTILIB_DIRNAMES       = 64 32
+ MULTILIB_EXTRA_OPTS     = fPIC mstrict-align
+-MULTILIB_EXCEPTIONS     = m64/msoft-float
+-MULTILIB_EXCLUSIONS     = m64/!m32/msoft-float
+ MULTILIB_OSDIRNAMES	= ../lib64$(call if_multiarch,:powerpc64-linux-gnu)
+ MULTILIB_OSDIRNAMES    += $(if $(wildcard $(shell echo $(SYSTEM_HEADER_DIR))/../../usr/lib32),../lib32,../lib)$(call if_multiarch,:powerpc-linux-gnu)
+-MULTILIB_OSDIRNAMES    += nof
+ MULTILIB_MATCHES        = $(MULTILIB_MATCHES_FLOAT)
+ 
+ softfp_wrap_start := '\#ifndef __powerpc64__'
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-undef.patch b/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-undef.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-undef.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-powerpc-undef.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,13 @@
+# DP: Undefine LINK_EH_SPEC before redefining it
+# DP: http://gcc.gnu.org/ml/gcc-patches/2011-02/msg01082.html
+
+--- a/gcc/config/rs6000/sysv4.h
++++ b/gcc/config/rs6000/sysv4.h
+@@ -835,6 +835,7 @@
+   -dynamic-linker " LINUX_DYNAMIC_LINKER "}}"
+ 
+ #if defined(HAVE_LD_EH_FRAME_HDR)
++# undef  LINK_EH_SPEC
+ # define LINK_EH_SPEC "%{!static:--eh-frame-hdr} "
+ #endif
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-system-root.patch b/patches/gcc/linaro-4.6-2012.10/gcc-system-root.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-system-root.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-system-root.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,42 @@
+# DP: Remove trailing slash from system root directory
+
+--- a/gcc/incpath.c
++++ b/gcc/incpath.c
+@@ -172,7 +172,15 @@
+ 
+ 	  /* Should this directory start with the sysroot?  */
+ 	  if (sysroot && p->add_sysroot)
+-	    str = concat (sysroot, p->fname, NULL);
++	    {
++	      char *sysroot_no_trailing_dir_separator = xstrdup (sysroot);
++	      size_t sysroot_len = strlen (sysroot);
++
++	      if (sysroot_len > 0 && sysroot[sysroot_len - 1] == DIR_SEPARATOR)
++		sysroot_no_trailing_dir_separator[sysroot_len - 1] = '\0';
++	      str = concat (sysroot_no_trailing_dir_separator, p->fname, NULL);
++	      free (sysroot_no_trailing_dir_separator);
++	    }
+ 	  else if (!p->add_sysroot && relocated
+ 		   && strncmp (p->fname, cpp_PREFIX, cpp_PREFIX_len) == 0)
+ 	    {
+--- a/gcc/gcc.c
++++ b/gcc/gcc.c
+@@ -2440,9 +2440,17 @@
+ 
+   if (target_system_root)
+     {
++      char *sysroot_no_trailing_dir_separator = xstrdup (target_system_root);
++      size_t sysroot_len = strlen (target_system_root);
++
++      if (sysroot_len > 0
++	  && target_system_root[sysroot_len - 1] == DIR_SEPARATOR)
++	sysroot_no_trailing_dir_separator[sysroot_len - 1] = '\0';
++
+       if (target_sysroot_suffix)
+ 	  prefix = concat (target_sysroot_suffix, prefix, NULL);
+-      prefix = concat (target_system_root, prefix, NULL);
++      prefix = concat (sysroot_no_trailing_dir_separator, prefix, NULL);
++      free (sysroot_no_trailing_dir_separator);
+ 
+       /* We have to override this because GCC's notion of sysroot
+ 	 moves along with GCC.  */
diff -Nru a/patches/gcc/linaro-4.6-2012.10/gcc-textdomain.patch b/patches/gcc/linaro-4.6-2012.10/gcc-textdomain.patch
--- a/patches/gcc/linaro-4.6-2012.10/gcc-textdomain.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/gcc-textdomain.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,84 @@
+# DP: Set gettext's domain and textdomain to the versioned package name.
+
+--- a/gcc/intl.c
++++ b/gcc/intl.c
+@@ -56,8 +56,8 @@
+   setlocale (LC_ALL, "");
+ #endif
+ 
+-  (void) bindtextdomain ("gcc", LOCALEDIR);
+-  (void) textdomain ("gcc");
++  (void) bindtextdomain ("gcc-4.6", LOCALEDIR);
++  (void) textdomain ("gcc-4.6");
+ 
+   /* Opening quotation mark.  */
+   open_quote = _("`");
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -5157,8 +5157,8 @@
+ 	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+ 	  echo $(mkinstalldirs) $(DESTDIR)$$dir; \
+ 	  $(mkinstalldirs) $(DESTDIR)$$dir || exit 1; \
+-	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc.mo; \
+-	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc.mo; \
++	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc-4.6.mo; \
++	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/gcc-4.6.mo; \
+ 	done
+ 
+ # Rule for regenerating the message template (gcc.pot).
+--- a/libcpp/init.c
++++ b/libcpp/init.c
+@@ -135,7 +135,7 @@
+       init_trigraph_map ();
+ 
+ #ifdef ENABLE_NLS
+-       (void) bindtextdomain (PACKAGE, LOCALEDIR);
++       (void) bindtextdomain (PACKAGE PACKAGE_SUFFIX, LOCALEDIR);
+ #endif
+     }
+ }
+--- a/libcpp/system.h
++++ b/libcpp/system.h
+@@ -265,7 +265,7 @@
+ #endif
+ 
+ #ifndef _
+-# define _(msgid) dgettext (PACKAGE, msgid)
++# define _(msgid) dgettext (PACKAGE PACKAGE_SUFFIX, msgid)
+ #endif
+ 
+ #ifndef N_
+--- a/libcpp/Makefile.in
++++ b/libcpp/Makefile.in
+@@ -49,6 +49,7 @@
+ LIBICONV = @LIBICONV@
+ LIBINTL = @LIBINTL@
+ PACKAGE = @PACKAGE@
++PACKAGE_SUFFIX = -4.6
+ RANLIB = @RANLIB@
+ SHELL = @SHELL@
+ USED_CATALOGS = @USED_CATALOGS@
+@@ -70,9 +71,10 @@
+ 
+ INCLUDES = -I$(srcdir) -I. -I$(srcdir)/../include @INCINTL@ \
+ 	-I$(srcdir)/include
++DEBCPPFLAGS += -DPACKAGE_SUFFIX=\"$(strip $(PACKAGE_SUFFIX))\"
+ 
+-ALL_CFLAGS = $(CFLAGS) $(WARN_CFLAGS) $(INCLUDES) $(CPPFLAGS)
+-ALL_CXXFLAGS = $(CXXFLAGS) $(WARN_CXXFLAGS) $(INCLUDES) $(CPPFLAGS)
++ALL_CFLAGS = $(CFLAGS) $(WARN_CFLAGS) $(INCLUDES) $(CPPFLAGS) $(DEBCPPFLAGS)
++ALL_CXXFLAGS = $(CXXFLAGS) $(WARN_CXXFLAGS) $(INCLUDES) $(CPPFLAGS) $(DEBCPPFLAGS)
+ 
+ # The name of the compiler to use.
+ ENABLE_BUILD_WITH_CXX = @ENABLE_BUILD_WITH_CXX@
+@@ -168,8 +170,8 @@
+ 	  else continue; \
+ 	  fi; \
+ 	  dir=$(localedir)/$$lang/LC_MESSAGES; \
+-	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE).mo; \
+-	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE).mo; \
++	  echo $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE)$(PACKAGE_SUFFIX).mo; \
++	  $(INSTALL_DATA) $$cat $(DESTDIR)$$dir/$(PACKAGE)$(PACKAGE_SUFFIX).mo; \
+ 	done
+ 
+ mostlyclean:
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libffi-kfreebsd.patch b/patches/gcc/linaro-4.6-2012.10/libffi-kfreebsd.patch
--- a/patches/gcc/linaro-4.6-2012.10/libffi-kfreebsd.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libffi-kfreebsd.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,13 @@
+# DP: libffi:  Define FFI_MMAP_EXEC_WRIT on kfreebsd-*.
+
+--- a/libffi/configure.ac
++++ b/libffi/configure.ac
+@@ -313,7 +313,7 @@
+ fi
+ 
+ case "$target" in
+-     *-apple-darwin10* | *-*-freebsd* | *-*-openbsd* | *-pc-solaris*)
++     *-apple-darwin10* | *-*-freebsd* | *-*-kfreebsd* | *-*-openbsd* | *-pc-solaris*)
+        AC_DEFINE(FFI_MMAP_EXEC_WRIT, 1,
+                  [Cannot use malloc on this target, so, we revert to
+                    alternative means])
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libffi-m68k.patch b/patches/gcc/linaro-4.6-2012.10/libffi-m68k.patch
--- a/patches/gcc/linaro-4.6-2012.10/libffi-m68k.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libffi-m68k.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,68 @@
+--- a/libffi/src/m68k/sysv.S
++++ b/libffi/src/m68k/sysv.S
+@@ -109,7 +109,7 @@
+ retfloat:
+ 	btst	#2,%d2
+ 	jbeq	retdouble
+-#if defined(__MC68881__)
++#if defined(__MC68881__) || defined(__HAVE_68881__)
+ 	fmove.s	%fp0,(%a1)
+ #else
+ 	move.l	%d0,(%a1)
+@@ -119,7 +119,7 @@
+ retdouble:
+ 	btst	#3,%d2
+ 	jbeq	retlongdouble
+-#if defined(__MC68881__)
++#if defined(__MC68881__) || defined(__HAVE_68881__)
+ 	fmove.d	%fp0,(%a1)
+ #else
+ 	move.l	%d0,(%a1)+
+@@ -130,7 +130,7 @@
+ retlongdouble:
+ 	btst	#4,%d2
+ 	jbeq	retpointer
+-#if defined(__MC68881__)
++#if defined(__MC68881__) || defined(__HAVE_68881__)
+ 	fmove.x	%fp0,(%a1)
+ #else
+ 	move.l	%d0,(%a1)+
+@@ -199,7 +199,7 @@
+ 	move.l	(%a0),%d1
+ 	jra	.Lcls_epilogue
+ .Lcls_ret_float:
+-#if defined(__MC68881__)
++#if defined(__MC68881__) || defined(__HAVE_68881__)
+ 	fmove.s	(%a0),%fp0
+ #else
+ 	move.l	(%a0),%d0
+@@ -209,7 +209,7 @@
+ 	lsr.l	#2,%d0
+ 	jne	1f
+ 	jcs	.Lcls_ret_ldouble
+-#if defined(__MC68881__)
++#if defined(__MC68881__) || defined(__HAVE_68881__)
+ 	fmove.d	(%a0),%fp0
+ #else
+ 	move.l	(%a0)+,%d0
+@@ -217,7 +217,7 @@
+ #endif
+ 	jra	.Lcls_epilogue
+ .Lcls_ret_ldouble:
+-#if defined(__MC68881__)
++#if defined(__MC68881__) || defined(__HAVE_68881__)
+ 	fmove.x	(%a0),%fp0
+ #else
+ 	move.l	(%a0)+,%d0
+--- a/libffi/src/m68k/ffi.c
++++ b/libffi/src/m68k/ffi.c
+@@ -261,7 +261,8 @@
+ 		      void *user_data,
+ 		      void *codeloc)
+ {
+-  FFI_ASSERT (cif->abi == FFI_SYSV);
++  if (cif->abi != FFI_SYSV)
++    return FFI_BAD_ABI;
+ 
+   *(unsigned short *)closure->tramp = 0x207c;
+   *(void **)(closure->tramp + 2) = codeloc;
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sf.patch b/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sf.patch
--- a/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sf.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sf.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,971 @@
+>From 95d80e11f6d14da32c9e117321658c27155e313a Mon Sep 17 00:00:00 2001
+From: Kyle Moffett <Kyle.D.Moffett@boeing.com>
+Date: Tue, 16 Aug 2011 14:46:50 -0400
+Subject: [PATCH] PowerPC: Debug and fix soft-floating-point support
+
+There were a wide range of bugs in this code, including long-double
+register alignment issues, assignments to global constants (which were
+actually stored as non-constant integers).
+
+This passes the testsuite on soft-floating-point PowerPC, and it builds
+and passes the testsuite on PowerPC e500 systems which cannot even
+assemble the regular floating-point instruction set.
+
+Signed-off-by: Kyle Moffett <Kyle.D.Moffett@boeing.com>
+---
+ src/powerpc/ffi.c         |  533 ++++++++++++++++++++++++---------------------
+ src/powerpc/ffitarget.h   |   14 +-
+ src/powerpc/ppc_closure.S |   19 ++
+ src/powerpc/sysv.S        |    6 +
+ 4 files changed, 310 insertions(+), 262 deletions(-)
+
+--- a/libffi/src/powerpc/ffi.c
++++ b/libffi/src/powerpc/ffi.c
+@@ -39,7 +39,9 @@
+   /* The assembly depends on these exact flags.  */
+   FLAG_RETURNS_SMST	= 1 << (31-31), /* Used for FFI_SYSV small structs.  */
+   FLAG_RETURNS_NOTHING  = 1 << (31-30), /* These go in cr7 */
++#ifndef __NO_FPRS__
+   FLAG_RETURNS_FP       = 1 << (31-29),
++#endif
+   FLAG_RETURNS_64BITS   = 1 << (31-28),
+ 
+   FLAG_RETURNS_128BITS  = 1 << (31-27), /* cr6  */
+@@ -50,21 +52,20 @@
+   /* Bits (31-24) through (31-19) store shift value for SMST */
+ 
+   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),
++#ifndef __NO_FPRS__
+   FLAG_FP_ARGUMENTS     = 1 << (31- 6), /* cr1.eq; specified by ABI */
++#endif
+   FLAG_4_GPR_ARGUMENTS  = 1 << (31- 5),
+   FLAG_RETVAL_REFERENCE = 1 << (31- 4)
+ };
+ 
+ /* About the SYSV ABI.  */
+-unsigned int NUM_GPR_ARG_REGISTERS = 8;
++#define ASM_NEEDS_REGISTERS 4
++#define NUM_GPR_ARG_REGISTERS 8
+ #ifndef __NO_FPRS__
+-unsigned int NUM_FPR_ARG_REGISTERS = 8;
+-#else
+-unsigned int NUM_FPR_ARG_REGISTERS = 0;
++# define NUM_FPR_ARG_REGISTERS 8
+ #endif
+ 
+-enum { ASM_NEEDS_REGISTERS = 4 };
+-
+ /* ffi_prep_args_SYSV is called by the assembly routine once stack space
+    has been allocated for the function's arguments.
+ 
+@@ -113,10 +114,12 @@
+   valp gpr_base;
+   int intarg_count;
+ 
++#ifndef __NO_FPRS__
+   /* 'fpr_base' points at the space for fpr1, and grows upwards as
+      we use FPR registers.  */
+   valp fpr_base;
+   int fparg_count;
++#endif
+ 
+   /* 'copy_space' grows down as we put structures in it.  It should
+      stay 16-byte aligned.  */
+@@ -125,9 +128,8 @@
+   /* 'next_arg' grows up as we put parameters in it.  */
+   valp next_arg;
+ 
+-  int i, ii MAYBE_UNUSED;
++  int i;
+   ffi_type **ptr;
+-  double double_tmp;
+   union {
+     void **v;
+     char **c;
+@@ -143,15 +145,16 @@
+   size_t struct_copy_size;
+   unsigned gprvalue;
+ 
+-  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)
+-    NUM_FPR_ARG_REGISTERS = 0;
+-
+   stacktop.c = (char *) stack + bytes;
+   gpr_base.u = stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS;
+   intarg_count = 0;
++#ifndef __NO_FPRS__
+   fpr_base.d = gpr_base.d - NUM_FPR_ARG_REGISTERS;
+   fparg_count = 0;
+   copy_space.c = ((flags & FLAG_FP_ARGUMENTS) ? fpr_base.c : gpr_base.c);
++#else
++  copy_space.c = gpr_base.c;
++#endif
+   next_arg.u = stack + 2;
+ 
+   /* Check that everything starts aligned properly.  */
+@@ -174,12 +177,29 @@
+        i > 0;
+        i--, ptr++, p_argv.v++)
+     {
+-      switch ((*ptr)->type)
+-	{
++      unsigned short typenum = (*ptr)->type;
++
++      /* We may need to handle some values depending on ABI */
++      if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT) {
++		if (typenum == FFI_TYPE_FLOAT)
++			typenum = FFI_TYPE_UINT32;
++		if (typenum == FFI_TYPE_DOUBLE)
++			typenum = FFI_TYPE_UINT64;
++		if (typenum == FFI_TYPE_LONGDOUBLE)
++			typenum = FFI_TYPE_UINT128;
++      } else if (ecif->cif->abi != FFI_LINUX) {
++#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++		if (typenum == FFI_TYPE_LONGDOUBLE)
++			typenum = FFI_TYPE_STRUCT;
++#endif
++      }
++
++      /* Now test the translated value */
++      switch (typenum) {
++        double double_tmp;
++#ifndef __NO_FPRS__
+ 	case FFI_TYPE_FLOAT:
+ 	  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */
+-	  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	    goto soft_float_prep;
+ 	  double_tmp = **p_argv.f;
+ 	  if (fparg_count >= NUM_FPR_ARG_REGISTERS)
+ 	    {
+@@ -195,8 +215,6 @@
+ 
+ 	case FFI_TYPE_DOUBLE:
+ 	  /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */
+-	  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	    goto soft_double_prep;
+ 	  double_tmp = **p_argv.d;
+ 
+ 	  if (fparg_count >= NUM_FPR_ARG_REGISTERS)
+@@ -218,43 +236,6 @@
+ 
+ #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+ 	case FFI_TYPE_LONGDOUBLE:
+-	  if ((ecif->cif->abi != FFI_LINUX)
+-		&& (ecif->cif->abi != FFI_LINUX_SOFT_FLOAT))
+-	    goto do_struct;
+-	  /* The soft float ABI for long doubles works like this,
+-	     a long double is passed in four consecutive gprs if available.
+-	     A maximum of 2 long doubles can be passed in gprs.
+-	     If we do not have 4 gprs left, the long double is passed on the
+-	     stack, 4-byte aligned.  */
+-	  if (ecif->cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	    {
+-	      unsigned int int_tmp = (*p_argv.ui)[0];
+-	      if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3)
+-		{
+-		  if (intarg_count < NUM_GPR_ARG_REGISTERS)
+-		    intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;
+-		  *next_arg.u = int_tmp;
+-		  next_arg.u++;
+-		  for (ii = 1; ii < 4; ii++)
+-		    {
+-		      int_tmp = (*p_argv.ui)[ii];
+-		      *next_arg.u = int_tmp;
+-		      next_arg.u++;
+-		    }
+-		}
+-	      else
+-		{
+-		  *gpr_base.u++ = int_tmp;
+-		  for (ii = 1; ii < 4; ii++)
+-		    {
+-		      int_tmp = (*p_argv.ui)[ii];
+-		      *gpr_base.u++ = int_tmp;
+-		    }
+-		}
+-	      intarg_count +=4;
+-	    }
+-	  else
+-	    {
+ 	      double_tmp = (*p_argv.d)[0];
+ 
+ 	      if (fparg_count >= NUM_FPR_ARG_REGISTERS - 1)
+@@ -280,13 +261,40 @@
+ 
+ 	      fparg_count += 2;
+ 	      FFI_ASSERT (flags & FLAG_FP_ARGUMENTS);
+-	    }
+ 	  break;
+ #endif
++#endif /* have FPRs */
++	
++	/* 
++	 * The soft float ABI for long doubles works like this, a long double
++	 * is passed in four consecutive GPRs if available.  A maximum of 2
++	 * long doubles can be passed in gprs.  If we do not have 4 GPRs
++	 * left, the long double is passed on the stack, 4-byte aligned.
++	 */
++	case FFI_TYPE_UINT128: {
++		unsigned int int_tmp = (*p_argv.ui)[0];
++		unsigned int ii;
++		if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3) {
++			if (intarg_count < NUM_GPR_ARG_REGISTERS)
++				intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;
++			*(next_arg.u++) = int_tmp;
++			for (ii = 1; ii < 4; ii++) {
++				int_tmp = (*p_argv.ui)[ii];
++				*(next_arg.u++) = int_tmp;
++			}
++		} else {
++			*(gpr_base.u++) = int_tmp;
++			for (ii = 1; ii < 4; ii++) {
++				int_tmp = (*p_argv.ui)[ii];
++				*(gpr_base.u++) = int_tmp;
++			}
++		}
++		intarg_count += 4;
++		break;
++	}
+ 
+ 	case FFI_TYPE_UINT64:
+ 	case FFI_TYPE_SINT64:
+-	soft_double_prep:
+ 	  if (intarg_count == NUM_GPR_ARG_REGISTERS-1)
+ 	    intarg_count++;
+ 	  if (intarg_count >= NUM_GPR_ARG_REGISTERS)
+@@ -319,9 +327,6 @@
+ 	  break;
+ 
+ 	case FFI_TYPE_STRUCT:
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-	do_struct:
+-#endif
+ 	  struct_copy_size = ((*ptr)->size + 15) & ~0xF;
+ 	  copy_space.c -= struct_copy_size;
+ 	  memcpy (copy_space.c, *p_argv.c, (*ptr)->size);
+@@ -349,7 +354,6 @@
+ 	case FFI_TYPE_UINT32:
+ 	case FFI_TYPE_SINT32:
+ 	case FFI_TYPE_POINTER:
+-	soft_float_prep:
+ 
+ 	  gprvalue = **p_argv.ui;
+ 
+@@ -366,8 +370,10 @@
+   /* Check that we didn't overrun the stack...  */
+   FFI_ASSERT (copy_space.c >= next_arg.c);
+   FFI_ASSERT (gpr_base.u <= stacktop.u - ASM_NEEDS_REGISTERS);
++#ifndef __NO_FPRS__
+   FFI_ASSERT (fpr_base.u
+ 	      <= stacktop.u - ASM_NEEDS_REGISTERS - NUM_GPR_ARG_REGISTERS);
++#endif
+   FFI_ASSERT (flags & FLAG_4_GPR_ARGUMENTS || intarg_count <= 4);
+ }
+ 
+@@ -604,9 +610,6 @@
+   unsigned type = cif->rtype->type;
+   unsigned size = cif->rtype->size;
+ 
+-  if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-    NUM_FPR_ARG_REGISTERS = 0;
+-
+   if (cif->abi != FFI_LINUX64)
+     {
+       /* All the machine-independent calculation of cif->bytes will be wrong.
+@@ -646,25 +649,38 @@
+      - Single/double FP values in fpr1, long double in fpr1,fpr2.
+      - soft-float float/doubles are treated as UINT32/UINT64 respectivley.
+      - soft-float long doubles are returned in gpr3-gpr6.  */
++  /* First translate for softfloat/nonlinux */
++  if (cif->abi == FFI_LINUX_SOFT_FLOAT) {
++	if (type == FFI_TYPE_FLOAT)
++		type = FFI_TYPE_UINT32;
++	if (type == FFI_TYPE_DOUBLE)
++		type = FFI_TYPE_UINT64;
++	if (type == FFI_TYPE_LONGDOUBLE)
++		type = FFI_TYPE_UINT128;
++  } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {
++#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++	if (type == FFI_TYPE_LONGDOUBLE)
++		type = FFI_TYPE_STRUCT;
++#endif
++  }
++
+   switch (type)
+     {
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++#ifndef __NO_FPRS__
+     case FFI_TYPE_LONGDOUBLE:
+-      if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64
+-	&& cif->abi != FFI_LINUX_SOFT_FLOAT)
+-	goto byref;
+       flags |= FLAG_RETURNS_128BITS;
+       /* Fall through.  */
+-#endif
+     case FFI_TYPE_DOUBLE:
+       flags |= FLAG_RETURNS_64BITS;
+       /* Fall through.  */
+     case FFI_TYPE_FLOAT:
+-      /* With FFI_LINUX_SOFT_FLOAT no fp registers are used.  */
+-      if (cif->abi != FFI_LINUX_SOFT_FLOAT)
+-	flags |= FLAG_RETURNS_FP;
++      flags |= FLAG_RETURNS_FP;
+       break;
++#endif
+ 
++    case FFI_TYPE_UINT128:
++      flags |= FLAG_RETURNS_128BITS;
++      /* Fall through.  */
+     case FFI_TYPE_UINT64:
+     case FFI_TYPE_SINT64:
+       flags |= FLAG_RETURNS_64BITS;
+@@ -699,9 +715,6 @@
+ 		}
+ 	    }
+ 	}
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-    byref:
+-#endif
+       intarg_count++;
+       flags |= FLAG_RETVAL_REFERENCE;
+       /* Fall through.  */
+@@ -722,39 +735,36 @@
+        Stuff on the stack needs to keep proper alignment.  */
+     for (ptr = cif->arg_types, i = cif->nargs; i > 0; i--, ptr++)
+       {
+-	switch ((*ptr)->type)
+-	  {
++	unsigned short typenum = (*ptr)->type;
++
++	/* We may need to handle some values depending on ABI */
++	if (cif->abi == FFI_LINUX_SOFT_FLOAT) {
++		if (typenum == FFI_TYPE_FLOAT)
++			typenum = FFI_TYPE_UINT32;
++		if (typenum == FFI_TYPE_DOUBLE)
++			typenum = FFI_TYPE_UINT64;
++		if (typenum == FFI_TYPE_LONGDOUBLE)
++			typenum = FFI_TYPE_UINT128;
++	} else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {
++#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++		if (typenum == FFI_TYPE_LONGDOUBLE)
++			typenum = FFI_TYPE_STRUCT;
++#endif
++	}
++
++	switch (typenum) {
++#ifndef __NO_FPRS__
+ 	  case FFI_TYPE_FLOAT:
+-	    /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */
+-	    if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	      goto soft_float_cif;
+ 	    fparg_count++;
+ 	    /* floating singles are not 8-aligned on stack */
+ 	    break;
+ 
+ #if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+ 	  case FFI_TYPE_LONGDOUBLE:
+-	    if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)
+-	      goto do_struct;
+-	    if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	      {
+-		if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3
+-		  || intarg_count < NUM_GPR_ARG_REGISTERS)
+-		  /* A long double in FFI_LINUX_SOFT_FLOAT can use only
+-		     a set of four consecutive gprs. If we have not enough,
+-		     we have to adjust the intarg_count value.  */
+-		  intarg_count += NUM_GPR_ARG_REGISTERS - intarg_count;
+-		intarg_count += 4;
+-		break;
+-	      }
+-	    else
+-	      fparg_count++;
++	    fparg_count++;
+ 	    /* Fall thru */
+ #endif
+ 	  case FFI_TYPE_DOUBLE:
+-	    /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */
+-	    if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	      goto soft_double_cif;
+ 	    fparg_count++;
+ 	    /* If this FP arg is going on the stack, it must be
+ 	       8-byte-aligned.  */
+@@ -763,10 +773,21 @@
+ 		&& intarg_count % 2 != 0)
+ 	      intarg_count++;
+ 	    break;
++#endif
++	  case FFI_TYPE_UINT128:
++		/* 
++		 * A long double in FFI_LINUX_SOFT_FLOAT can use only a set
++		 * of four consecutive gprs. If we do not have enough, we
++		 * have to adjust the intarg_count value.
++		 */
++		if (intarg_count >= NUM_GPR_ARG_REGISTERS - 3
++				&& intarg_count < NUM_GPR_ARG_REGISTERS)
++			intarg_count = NUM_GPR_ARG_REGISTERS;
++		intarg_count += 4;
++		break;
+ 
+ 	  case FFI_TYPE_UINT64:
+ 	  case FFI_TYPE_SINT64:
+-	  soft_double_cif:
+ 	    /* 'long long' arguments are passed as two words, but
+ 	       either both words must fit in registers or both go
+ 	       on the stack.  If they go on the stack, they must
+@@ -783,9 +804,6 @@
+ 	    break;
+ 
+ 	  case FFI_TYPE_STRUCT:
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-	  do_struct:
+-#endif
+ 	    /* We must allocate space for a copy of these to enforce
+ 	       pass-by-value.  Pad the space up to a multiple of 16
+ 	       bytes (the maximum alignment required for anything under
+@@ -793,12 +811,20 @@
+ 	    struct_copy_size += ((*ptr)->size + 15) & ~0xF;
+ 	    /* Fall through (allocate space for the pointer).  */
+ 
+-	  default:
+-	  soft_float_cif:
++	  case FFI_TYPE_POINTER:
++	  case FFI_TYPE_INT:
++	  case FFI_TYPE_UINT32:
++	  case FFI_TYPE_SINT32:
++	  case FFI_TYPE_UINT16:
++	  case FFI_TYPE_SINT16:
++	  case FFI_TYPE_UINT8:
++	  case FFI_TYPE_SINT8:
+ 	    /* Everything else is passed as a 4-byte word in a GPR, either
+ 	       the object itself or a pointer to it.  */
+ 	    intarg_count++;
+ 	    break;
++	  default:
++		FFI_ASSERT (0);
+ 	  }
+       }
+   else
+@@ -827,16 +853,29 @@
+ 	    intarg_count += ((*ptr)->size + 7) / 8;
+ 	    break;
+ 
+-	  default:
++	  case FFI_TYPE_POINTER:
++	  case FFI_TYPE_UINT64:
++	  case FFI_TYPE_SINT64:
++	  case FFI_TYPE_INT:
++	  case FFI_TYPE_UINT32:
++	  case FFI_TYPE_SINT32:
++	  case FFI_TYPE_UINT16:
++	  case FFI_TYPE_SINT16:
++	  case FFI_TYPE_UINT8:
++	  case FFI_TYPE_SINT8:
+ 	    /* Everything else is passed as a 8-byte word in a GPR, either
+ 	       the object itself or a pointer to it.  */
+ 	    intarg_count++;
+ 	    break;
++	  default:
++		FFI_ASSERT (0);
+ 	  }
+       }
+ 
++#ifndef __NO_FPRS__
+   if (fparg_count != 0)
+     flags |= FLAG_FP_ARGUMENTS;
++#endif
+   if (intarg_count > 4)
+     flags |= FLAG_4_GPR_ARGUMENTS;
+   if (struct_copy_size != 0)
+@@ -844,21 +883,27 @@
+ 
+   if (cif->abi != FFI_LINUX64)
+     {
++#ifndef __NO_FPRS__
+       /* Space for the FPR registers, if needed.  */
+       if (fparg_count != 0)
+ 	bytes += NUM_FPR_ARG_REGISTERS * sizeof (double);
++#endif
+ 
+       /* Stack space.  */
+       if (intarg_count > NUM_GPR_ARG_REGISTERS)
+ 	bytes += (intarg_count - NUM_GPR_ARG_REGISTERS) * sizeof (int);
++#ifndef __NO_FPRS__
+       if (fparg_count > NUM_FPR_ARG_REGISTERS)
+ 	bytes += (fparg_count - NUM_FPR_ARG_REGISTERS) * sizeof (double);
++#endif
+     }
+   else
+     {
++#ifndef __NO_FPRS__
+       /* Space for the FPR registers, if needed.  */
+       if (fparg_count != 0)
+ 	bytes += NUM_FPR_ARG_REGISTERS64 * sizeof (double);
++#endif
+ 
+       /* Stack space.  */
+       if (intarg_count > NUM_GPR_ARG_REGISTERS64)
+@@ -905,9 +950,11 @@
+   switch (cif->abi)
+     {
+ #ifndef POWERPC64
++# ifndef __NO_FPRS__
+     case FFI_SYSV:
+     case FFI_GCC_SYSV:
+     case FFI_LINUX:
++# endif
+     case FFI_LINUX_SOFT_FLOAT:
+       ffi_call_SYSV (&ecif, -cif->bytes, cif->flags, ecif.rvalue, fn);
+       break;
+@@ -1011,32 +1058,38 @@
+   void **          avalue;
+   ffi_type **      arg_types;
+   long             i, avn;
+-  long             nf;   /* number of floating registers already used */
+-  long             ng;   /* number of general registers already used */
+-  ffi_cif *        cif;
+-  double           temp;
+-  unsigned         size;
++#ifndef __NO_FPRS__
++  long             nf = 0;   /* number of floating registers already used */
++#endif
++  long             ng = 0;   /* number of general registers already used */
++
++  ffi_cif *cif = closure->cif;
++  unsigned       size     = cif->rtype->size;
++  unsigned short rtypenum = cif->rtype->type;
+ 
+-  cif = closure->cif;
+   avalue = alloca (cif->nargs * sizeof (void *));
+-  size = cif->rtype->size;
+ 
+-  nf = 0;
+-  ng = 0;
++  /* First translate for softfloat/nonlinux */
++  if (cif->abi == FFI_LINUX_SOFT_FLOAT) {
++	if (rtypenum == FFI_TYPE_FLOAT)
++		rtypenum = FFI_TYPE_UINT32;
++	if (rtypenum == FFI_TYPE_DOUBLE)
++		rtypenum = FFI_TYPE_UINT64;
++	if (rtypenum == FFI_TYPE_LONGDOUBLE)
++		rtypenum = FFI_TYPE_UINT128;
++  } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {
++#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++	if (rtypenum == FFI_TYPE_LONGDOUBLE)
++		rtypenum = FFI_TYPE_STRUCT;
++#endif
++  }
++
+ 
+   /* Copy the caller's structure return value address so that the closure
+      returns the data directly to the caller.
+      For FFI_SYSV the result is passed in r3/r4 if the struct size is less
+      or equal 8 bytes.  */
+-
+-  if ((cif->rtype->type == FFI_TYPE_STRUCT
+-       && !((cif->abi == FFI_SYSV) && (size <= 8)))
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-      || (cif->rtype->type == FFI_TYPE_LONGDOUBLE
+-	  && cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)
+-#endif
+-      )
+-    {
++  if (rtypenum == FFI_TYPE_STRUCT && ((cif->abi != FFI_SYSV) || (size > 8))) {
+       rvalue = (void *) *pgr;
+       ng++;
+       pgr++;
+@@ -1047,10 +1100,109 @@
+   arg_types = cif->arg_types;
+ 
+   /* Grab the addresses of the arguments from the stack frame.  */
+-  while (i < avn)
+-    {
+-      switch (arg_types[i]->type)
+-	{
++  while (i < avn) {
++      unsigned short typenum = arg_types[i]->type;
++
++      /* We may need to handle some values depending on ABI */
++      if (cif->abi == FFI_LINUX_SOFT_FLOAT) {
++		if (typenum == FFI_TYPE_FLOAT)
++			typenum = FFI_TYPE_UINT32;
++		if (typenum == FFI_TYPE_DOUBLE)
++			typenum = FFI_TYPE_UINT64;
++		if (typenum == FFI_TYPE_LONGDOUBLE)
++			typenum = FFI_TYPE_UINT128;
++      } else if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX64) {
++#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++		if (typenum == FFI_TYPE_LONGDOUBLE)
++			typenum = FFI_TYPE_STRUCT;
++#endif
++      }
++
++      switch (typenum) {
++#ifndef __NO_FPRS__
++	case FFI_TYPE_FLOAT:
++	  /* unfortunately float values are stored as doubles
++	   * in the ffi_closure_SYSV code (since we don't check
++	   * the type in that routine).
++	   */
++
++	  /* there are 8 64bit floating point registers */
++
++	  if (nf < 8)
++	    {
++	      double temp = pfr->d;
++	      pfr->f = (float) temp;
++	      avalue[i] = pfr;
++	      nf++;
++	      pfr++;
++	    }
++	  else
++	    {
++	      /* FIXME? here we are really changing the values
++	       * stored in the original calling routines outgoing
++	       * parameter stack.  This is probably a really
++	       * naughty thing to do but...
++	       */
++	      avalue[i] = pst;
++	      pst += 1;
++	    }
++	  break;
++
++	case FFI_TYPE_DOUBLE:
++	  /* On the outgoing stack all values are aligned to 8 */
++	  /* there are 8 64bit floating point registers */
++
++	  if (nf < 8)
++	    {
++	      avalue[i] = pfr;
++	      nf++;
++	      pfr++;
++	    }
++	  else
++	    {
++	      if (((long) pst) & 4)
++		pst++;
++	      avalue[i] = pst;
++	      pst += 2;
++	    }
++	  break;
++
++#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
++	case FFI_TYPE_LONGDOUBLE:
++	  if (nf < 7)
++	    {
++	      avalue[i] = pfr;
++	      pfr += 2;
++	      nf += 2;
++	    }
++	  else
++	    {
++	      if (((long) pst) & 4)
++		pst++;
++	      avalue[i] = pst;
++	      pst += 4;
++	      nf = 8;
++	    }
++	  break;
++#endif
++#endif /* have FPRS */
++
++	case FFI_TYPE_UINT128:
++		/* 
++		 * Test if for the whole long double, 4 gprs are available.
++		 * otherwise the stuff ends up on the stack.
++		 */
++		if (ng < 5) {
++			avalue[i] = pgr;
++			pgr += 4;
++			ng += 4;
++		} else {
++			avalue[i] = pst;
++			pst += 4;
++			ng = 8+4;
++		}
++		break;
++
+ 	case FFI_TYPE_SINT8:
+ 	case FFI_TYPE_UINT8:
+ 	  /* there are 8 gpr registers used to pass values */
+@@ -1086,7 +1238,6 @@
+ 	case FFI_TYPE_SINT32:
+ 	case FFI_TYPE_UINT32:
+ 	case FFI_TYPE_POINTER:
+-	soft_float_closure:
+ 	  /* there are 8 gpr registers used to pass values */
+ 	  if (ng < 8)
+ 	    {
+@@ -1102,9 +1253,6 @@
+ 	  break;
+ 
+ 	case FFI_TYPE_STRUCT:
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-	do_struct:
+-#endif
+ 	  /* Structs are passed by reference. The address will appear in a
+ 	     gpr if it is one of the first 8 arguments.  */
+ 	  if (ng < 8)
+@@ -1122,7 +1270,6 @@
+ 
+ 	case FFI_TYPE_SINT64:
+ 	case FFI_TYPE_UINT64:
+-	soft_double_closure:
+ 	  /* passing long long ints are complex, they must
+ 	   * be passed in suitable register pairs such as
+ 	   * (r3,r4) or (r5,r6) or (r6,r7), or (r7,r8) or (r9,r10)
+@@ -1154,99 +1301,8 @@
+ 	    }
+ 	  break;
+ 
+-	case FFI_TYPE_FLOAT:
+-	  /* With FFI_LINUX_SOFT_FLOAT floats are handled like UINT32.  */
+-	  if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	    goto soft_float_closure;
+-	  /* unfortunately float values are stored as doubles
+-	   * in the ffi_closure_SYSV code (since we don't check
+-	   * the type in that routine).
+-	   */
+-
+-	  /* there are 8 64bit floating point registers */
+-
+-	  if (nf < 8)
+-	    {
+-	      temp = pfr->d;
+-	      pfr->f = (float) temp;
+-	      avalue[i] = pfr;
+-	      nf++;
+-	      pfr++;
+-	    }
+-	  else
+-	    {
+-	      /* FIXME? here we are really changing the values
+-	       * stored in the original calling routines outgoing
+-	       * parameter stack.  This is probably a really
+-	       * naughty thing to do but...
+-	       */
+-	      avalue[i] = pst;
+-	      pst += 1;
+-	    }
+-	  break;
+-
+-	case FFI_TYPE_DOUBLE:
+-	  /* With FFI_LINUX_SOFT_FLOAT doubles are handled like UINT64.  */
+-	  if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	    goto soft_double_closure;
+-	  /* On the outgoing stack all values are aligned to 8 */
+-	  /* there are 8 64bit floating point registers */
+-
+-	  if (nf < 8)
+-	    {
+-	      avalue[i] = pfr;
+-	      nf++;
+-	      pfr++;
+-	    }
+-	  else
+-	    {
+-	      if (((long) pst) & 4)
+-		pst++;
+-	      avalue[i] = pst;
+-	      pst += 2;
+-	    }
+-	  break;
+-
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-	case FFI_TYPE_LONGDOUBLE:
+-	  if (cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)
+-	    goto do_struct;
+-	  if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-	    { /* Test if for the whole long double, 4 gprs are available.
+-		 otherwise the stuff ends up on the stack.  */
+-	      if (ng < 5)
+-		{
+-		  avalue[i] = pgr;
+-		  pgr += 4;
+-		  ng += 4;
+-		}
+-	      else
+-		{
+-		  avalue[i] = pst;
+-		  pst += 4;
+-		  ng = 8;
+-		}
+-	      break;
+-	    }
+-	  if (nf < 7)
+-	    {
+-	      avalue[i] = pfr;
+-	      pfr += 2;
+-	      nf += 2;
+-	    }
+-	  else
+-	    {
+-	      if (((long) pst) & 4)
+-		pst++;
+-	      avalue[i] = pst;
+-	      pst += 4;
+-	      nf = 8;
+-	    }
+-	  break;
+-#endif
+-
+ 	default:
+-	  FFI_ASSERT (0);
++		FFI_ASSERT (0);
+ 	}
+ 
+       i++;
+@@ -1263,39 +1319,9 @@
+      already used and we never have a struct with size zero. That is the reason
+      for the subtraction of 1. See the comment in ffitarget.h about ordering.
+   */
+-  if (cif->abi == FFI_SYSV && cif->rtype->type == FFI_TYPE_STRUCT
+-      && size <= 8)
++  if (cif->abi == FFI_SYSV && rtypenum == FFI_TYPE_STRUCT && size <= 8)
+     return (FFI_SYSV_TYPE_SMALL_STRUCT - 1) + size;
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-  else if (cif->rtype->type == FFI_TYPE_LONGDOUBLE
+-	   && cif->abi != FFI_LINUX && cif->abi != FFI_LINUX_SOFT_FLOAT)
+-    return FFI_TYPE_STRUCT;
+-#endif
+-  /* With FFI_LINUX_SOFT_FLOAT floats and doubles are handled like UINT32
+-     respectivley UINT64.  */
+-  if (cif->abi == FFI_LINUX_SOFT_FLOAT)
+-    {
+-      switch (cif->rtype->type)
+-	{
+-	case FFI_TYPE_FLOAT:
+-	  return FFI_TYPE_UINT32;
+-	  break;
+-	case FFI_TYPE_DOUBLE:
+-	  return FFI_TYPE_UINT64;
+-	  break;
+-#if FFI_TYPE_LONGDOUBLE != FFI_TYPE_DOUBLE
+-	case FFI_TYPE_LONGDOUBLE:
+-	  return FFI_TYPE_UINT128;
+-	  break;
+-#endif
+-	default:
+-	  return cif->rtype->type;
+-	}
+-    }
+-  else
+-    {
+-      return cif->rtype->type;
+-    }
++  return rtypenum;
+ }
+ 
+ int FFI_HIDDEN ffi_closure_helper_LINUX64 (ffi_closure *, void *,
+--- a/libffi/src/powerpc/ffitarget.h
++++ b/libffi/src/powerpc/ffitarget.h
+@@ -60,18 +60,14 @@
+   FFI_LINUX64,
+   FFI_LINUX,
+   FFI_LINUX_SOFT_FLOAT,
+-# ifdef POWERPC64
++# if defined(POWERPC64)
+   FFI_DEFAULT_ABI = FFI_LINUX64,
+-# else
+-#  if (!defined(__NO_FPRS__) && (__LDBL_MANT_DIG__ == 106))
+-  FFI_DEFAULT_ABI = FFI_LINUX,
+-#  else
+-#   ifdef __NO_FPRS__
++# elif defined(__NO_FPRS__)
+   FFI_DEFAULT_ABI = FFI_LINUX_SOFT_FLOAT,
+-#   else
++# elif (__LDBL_MANT_DIG__ == 106)
++  FFI_DEFAULT_ABI = FFI_LINUX,
++# else
+   FFI_DEFAULT_ABI = FFI_GCC_SYSV,
+-#   endif
+-#  endif
+ # endif
+ #endif
+ 
+--- a/libffi/src/powerpc/ppc_closure.S
++++ b/libffi/src/powerpc/ppc_closure.S
+@@ -122,22 +122,41 @@
+ 	blr
+ 
+ # case FFI_TYPE_FLOAT
++#ifndef __NO_FPRS__
+ 	lfs %f1,112+0(%r1)
+ 	mtlr %r0
+ 	addi %r1,%r1,144
++#else
++	nop
++	nop
++	nop
++#endif
+ 	blr
+ 
+ # case FFI_TYPE_DOUBLE
++#ifndef __NO_FPRS__
+ 	lfd %f1,112+0(%r1)
+ 	mtlr %r0
+ 	addi %r1,%r1,144
++#else
++	nop
++	nop
++	nop
++#endif
+ 	blr
+ 
+ # case FFI_TYPE_LONGDOUBLE
++#ifndef __NO_FPRS__
+ 	lfd %f1,112+0(%r1)
+ 	lfd %f2,112+8(%r1)
+ 	mtlr %r0
+ 	b .Lfinish
++#else
++	nop
++	nop
++	nop
++	blr
++#endif
+ 
+ # case FFI_TYPE_UINT8
+ 	lbz %r3,112+3(%r1)
+--- a/libffi/src/powerpc/sysv.S
++++ b/libffi/src/powerpc/sysv.S
+@@ -83,6 +83,7 @@
+ 	nop
+ 1:
+ 
++#ifndef __NO_FPRS__
+ 	/* Load all the FP registers.  */
+ 	bf-	6,2f
+ 	lfd	%f1,-16-(8*4)-(8*8)(%r28)
+@@ -94,6 +95,7 @@
+ 	lfd	%f6,-16-(8*4)-(3*8)(%r28)
+ 	lfd	%f7,-16-(8*4)-(2*8)(%r28)
+ 	lfd	%f8,-16-(8*4)-(1*8)(%r28)
++#endif
+ 2:
+ 
+ 	/* Make the call.  */
+@@ -103,7 +105,9 @@
+ 	mtcrf	0x01,%r31 /* cr7  */
+ 	bt-	31,L(small_struct_return_value)
+ 	bt-	30,L(done_return_value)
++#ifndef __NO_FPRS__
+ 	bt-	29,L(fp_return_value)
++#endif
+ 	stw	%r3,0(%r30)
+ 	bf+	28,L(done_return_value)
+ 	stw	%r4,4(%r30)
+@@ -124,6 +128,7 @@
+ 	lwz	%r1,0(%r1)
+ 	blr
+ 
++#ifndef __NO_FPRS__
+ L(fp_return_value):
+ 	bf	28,L(float_return_value)
+ 	stfd	%f1,0(%r30)
+@@ -134,6 +139,7 @@
+ L(float_return_value):
+ 	stfs	%f1,0(%r30)
+ 	b	L(done_return_value)
++#endif
+ 
+ L(small_struct_return_value):
+ 	extrwi	%r6,%r31,2,19         /* number of bytes padding = shift/8 */
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sysv-without-string-ops.patch b/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sysv-without-string-ops.patch
--- a/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sysv-without-string-ops.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libffi-powerpc-sysv-without-string-ops.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,149 @@
+--- a/libffi/src/powerpc/ffi.c
++++ b/libffi/src/powerpc/ffi.c
+@@ -45,11 +45,6 @@
+   FLAG_RETURNS_64BITS   = 1 << (31-28),
+ 
+   FLAG_RETURNS_128BITS  = 1 << (31-27), /* cr6  */
+-  FLAG_SYSV_SMST_R4     = 1 << (31-26), /* use r4 for FFI_SYSV 8 byte
+-					   structs.  */
+-  FLAG_SYSV_SMST_R3     = 1 << (31-25), /* use r3 for FFI_SYSV 4 byte
+-					   structs.  */
+-  /* Bits (31-24) through (31-19) store shift value for SMST */
+ 
+   FLAG_ARG_NEEDS_COPY   = 1 << (31- 7),
+ #ifndef __NO_FPRS__
+@@ -687,37 +682,22 @@
+       break;
+ 
+     case FFI_TYPE_STRUCT:
+-      if (cif->abi == FFI_SYSV)
+-	{
+-	  /* The final SYSV ABI says that structures smaller or equal 8 bytes
+-	     are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them
+-	     in memory.  */
++	/*
++	 * The final SYSV ABI says that structures smaller or equal 8 bytes
++	 * are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them
++	 * in memory.
++	 *
++	 * NOTE: The assembly code can safely assume that it just needs to
++	 *       store both r3 and r4 into a 8-byte word-aligned buffer, as
++	 *       we allocate a temporary buffer in ffi_call() if this flag is
++	 *       set.
++	 */
++	if (cif->abi == FFI_SYSV && size <= 8)
++		flags |= FLAG_RETURNS_SMST;
+ 
+-	  /* Treat structs with size <= 8 bytes.  */
+-	  if (size <= 8)
+-	    {
+-	      flags |= FLAG_RETURNS_SMST;
+-	      /* These structs are returned in r3. We pack the type and the
+-		 precalculated shift value (needed in the sysv.S) into flags.
+-		 The same applies for the structs returned in r3/r4.  */
+-	      if (size <= 4)
+-		{
+-		  flags |= FLAG_SYSV_SMST_R3;
+-		  flags |= 8 * (4 - size) << 8;
+-		  break;
+-		}
+-	      /* These structs are returned in r3 and r4. See above.   */
+-	      if  (size <= 8)
+-		{
+-		  flags |= FLAG_SYSV_SMST_R3 | FLAG_SYSV_SMST_R4;
+-		  flags |= 8 * (8 - size) << 8;
+-		  break;
+-		}
+-	    }
+-	}
+-      intarg_count++;
+-      flags |= FLAG_RETVAL_REFERENCE;
+-      /* Fall through.  */
++	intarg_count++;
++	flags |= FLAG_RETVAL_REFERENCE;
++	/* Fall through.  */
+     case FFI_TYPE_VOID:
+       flags |= FLAG_RETURNS_NOTHING;
+       break;
+@@ -931,21 +911,30 @@
+ void
+ ffi_call(ffi_cif *cif, void (*fn)(void), void *rvalue, void **avalue)
+ {
++  /*
++   * The final SYSV ABI says that structures smaller or equal 8 bytes
++   * are returned in r3/r4. The FFI_GCC_SYSV ABI instead returns them
++   * in memory.
++   *
++   * Just to keep things simple for the assembly code, we will always
++   * bounce-buffer struct return values less than or equal to 8 bytes.
++   * This allows the ASM to handle SYSV small structures by directly
++   * writing r3 and r4 to memory without worrying about struct size.
++   */
++  unsigned int smst_buffer[2];
+   extended_cif ecif;
+ 
+   ecif.cif = cif;
+   ecif.avalue = avalue;
+ 
+-  /* If the return value is a struct and we don't have a return	*/
+-  /* value address then we need to make one		        */
+-
+-  if ((rvalue == NULL) && (cif->rtype->type == FFI_TYPE_STRUCT))
+-    {
+-      ecif.rvalue = alloca(cif->rtype->size);
+-    }
+-  else
+-    ecif.rvalue = rvalue;
+-
++  /* Ensure that we have a valid struct return value */
++  ecif.rvalue = rvalue;
++  if (cif->rtype->type == FFI_TYPE_STRUCT) {
++	if (cif->rtype->size <= 8)
++		ecif.rvalue = smst_buffer;
++	else if (!rvalue)
++		ecif.rvalue = alloca(cif->rtype->size);
++  }
+ 
+   switch (cif->abi)
+     {
+@@ -967,6 +956,10 @@
+       FFI_ASSERT (0);
+       break;
+     }
++
++  /* Check for a bounce-buffered return value */
++  if (rvalue && ecif.rvalue == smst_buffer)
++	memcpy(rvalue, smst_buffer, cif->rtype->size);
+ }
+ 
+ 
+--- a/libffi/src/powerpc/sysv.S
++++ b/libffi/src/powerpc/sysv.S
+@@ -142,19 +142,14 @@
+ #endif
+ 
+ L(small_struct_return_value):
+-	extrwi	%r6,%r31,2,19         /* number of bytes padding = shift/8 */
+-	mtcrf	0x02,%r31	      /* copy flags to cr[24:27] (cr6) */
+-	extrwi	%r5,%r31,5,19         /* r5 <- number of bits of padding */
+-	subfic  %r6,%r6,4             /* r6 <- number of useful bytes in r3 */
+-	bf-	25,L(done_return_value) /* struct in r3 ? if not, done. */
+-/* smst_one_register: */
+-	slw	%r3,%r3,%r5           /* Left-justify value in r3 */
+-	mtxer	%r6                   /* move byte count to XER ... */
+-	stswx	%r3,0,%r30            /* ... and store that many bytes */
+-	bf+	26,L(done_return_value)  /* struct in r3:r4 ? */
+-	add	%r6,%r6,%r30          /* adjust pointer */
+-	stswi	%r4,%r6,4             /* store last four bytes */
+-	b	L(done_return_value)
++	/*
++	 * The C code always allocates a properly-aligned 8-byte bounce
++	 * buffer to make this assembly code very simple.  Just write out
++	 * r3 and r4 to the buffer to allow the C code to handle the rest.
++	 */
++	stw %r3, 0(%r30)
++	stw %r4, 4(%r30)
++	b L(done_return_value)
+ 
+ .LFE1:
+ END(ffi_call_SYSV)
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libffi-ro-eh_frame_sect.patch b/patches/gcc/linaro-4.6-2012.10/libffi-ro-eh_frame_sect.patch
--- a/patches/gcc/linaro-4.6-2012.10/libffi-ro-eh_frame_sect.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libffi-ro-eh_frame_sect.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,13 @@
+# DP: PR libffi/47248, force a read only eh frame section.
+
+--- a/libffi/configure.ac
++++ b/libffi/configure.ac
+@@ -347,6 +347,8 @@
+ 		libffi_cv_ro_eh_frame=yes
+ 	    fi
+ 	fi
++	# FIXME: see PR libffi/47248
++	libffi_cv_ro_eh_frame=yes
+ 	rm -f conftest.*
+     ])
+ if test "x$libffi_cv_ro_eh_frame" = xyes; then
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libgomp-kfreebsd-testsuite.patch b/patches/gcc/linaro-4.6-2012.10/libgomp-kfreebsd-testsuite.patch
--- a/patches/gcc/linaro-4.6-2012.10/libgomp-kfreebsd-testsuite.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libgomp-kfreebsd-testsuite.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,14 @@
+# DP: Disable lock-2.c test on kfreebsd-*
+
+--- a/libgomp/testsuite/libgomp.c/lock-2.c
++++ b/libgomp/testsuite/libgomp.c/lock-2.c
+@@ -4,6 +4,9 @@
+ int
+ main (void)
+ {
++#ifdef __FreeBSD_kernel__
++  return 1;
++#endif
+   int l = 0;
+   omp_nest_lock_t lock;
+   omp_init_nest_lock (&lock);
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libgomp-omp_h-multilib.patch b/patches/gcc/linaro-4.6-2012.10/libgomp-omp_h-multilib.patch
--- a/patches/gcc/linaro-4.6-2012.10/libgomp-omp_h-multilib.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libgomp-omp_h-multilib.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,19 @@
+# DP: Fix up omp.h for multilibs.
+
+2008-06-09  Jakub Jelinek  <jakub@redhat.com>
+
+	* omp.h.in (omp_nest_lock_t): Fix up for Linux multilibs.
+
+--- a/libgomp/omp.h.in
++++ b/libgomp/omp.h.in
+@@ -39,8 +39,8 @@
+ 
+ typedef struct
+ {
+-  unsigned char _x[@OMP_NEST_LOCK_SIZE@] 
+-    __attribute__((__aligned__(@OMP_NEST_LOCK_ALIGN@)));
++  unsigned char _x[8 + sizeof (void *)] 
++    __attribute__((__aligned__(sizeof (void *))));
+ } omp_nest_lock_t;
+ #endif
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-armel-unwind.patch b/patches/gcc/linaro-4.6-2012.10/libjava-armel-unwind.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-armel-unwind.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-armel-unwind.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,19 @@
+# DP: On armel, apply kludge to fix unwinder infinitely looping 'til it runs out
+# DP: of memory (http://gcc.gnu.org/ml/java/2008-06/msg00010.html).
+
+---
+ libjava/stacktrace.cc |    3 +++
+ 1 files changed, 3 insertions(+), 0 deletions(-)
+
+--- a/libjava/stacktrace.cc
++++ b/libjava/stacktrace.cc
+@@ -115,6 +115,9 @@ _Jv_StackTrace::UnwindTraceFn (struct _Unwind_Context *context, void *state_ptr)
+   // Check if the trace buffer needs to be extended.
+   if (pos == state->length)
+     {
++      // http://gcc.gnu.org/ml/java/2008-06/msg00010.html
++      return _URC_END_OF_STACK;
++
+       int newLength = state->length * 2;
+       void *newFrames = _Jv_AllocBytes (newLength * sizeof(_Jv_StackFrame));
+       memcpy (newFrames, state->frames, state->length * sizeof(_Jv_StackFrame));      
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-disable-plugin.patch b/patches/gcc/linaro-4.6-2012.10/libjava-disable-plugin.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-disable-plugin.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-disable-plugin.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,13 @@
+# DP: Don't build the gcjwebplugin, even when configured with --enable-plugin
+
+--- a/libjava/configure.ac
++++ b/libjava/configure.ac
+@@ -65,6 +65,8 @@
+      esac],
+     [browser_plugin_enabled=no]
+ )
++# FIXME: don't build the plugin, this option collides with GCC plugin support
++plugin_enabled=no
+ 
+ AC_ARG_ENABLE(gconf-peer,
+   AS_HELP_STRING([--enable-gconf-peer],
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-disable-static.patch b/patches/gcc/linaro-4.6-2012.10/libjava-disable-static.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-disable-static.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-disable-static.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,26 @@
+# DP: Disable building the static libjava.
+
+---
+ Makefile.in |    4 ++--
+ 1 files changed, 2 insertions(+), 2 deletions(-)
+
+--- a/Makefile.in
++++ b/Makefile.in
+@@ -53956,7 +53956,7 @@
+ 	rm -f no-such-file || : ; \
+ 	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+ 	  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \
+-	  --target=${target_alias} $${srcdiroption}  \
++	  --target=${target_alias} --disable-static $${srcdiroption}  \
+ 	  || exit 1
+ @endif target-libjava
+ 
+@@ -54870,7 +54870,7 @@
+ 	rm -f no-such-file || : ; \
+ 	CONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \
+ 	  $(TARGET_CONFIGARGS) --build=${build_alias} --host=${target_alias} \
+-	  --target=${target_alias} $${srcdiroption}  \
++	  --target=${target_alias} --disable-static $${srcdiroption}  \
+ 	  || exit 1
+ @endif target-boehm-gc
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-fixed-symlinks.patch b/patches/gcc/linaro-4.6-2012.10/libjava-fixed-symlinks.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-fixed-symlinks.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-fixed-symlinks.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,24 @@
+# DP: Remove unneed '..' elements from symlinks in JAVA_HOME
+
+--- a/libjava/Makefile.am
++++ b/libjava/Makefile.am
+@@ -831,7 +831,7 @@
+ 	$(mkinstalldirs) $(DESTDIR)$(SDK_INCLUDE_DIR)/$(OS)
+ 	relative() { \
+ 	  $(PERL) -e 'use File::Spec; \
+-	    print File::Spec->abs2rel($$ARGV[0], $$ARGV[1])' $$1 $$2; \
++	    print File::Spec->abs2rel($$ARGV[0], $$ARGV[1])' $$1 $$2 | sed -r 's,(bin|lib)[^/]*/\.\./,,'; \
+ 	}; \
+ 	RELATIVE=$$(relative $(DESTDIR)$(bindir) $(DESTDIR)$(SDK_BIN_DIR)); \
+ 	ln -sf $$RELATIVE/`echo gij | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` \
+--- a/libjava/Makefile.in
++++ b/libjava/Makefile.in
+@@ -12461,7 +12461,7 @@
+ @CREATE_JAVA_HOME_TRUE@	$(mkinstalldirs) $(DESTDIR)$(SDK_INCLUDE_DIR)/$(OS)
+ @CREATE_JAVA_HOME_TRUE@	relative() { \
+ @CREATE_JAVA_HOME_TRUE@	  $(PERL) -e 'use File::Spec; \
+-@CREATE_JAVA_HOME_TRUE@	    print File::Spec->abs2rel($$ARGV[0], $$ARGV[1])' $$1 $$2; \
++@CREATE_JAVA_HOME_TRUE@	    print File::Spec->abs2rel($$ARGV[0], $$ARGV[1])' $$1 $$2 | sed -r 's,(bin|lib)[^/]*/\.\./,,'; \
+ @CREATE_JAVA_HOME_TRUE@	}; \
+ @CREATE_JAVA_HOME_TRUE@	RELATIVE=$$(relative $(DESTDIR)$(bindir) $(DESTDIR)$(SDK_BIN_DIR)); \
+ @CREATE_JAVA_HOME_TRUE@	ln -sf $$RELATIVE/`echo gij | sed 's,^.*/,,;$(transform);s/$$/$(EXEEXT)/'` \
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-jnipath.patch b/patches/gcc/linaro-4.6-2012.10/libjava-jnipath.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-jnipath.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-jnipath.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,121 @@
+# DP: - Add /usr/lib/jni and /usr/lib/<multiarch>/jni to java.library.path.
+# DP: - When running the i386 binaries on amd64, look in
+# DP: - /usr/lib32/gcj-x.y and /usr/lib32/jni instead.
+
+--- a/libjava/configure.ac
++++ b/libjava/configure.ac
+@@ -1533,6 +1533,9 @@
+ 
+ AC_C_BIGENDIAN
+ 
++MULTIARCH_DIR=$(dpkg-architecture -qDEB_HOST_MULTIARCH 2>/dev/null || true)
++AC_SUBST(MULTIARCH_DIR)
++
+ ZLIBS=
+ SYS_ZLIBS=
+ ZINCS=
+--- a/libjava/Makefile.am
++++ b/libjava/Makefile.am
+@@ -362,6 +362,7 @@
+ 	$(WARNINGS) \
+ 	-D_GNU_SOURCE \
+ 	-DPREFIX="\"$(prefix)\"" \
++	-DMULTIARCH_DIR="\"$(MULTIARCH_DIR)\"" \
+ 	-DTOOLEXECLIBDIR="\"$(toolexeclibdir)\"" \
+         -DJAVA_HOME="\"$(JAVA_HOME_DIR)\"" \
+         -DBOOT_CLASS_PATH="\"$(BOOT_CLASS_PATH_DIR)\"" \
+--- a/libjava/Makefile.in
++++ b/libjava/Makefile.in
+@@ -626,6 +626,7 @@
+ MAKE = @MAKE@
+ MAKEINFO = @MAKEINFO@
+ MKDIR_P = @MKDIR_P@
++MULTIARCH_DIR = @MULTIARCH_DIR@
+ NM = nm
+ NMEDIT = @NMEDIT@
+ OBJDUMP = @OBJDUMP@
+@@ -1008,6 +1009,7 @@
+ 	$(WARNINGS) \
+ 	-D_GNU_SOURCE \
+ 	-DPREFIX="\"$(prefix)\"" \
++	-DMULTIARCH_DIR="\"$(MULTIARCH_DIR)\"" \
+ 	-DTOOLEXECLIBDIR="\"$(toolexeclibdir)\"" \
+         -DJAVA_HOME="\"$(JAVA_HOME_DIR)\"" \
+         -DBOOT_CLASS_PATH="\"$(BOOT_CLASS_PATH_DIR)\"" \
+--- a/libjava/gnu/classpath/natSystemProperties.cc
++++ b/libjava/gnu/classpath/natSystemProperties.cc
+@@ -141,6 +141,44 @@
+   return retval;
+ }
+ 
++static char*
++AppendJniLibdir (char *path, struct utsname *u)
++{
++  char* retval;
++  const char* jnilibdir = "/usr/lib/jni";
++#ifdef MULTIARCH_DIR
++  const char* jnilibdir2 = "/usr/lib/" MULTIARCH_DIR "/jni";
++  jsize len2 = strlen (jnilibdir2) + 2;
++#else
++  jsize len2 = 0;
++#endif
++
++#if defined(__linux__) && defined (__i386__)
++  if (! strcmp ("x86_64", u->machine))
++    jnilibdir = "/usr/lib32/jni";
++#endif
++
++  if (path)
++    {
++      jsize total = strlen (path)
++	+ (sizeof (PATH_SEPARATOR) - 1) + strlen (jnilibdir) +len2 + 1;
++      retval = (char*) _Jv_Malloc (total);
++      strcpy (retval, path);
++      strcat (retval, PATH_SEPARATOR);
++      strcat (retval, jnilibdir);
++    }
++  else
++    {
++      retval = (char*) _Jv_Malloc (strlen (jnilibdir) + len2 + 1);
++      strcpy (retval, jnilibdir);
++    }
++#ifdef MULTIARCH_DIR
++  strcat (retval, PATH_SEPARATOR);
++  strcat (retval, jnilibdir2);
++#endif
++  return retval;
++}
++
+ void
+ gnu::classpath::SystemProperties::insertSystemProperties (::java::util::Properties *newprops)
+ {
+@@ -373,8 +411,13 @@
+       // Prepend GCJ_VERSIONED_LIBDIR to the module load path so that
+       // libgcj will find its own JNI libraries, like libgtkpeer.so.
+       char* val = PrependVersionedLibdir (path);
+-      _Jv_SetDLLSearchPath (val);
++
++      // Append jnilibdir
++      char* val2 = AppendJniLibdir (val, &u);
++
++      _Jv_SetDLLSearchPath (val2);
+       _Jv_Free (val);
++      _Jv_Free (val2);
+     }
+   else
+     {
+@@ -382,9 +425,12 @@
+ #ifdef USE_LTDL
+       char *libpath = getenv (LTDL_SHLIBPATH_VAR);
+       char* val = _Jv_PrependVersionedLibdir (libpath);
+-      SET ("java.library.path", val);
+-      _Jv_SetDLLSearchPath (val);
++      // Append jnilibdir
++      char* val2 = AppendJniLibdir (val, &u);
++      SET ("java.library.path", val2);
++      _Jv_SetDLLSearchPath (val2);
+       _Jv_Free (val);
++      _Jv_Free (val2);
+ #else
+       SET ("java.library.path", "");
+ #endif
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-multiarch.patch b/patches/gcc/linaro-4.6-2012.10/libjava-multiarch.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-multiarch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-multiarch.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,72 @@
+# DP: Install libjava libraries to multiarch location
+
+--- a/libjava/configure.ac
++++ b/libjava/configure.ac
+@@ -1593,6 +1593,10 @@
+       .) toolexeclibdir=$toolexecmainlibdir ;; # Avoid trailing /.
+       *) toolexeclibdir=$toolexecmainlibdir/$multi_os_directory ;;
+     esac
++    multiarch=`$CC -print-multiarch`
++    if test -n "$multiarch"; then
++        toolexeclibdir=$toolexecmainlibdir/$multiarch
++    fi
+     ;;
+ esac
+ AC_SUBST(toolexecdir)
+@@ -1618,6 +1622,10 @@
+    dbexecdir='$(libdir)/'$multi_os_directory/$gcjsubdir
+    ;;
+ esac
++multiarch=`$CC -print-multiarch`
++if test -n "$multiarch"; then
++    dbexecdir='$(libdir)/'$multiarch/$gcjsubdir
++fi
+ AC_SUBST(dbexecdir)
+ AC_SUBST(gcjsubdir)
+ 
+--- a/libjava/Makefile.am
++++ b/libjava/Makefile.am
+@@ -371,7 +371,7 @@
+ 	-DGCJ_VERSIONED_LIBDIR="\"$(dbexecdir)\"" \
+ 	-DPATH_SEPARATOR="\"$(CLASSPATH_SEPARATOR)\"" \
+ 	-DECJ_JAR_FILE="\"$(ECJ_JAR)\"" \
+-	-DLIBGCJ_DEFAULT_DATABASE="\"$(dbexecdir)/$(db_name)\"" \
++	-DLIBGCJ_DEFAULT_DATABASE="\"/var/lib/$(MULTIARCH_DIR)/gcj-4.6/$(db_name)\"" \
+ 	-DLIBGCJ_DEFAULT_DATABASE_PATH_TAIL="\"$(db_pathtail)\""
+ 
+ AM_GCJFLAGS = \
+--- a/libjava/Makefile.in
++++ b/libjava/Makefile.in
+@@ -1018,7 +1018,7 @@
+ 	-DGCJ_VERSIONED_LIBDIR="\"$(dbexecdir)\"" \
+ 	-DPATH_SEPARATOR="\"$(CLASSPATH_SEPARATOR)\"" \
+ 	-DECJ_JAR_FILE="\"$(ECJ_JAR)\"" \
+-	-DLIBGCJ_DEFAULT_DATABASE="\"$(dbexecdir)/$(db_name)\"" \
++	-DLIBGCJ_DEFAULT_DATABASE="\"/var/lib/$(MULTIARCH_DIR)/gcj-4.6/$(db_name)\"" \
+ 	-DLIBGCJ_DEFAULT_DATABASE_PATH_TAIL="\"$(db_pathtail)\""
+ 
+ AM_GCJFLAGS = \
+--- a/libjava/classpath/m4/acinclude.m4
++++ b/libjava/classpath/m4/acinclude.m4
+@@ -252,6 +252,10 @@
+     .) toolexeclibdir=${libdir} ;; # Avoid trailing /.
+     *) toolexeclibdir=${libdir}/${multi_os_directory} ;;
+   esac
++  multiarch=`$CC -print-multiarch`
++  if test -n "$multiarch"; then
++    toolexeclibdir=${libdir}/${multiarch}
++  fi
+   AC_SUBST(toolexeclibdir)
+ ])
+ 
+--- a/libjava/classpath/configure.ac
++++ b/libjava/classpath/configure.ac
+@@ -16,6 +16,8 @@
+ 
+ AC_CANONICAL_TARGET
+ 
++dnl dummy change to run autoconf
++
+ dnl GCJ LOCAL
+ AC_ARG_ENABLE(java-maintainer-mode,
+ 	AS_HELP_STRING([--enable-java-maintainer-mode],
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-nobiarch-check.patch b/patches/gcc/linaro-4.6-2012.10/libjava-nobiarch-check.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-nobiarch-check.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-nobiarch-check.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,25 @@
+# DP: For biarch builds, disable the testsuite for the non-default architecture
+# DP: for runtime libraries, which are not built by default (libjava).
+
+---
+ libjava/testsuite/Makefile.in |    4 +++-
+ 2 files changed, 25 insertions(+), 1 deletions(-)
+
+--- a/libjava/testsuite/Makefile.in
++++ b/libjava/testsuite/Makefile.in
+@@ -380,12 +380,14 @@
+ 
+ 
+ check-DEJAGNU: site.exp
++	runtestflags="`echo '$(RUNTESTFLAGS)' | sed 's/,-m[36][24]//;s/,-mabi=n32//;s/,-mabi=64//'`"; \
++	case "$$runtestflags" in *\\{\\}) runtestflags=; esac; \
+ 	srcdir=`$(am__cd) $(srcdir) && pwd`; export srcdir; \
+ 	EXPECT=$(EXPECT); export EXPECT; \
+ 	runtest=$(RUNTEST); \
+ 	if $(SHELL) -c "$$runtest --version" > /dev/null 2>&1; then \
+ 	  exit_status=0; l='$(DEJATOOL)'; for tool in $$l; do \
+-	    if $$runtest $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) $(RUNTESTFLAGS); \
++	    if $$runtest $(AM_RUNTESTFLAGS) $(RUNTESTDEFAULTFLAGS) $$runtestflags; \
+ 	    then :; else exit_status=1; fi; \
+ 	  done; \
+ 	else echo "WARNING: could not find \`runtest'" 1>&2; :;\
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-sjlj.patch b/patches/gcc/linaro-4.6-2012.10/libjava-sjlj.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-sjlj.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-sjlj.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,38 @@
+# DP: Don't try to use _Unwind_Backtrace on SJLJ targets.
+# DP: See bug #387875, #388505, GCC PR 29206.
+
+---
+ libjava/sysdep/generic/backtrace.h |   17 +++++++++++++++++
+ 1 files changed, 17 insertions(+), 0 deletions(-)
+
+--- a/libjava/sysdep/generic/backtrace.h
++++ b/libjava/sysdep/generic/backtrace.h
+@@ -13,6 +13,20 @@
+ 
+ #include <java-stack.h>
+ 
++#ifdef SJLJ_EXCEPTIONS
++
++#undef _Unwind_GetIPInfo
++#define _Unwind_GetIPInfo(ctx,ip_before_insn) \
++  (abort (), (void) (ctx), *ip_before_insn = 1, 0)
++
++#undef _Unwind_GetRegionStart
++#define _Unwind_GetRegionStart(ctx) \
++  (abort (), (void) (ctx), 0)
++
++#undef _Unwind_Backtrace
++#define _Unwind_Backtrace(trace_fn,state_ptr) \
++  (fallback_backtrace (trace_fn, state_ptr))
++
+ /* Unwind through the call stack calling TRACE_FN with STATE for every stack
+    frame.  Returns the reason why the unwinding was stopped.  */
+ _Unwind_Reason_Code
+@@ -20,4 +34,7 @@
+ {
+   return _URC_NO_REASON;
+ }
++
++#endif /* SJLJ_EXCEPTIONS */
++
+ #endif
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libjava-stacktrace.patch b/patches/gcc/linaro-4.6-2012.10/libjava-stacktrace.patch
--- a/patches/gcc/linaro-4.6-2012.10/libjava-stacktrace.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libjava-stacktrace.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,50 @@
+# DP: libgcj: Lookup source file name and line number in separated
+# DP: debug files found in /usr/lib/debug
+
+---
+ libjava/stacktrace.cc |   27 +++++++++++++++++++++++++++
+ 1 files changed, 27 insertions(+), 0 deletions(-)
+
+--- a/libjava/stacktrace.cc
++++ b/libjava/stacktrace.cc
+@@ -17,6 +17,11 @@
+ #include <java-stack.h>
+ 
+ #include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++#ifdef HAVE_UNISTD_H
++#include <unistd.h>
++#endif
+ 
+ #include <java/lang/Boolean.h>
+ #include <java/lang/Class.h>
+@@ -260,6 +265,28 @@
+       finder->lookup (binaryName, (jlong) offset);
+       *sourceFileName = finder->getSourceFile();
+       *lineNum = finder->getLineNum();
++      if (*lineNum == -1 && info.file_name[0] == '/')
++	{
++	  const char *debugPrefix = "/usr/lib/debug";
++	  char *debugPath = (char *) malloc (strlen(debugPrefix)
++					     + strlen(info.file_name)
++					     + 2);
++
++	  if (debugPath)
++	    {
++	      strcpy (debugPath, debugPrefix);
++	      strcat (debugPath, info.file_name);
++	      //printf ("%s: 0x%x\n", debugPath, offset);
++	      if (!access (debugPath, R_OK))
++		{
++		  binaryName = JvNewStringUTF (debugPath);
++		  finder->lookup (binaryName, (jlong) offset);
++		  *sourceFileName = finder->getSourceFile();
++		  *lineNum = finder->getLineNum();
++		}
++	      free (debugPath);
++	    }
++	}
+       if (*lineNum == -1 && NameFinder::showRaw())
+         {
+           gnu::gcj::runtime::StringBuffer *t =
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libstdc++-arm-wno-abi.patch b/patches/gcc/linaro-4.6-2012.10/libstdc++-arm-wno-abi.patch
--- a/patches/gcc/linaro-4.6-2012.10/libstdc++-arm-wno-abi.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libstdc++-arm-wno-abi.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,16 @@
+# DP: Temporary work around:
+# DP: On arm-linux-gnueabi run the libstdc++v3 testsuite with -Wno-abi
+
+--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
++++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
+@@ -289,6 +289,10 @@
+     }
+     append cxxflags " "
+     append cxxflags [getenv CXXFLAGS]
++    # ARM C++ emits an ABI warning for varargs.
++    if [istarget "arm*"] {
++        append cxxflags " -Wno-abi"
++    }
+     v3track cxxflags 2
+ 
+     # Always use MO files built by this test harness.
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libstdc++-doclink.patch b/patches/gcc/linaro-4.6-2012.10/libstdc++-doclink.patch
--- a/patches/gcc/linaro-4.6-2012.10/libstdc++-doclink.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libstdc++-doclink.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,57 @@
+# DP: adjust hrefs to point to the local documentation
+
+---
+ libstdc++-v3/doc/doxygen/mainpage.html |   10 +++++-----
+ 1 files changed, 5 insertions(+), 5 deletions(-)
+
+--- a/libstdc++-v3/doc/doxygen/mainpage.html
++++ b/libstdc++-v3/doc/doxygen/mainpage.html
+@@ -29,8 +29,8 @@
+ <p>There are two types of documentation for libstdc++.  One is the
+    distribution documentation, which can be read online
+    <a href="http://gcc.gnu.org/onlinedocs/libstdc++/index.html">here</a>
+-   or offline from the file doc/html/index.html in the library source
+-   directory.
++   or offline in the documentation directory
++   <a href="manual/spine.html">here</a>.
+ </p>
+ 
+ <p>The other type is the source documentation, of which this is the first page.
+@@ -81,9 +81,9 @@
+   This style guide can also be viewed on the <a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01apas04.html">web</a>.
+ 
+ <h2>License, Copyright, and Other Lawyerly Verbosity</h2>
+-<p>The libstdc++ documentation is released under
+-   <a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/bk01pt01ch01s02.html">
+-   these terms</a>.
++<p>The libstdc++ documentation is released under these terms
++   (<a href="http://gcc.gnu.org/onlinedocs/libstdc++/manual/license.html">read online</a>, or
++   <a href="manual/license.html">read offline</a>).
+ </p>
+ <p>Part of the generated documentation involved comments and notes from
+    SGI, who says we gotta say this:
+--- a/libstdc++-v3/doc/html/api.html
++++ b/libstdc++-v3/doc/html/api.html
+@@ -19,6 +19,8 @@
+   member functions for the library classes, finding out what is in a
+   particular include file, looking at inheritance diagrams, etc.
+ </p><p>
++<a class="ulink" href="index.html"The API documentation, rendered into HTML, can be viewed offline.</a>
++</p><p>
+   The API documentation, rendered into HTML, can be viewed online:
+ </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
+       <a class="link" href="http://gcc.gnu.org/onlinedocs/libstdc++/libstdc++-html-USERS-3.4/index.html">for the 3.4 release
+--- a/libstdc++-v3/doc/xml/api.xml
++++ b/libstdc++-v3/doc/xml/api.xml
+@@ -36,6 +36,11 @@
+   particular include file, looking at inheritance diagrams, etc.
+ </para>
+ 
++ <para>
++  <ulink url="index.html">The source-level documentation for this release can be viewed offline.
++  </ulink>
++</para>
++
+ <para>
+   The API documentation, rendered into HTML, can be viewed online:
+ </para>
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libstdc++-man-3cxx.patch b/patches/gcc/linaro-4.6-2012.10/libstdc++-man-3cxx.patch
--- a/patches/gcc/linaro-4.6-2012.10/libstdc++-man-3cxx.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libstdc++-man-3cxx.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,91 @@
+# DP: Install libstdc++ man pages with suffix .3cxx instead of .3
+
+Index: b/libstdc++-v3/doc/doxygen/user.cfg.in
+===================================================================
+--- a/libstdc++-v3/doc/doxygen/user.cfg.in
++++ b/libstdc++-v3/doc/doxygen/user.cfg.in
+@@ -181,8 +181,8 @@
+ 
+ ALIASES = doctodo="@todo\nNeeds documentation! See http://gcc.gnu.org/onlinedocs/libstdc++/manual/documentation_style.html"
+ 
+-ALIASES += headername{1}="Instead, include <\1>."
+-ALIASES += headername{2}="Instead, include <\1> or <\2>."
++ALIASES += headername{1}="Instead, include \<\1\>."
++ALIASES += headername{2}="Instead, include \<\1\> or \<\2\>."
+ 
+ # Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C
+ # sources only. Doxygen will then generate output that is more tailored for C.
+@@ -1388,7 +1388,7 @@
+ # The MAN_EXTENSION tag determines the extension that is added to
+ # the generated man pages (default is the subroutine's section .3)
+ 
+-MAN_EXTENSION          = .3
++MAN_EXTENSION          = .3cxx
+ 
+ # If the MAN_LINKS tag is set to YES and Doxygen generates man output,
+ # then it will generate one additional man file for each entity
+Index: b/libstdc++-v3/scripts/run_doxygen
+===================================================================
+--- a/libstdc++-v3/scripts/run_doxygen
++++ b/libstdc++-v3/scripts/run_doxygen
+@@ -235,6 +235,9 @@
+ if $do_man; then
+ echo ::
+ echo :: Fixing up the man pages...
++mkdir -p $outdir/man/man3
++mv $outdir/man/man3cxx/* $outdir/man/man3/
++rmdir $outdir/man/man3cxx
+ cd $outdir/man/man3
+ 
+ # File names with embedded spaces (EVIL!) need to be....?  renamed or removed?
+@@ -256,7 +259,7 @@
+ # and I'm off getting coffee then anyhow, so I didn't care enough to make
+ # this super-fast.
+ g++ ${srcdir}/doc/doxygen/stdheader.cc -o ./stdheader
+-problematic=`egrep -l '#include <.*_.*>' [a-z]*.3`
++problematic=`egrep -l '#include <.*_.*>' [a-z]*.3 [a-z]*.3cxx`
+ for f in $problematic; do
+     # this is also slow, but safe and easy to debug
+     oldh=`sed -n '/fC#include </s/.*<\(.*\)>.*/\1/p' $f`
+@@ -269,7 +272,7 @@
+ # Some of the pages for generated modules have text that confuses certain
+ # implementations of man(1), e.g., Linux's.  We need to have another top-level
+ # *roff tag to /stop/ the .SH NAME entry.
+-problematic=`egrep --files-without-match '^\.SH SYNOPSIS' [A-Z]*.3`
++problematic=`egrep --files-without-match '^\.SH SYNOPSIS' [A-Z]*.3cxx`
+ #problematic='Containers.3 Sequences.3 Assoc_containers.3 Iterator_types.3'
+ 
+ for f in $problematic; do
+@@ -283,7 +286,7 @@
+ done
+ 
+ # Also, break this (generated) line up.  It's ugly as sin.
+-problematic=`grep -l '[^^]Definition at line' *.3`
++problematic=`grep -l '[^^]Definition at line' *.3 *.3cxx`
+ for f in $problematic; do
+     sed 's/Definition at line/\
+ .PP\
+@@ -388,8 +391,8 @@
+ 	 istringstream ostringstream stringstream filebuf ifstream \
+ 	 ofstream fstream string;
+ do
+-    echo ".so man3/std::basic_${f}.3" > std::${f}.3
+-    echo ".so man3/std::basic_${f}.3" > std::w${f}.3
++    echo ".so man3/std::basic_${f}.3cxx" > std::${f}.3cxx
++    echo ".so man3/std::basic_${f}.3cxx" > std::w${f}.3cxx
+ done
+ 
+ echo ::
+Index: b/libstdc++-v3/include/profile/impl/profiler_algos.h
+===================================================================
+--- a/libstdc++-v3/include/profile/impl/profiler_algos.h
++++ b/libstdc++-v3/include/profile/impl/profiler_algos.h
+@@ -24,7 +24,7 @@
+ /** @file profile/impl/profiler_algos.h
+  *  @brief Algorithms used by the profile extension.
+  *
+- *  This file is needed to avoid including <algorithm> or <bits/stl_algo.h>.
++ *  This file is needed to avoid including \<algorithm\> or \<bits/stl_algo.h\>.
+  *  Including those files would result in recursive includes.
+  *  These implementations are oversimplified.  In general, efficiency may be
+  *  sacrificed to minimize maintenance overhead.
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libstdc++-pic.patch b/patches/gcc/linaro-4.6-2012.10/libstdc++-pic.patch
--- a/patches/gcc/linaro-4.6-2012.10/libstdc++-pic.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libstdc++-pic.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,53 @@
+# DP: Build and install libstdc++_pic.a library.
+
+---
+ libstdc++-v3/Makefile.am |    4 ++++
+ libstdc++-v3/Makefile.in |    8 +++++++-
+ 2 files changed, 11 insertions(+), 1 deletions(-)
+
+--- a/libstdc++-v3/src/Makefile.am
++++ b/libstdc++-v3/src/Makefile.am
+@@ -445,6 +445,11 @@
+ 	  $(CXX) $(OPT_LDFLAGS) $(SECTION_LDFLAGS) $(AM_CXXFLAGS) $(LTLDFLAGS) -o $@
+ 
+ 
++install-exec-local:
++	$(AR) cru libstdc++_pic.a .libs/*.o $(top_builddir)/libsupc++/*.o || touch libstdc++_pic.a
++	$(MKDIR_P) $(DESTDIR)$(toolexeclibdir)
++	$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir)
++
+ # Added bits to build debug library.
+ if GLIBCXX_BUILD_DEBUG
+ all-local: build_debug
+--- a/libstdc++-v3/src/Makefile.in
++++ b/libstdc++-v3/src/Makefile.in
+@@ -725,7 +725,7 @@
+ 
+ install-dvi-am:
+ 
+-install-exec-am: install-toolexeclibLTLIBRARIES
++install-exec-am: install-exec-local install-toolexeclibLTLIBRARIES
+ 
+ install-html: install-html-am
+ 
+@@ -774,7 +774,7 @@
+ 	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+ 	info-am install install-am install-data install-data-am \
+ 	install-data-local install-dvi install-dvi-am install-exec \
+-	install-exec-am install-html install-html-am install-info \
++	install-exec-am install-exec-local install-html install-html-am install-info \
+ 	install-info-am install-man install-pdf install-pdf-am \
+ 	install-ps install-ps-am install-strip \
+ 	install-toolexeclibLTLIBRARIES installcheck installcheck-am \
+@@ -989,6 +989,11 @@
+ @GLIBCXX_LDBL_COMPAT_TRUE@compatibility-ldbl.o: compatibility-ldbl.cc
+ @GLIBCXX_LDBL_COMPAT_TRUE@	$(CXXCOMPILE) -mlong-double-64 -c $<
+ 
++install-exec-local:
++	$(AR) cru libstdc++_pic.a .libs/*.o $(top_builddir)/libsupc++/*.o || touch libstdc++_pic.a
++	$(MKDIR_P) $(DESTDIR)$(toolexeclibdir)
++	$(INSTALL_DATA) libstdc++_pic.a $(DESTDIR)$(toolexeclibdir)
++
+ # Added bits to build debug library.
+ @GLIBCXX_BUILD_DEBUG_TRUE@all-local: build_debug
+ @GLIBCXX_BUILD_DEBUG_TRUE@install-data-local: install_debug
diff -Nru a/patches/gcc/linaro-4.6-2012.10/libstdc++-test-installed.patch b/patches/gcc/linaro-4.6-2012.10/libstdc++-test-installed.patch
--- a/patches/gcc/linaro-4.6-2012.10/libstdc++-test-installed.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/libstdc++-test-installed.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,76 @@
+# DP: Add support to run the libstdc++-v3 testsuite using the
+# DP: installed shared libraries.
+
+--- a/libstdc++-v3/testsuite/lib/libstdc++.exp
++++ b/libstdc++-v3/testsuite/lib/libstdc++.exp
+@@ -38,6 +38,12 @@
+ # the last thing before testing begins.  This can be defined in, e.g.,
+ # ~/.dejagnurc or $DEJAGNU.
+ 
++set test_installed 0
++if [info exists env(TEST_INSTALLED)] {
++    verbose -log "test installed libstdc++-v3"
++    set test_installed 1
++}
++
+ proc load_gcc_lib { filename } {
+     global srcdir
+     load_file $srcdir/../../gcc/testsuite/lib/$filename
+@@ -94,6 +100,7 @@
+     global tool_timeout
+     global DEFAULT_CXXFLAGS
+     global STATIC_LIBCXXFLAGS
++    global test_installed
+ 
+     # We set LC_ALL and LANG to C so that we get the same error
+     # messages as expected.
+@@ -109,6 +116,9 @@
+ 
+     set blddir [lookfor_file [get_multilibs] libstdc++-v3]
+     set flags_file "${blddir}/scripts/testsuite_flags"
++    if {$test_installed} {
++      set flags_file "${blddir}/scripts/testsuite_flags.installed"
++    }
+     set shlib_ext [get_shlib_extension]
+     v3track flags_file 2
+ 
+@@ -140,7 +150,11 @@
+ 
+     # Locate libgcc.a so we don't need to account for different values of
+     # SHLIB_EXT on different platforms
+-    set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]
++    if {$test_installed} {
++	set gccdir ""
++    } else {
++	set gccdir [lookfor_file $tool_root_dir gcc/libgcc.a]
++    }
+     if {$gccdir != ""} {
+         set gccdir [file dirname $gccdir]
+ 	append ld_library_path_tmp ":${gccdir}"
+@@ -149,7 +163,11 @@
+ 
+     # Locate libgomp. This is only required for parallel mode.
+     set v3-libgomp 0
+-    set libgompdir [lookfor_file $blddir/../libgomp .libs/libgomp.$shlib_ext]
++    if {$test_installed} {
++	set libgompdir ""
++    } else {
++	set libgompdir [lookfor_file $blddir/../libgomp .libs/libgomp.$shlib_ext]
++    }
+     if {$libgompdir != ""} {
+ 	set v3-libgomp 1
+         set libgompdir [file dirname $libgompdir]
+@@ -160,7 +178,12 @@
+ 
+     # Locate libstdc++ shared library. (ie libstdc++.so.)
+     set v3-sharedlib 0
+-    set sharedlibdir [lookfor_file $blddir src/.libs/libstdc++.$shlib_ext]
++    if {$test_installed} {
++	set sharedlibdir ""
++	set v3-sharedlib 1
++    } else {
++	set sharedlibdir [lookfor_file $blddir src/.libs/libstdc++.$shlib_ext]
++    }
+     if {$sharedlibdir != ""} {
+ 	if { [string match "*-*-linux*" $target_triplet] && [isnative] } {
+ 	    set v3-sharedlib 1
diff -Nru a/patches/gcc/linaro-4.6-2012.10/m68k-fp-cmp-zero.patch b/patches/gcc/linaro-4.6-2012.10/m68k-fp-cmp-zero.patch
--- a/patches/gcc/linaro-4.6-2012.10/m68k-fp-cmp-zero.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/m68k-fp-cmp-zero.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,118 @@
+[backport proposed and approved but not yet applied fix for a
+ wrong-code bug in m68k fp compares with zero <mikpe@it.uu.se>]
+
+Date: Wed, 19 Oct 2011 22:29:36 +0100
+From: Julian Brown <julian at codesourcery dot com>
+Subject: [PATCH, m68k] Fix floating-point comparisons with zero
+List-Archive: <http://gcc.gnu.org/ml/gcc-patches/>
+
+Hi,
+
+It appears that m68k floating-point comparisons may have been
+subtly broken since 2007 when the following patch was applied:
+
+  http://gcc.gnu.org/ml/gcc-patches/2007-09/msg01570.html
+
+The bug shows with our internal 4.6-based branch, but appears to be
+latent on mainline (generated code is perturbed by r171236, an
+apparently-unrelated change -- if that commit alone is reverted, the bug
+reappears on current trunk). The discussion below was written wrt. the
+previously-mentioned 4.6 branch, so details may be slightly different on
+mainline, but the outcome is the same.
+
+The trouble is the code introduced in m68k.c:notice_update_cc, intended
+to reverse the sense of comparisons for one particular
+*cmp<mode>_68881/*cmp<mode>_cf alternative, inadvertently also inverts
+the sense for tst<mode>_68881/tst<mode>_cf (FP comparisons against
+zero).
+
+For the test case gcc.c-torture/execute/ieee/20010114-2.c, the
+badness only triggers when -freorder-blocks is in effect (-O2 and
+above). Two comparisons (of the same variable) against zero are munged
+into one in final.c after basic-block reordering makes them
+consecutive, and we get:
+
+	ftst.s %d0	| x
+	fjgt .L13	|
+(final.c omits a redundant "ftst.s %d0" here)
+	fjngt .L2	|
+
+when we ought to have got:
+
+	ftst.s %d0	| x
+	fjgt .L13	|
+	fjnlt .L2	|
+
+The bug only triggers due to the omission of the test, else it would
+happen (far) more often: if the ftst is actually emitted, the flags get
+reset before any harm can be done:
+
+(define_insn "tst<mode>_68881"
+  [(set (cc0)
+	(compare (match_operand:FP 0 "general_operand" "f<FP:dreg>m")
+		 (match_operand:FP 1 "const0_operand" "H")))]
+  "TARGET_68881"
+{
+  cc_status.flags = CC_IN_68881;  /* unsets CC_REVERSED & other flags */
+  ...
+
+but, when final.c decides the second ftst is redundant, nothing unsets
+CC_REVERSED, so we actually (incorrectly) treat the comparison as
+having been done with reversed operands.
+
+We can fix this by never setting CC_REVERSED for ftst instructions in
+the first place. The problem is that the test (in notice_update_cc),
+
+  if (cc_status.value2 && GET_CODE (cc_status.value2) == COMPARE
+      && GET_MODE_CLASS (GET_MODE (XEXP (cc_status.value2, 0))) == MODE_FLOAT)
+    {
+      cc_status.flags = CC_IN_68881;
+      if (!FP_REG_P (XEXP (cc_status.value2, 0)))
+	cc_status.flags |= CC_REVERSED;
+    }
+
+is not strict enough, and triggers for ftst instructions (even elided
+ones), as well as for the intended third alternative of fcmp.
+
+So, the fix is to tighten up the inner condition to not trigger for
+ftst. The attached patch does that, and we get the following test result
+delta (as well as some noise in libstdc++ results, but I think those
+are environment-related):
+
+FAIL -> PASS: gcc.c-torture/execute/ieee/20010114-2.c execution,  -O2 
+FAIL -> PASS: gcc.c-torture/execute/ieee/20010114-2.c execution,  -O3 -fomit-frame-pointer 
+FAIL -> PASS: gcc.c-torture/execute/ieee/20010114-2.c execution,  -O3 -g 
+FAIL -> PASS: gcc.c-torture/execute/ieee/20030331-1.c execution,  -O2 
+FAIL -> PASS: gcc.c-torture/execute/ieee/20030331-1.c execution,  -O3 -fomit-frame-pointer 
+FAIL -> PASS: gcc.c-torture/execute/ieee/20030331-1.c execution,  -O3 -g 
+
+These results are against mainline *with r171236 reverted*, cross to
+ColdFire Linux -- otherwise results are the same before/after. I believe
+the patch is still needed regardless though.
+
+OK to apply?
+
+Thanks,
+
+Julian
+
+ChangeLog
+
+    gcc/
+    * config/m68k/m68k.c (notice_update_cc): Tighten condition for
+    setting CC_REVERSED for FP comparisons.
+
+Index: gcc-4.6-4.6.3/gcc/config/m68k/m68k.c
+===================================================================
+--- gcc-4.6-4.6.3.orig/gcc/config/m68k/m68k.c	2012-03-04 15:55:43.000000000 +0000
++++ gcc-4.6-4.6.3/gcc/config/m68k/m68k.c	2012-03-04 15:59:23.000000000 +0000
+@@ -4306,7 +4306,8 @@
+       && GET_MODE_CLASS (GET_MODE (XEXP (cc_status.value2, 0))) == MODE_FLOAT)
+     {
+       cc_status.flags = CC_IN_68881;
+-      if (!FP_REG_P (XEXP (cc_status.value2, 0)))
++      if (!FP_REG_P (XEXP (cc_status.value2, 0))
++	  && FP_REG_P (XEXP (cc_status.value2, 1)))
+ 	cc_status.flags |= CC_REVERSED;
+     }
+ }
diff -Nru a/patches/gcc/linaro-4.6-2012.10/mips-fix-loongson2f-nop.patch b/patches/gcc/linaro-4.6-2012.10/mips-fix-loongson2f-nop.patch
--- a/patches/gcc/linaro-4.6-2012.10/mips-fix-loongson2f-nop.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/mips-fix-loongson2f-nop.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,13 @@
+# DP: On mips, pass -mfix-loongson2f-nop to as, if -mno-fix-loongson2f-nop
+# DP: is not passed.
+
+--- a/gcc/config/mips/mips.h
++++ b/gcc/config/mips/mips.h
+@@ -1142,6 +1142,7 @@
+ %{mshared} %{mno-shared} \
+ %{msym32} %{mno-sym32} \
+ %{mtune=*} \
++%{!mno-fix-loongson2f-nop:-mfix-loongson2f-nop} \
+ %(subtarget_asm_spec)"
+ 
+ /* Extra switches sometimes passed to the linker.  */
diff -Nru a/patches/gcc/linaro-4.6-2012.10/mips-triarch.patch b/patches/gcc/linaro-4.6-2012.10/mips-triarch.patch
--- a/patches/gcc/linaro-4.6-2012.10/mips-triarch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/mips-triarch.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,44 @@
+# DP: Build a tri-arch compiler on mips-linux-gnu.
+# DP: http://gcc.gnu.org/ml/gcc-patches/2009-03/msg01047.html
+
+2009-06-13  Matthias Klose <doko@debian.org>
+	    Arthur Loiret  <aloiret@debian.org>
+
+	* config.gcc (mips*-*-linux*): If 'enabled_targets' is 'all', build
+	a tri-arch compiler defaulting to 32-bit (ABI o32). In this case:
+	(tm_file): Add mips/linux64.h.
+	(tmake_file): Add mips/t-linux64.
+	(tm_defines): Add MIPS_ABI_DEFAULT=ABI_32.
+	* config/mips/linux64.h (DRIVER_SELF_SPECS): Use MULTILIB_ABI_DEFAULT
+	instead of hardcoded mabi=n32.
+	* config/mips/t-linux64 (MULTILIB_DIRNAMES): Set to 'n32 . 64' if
+	tm_defines contains MIPS_ABI_DEFAULT ABI_32, to follow the glibc
+	convention.
+	* doc/install.texi: Add mips-linux to the list of targets supporting
+	--enable-targets=all. Document the effect on mips.
+
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -1902,6 +1902,11 @@
+ mips*-*-linux*)				# Linux MIPS, either endian.
+         tm_file="dbxelf.h elfos.h gnu-user.h linux.h glibc-stdint.h ${tm_file} mips/linux.h"
+ 	tmake_file="${tmake_file} mips/t-libgcc-mips16"
++	if test x$enable_targets = xall; then
++		tm_file="${tm_file} mips/linux64.h"
++		tmake_file="${tmake_file} mips/t-linux64"
++		tm_defines="${tm_defines} MIPS_ABI_DEFAULT=ABI_32"
++	fi
+ 	case ${target} in
+         mipsisa32r2*)
+ 		tm_defines="${tm_defines} MIPS_ISA_DEFAULT=33"
+--- a/gcc/config/mips/linux64.h
++++ b/gcc/config/mips/linux64.h
+@@ -26,7 +26,7 @@
+   BASE_DRIVER_SELF_SPECS, \
+   LINUX_DRIVER_SELF_SPECS \
+   " %{!EB:%{!EL:%(endian_spec)}}" \
+-  " %{!mabi=*: -mabi=n32}"
++  " %{!mabi=*: -" MULTILIB_ABI_DEFAULT "}"
+ 
+ #undef LIB_SPEC
+ #define LIB_SPEC "\
diff -Nru a/patches/gcc/linaro-4.6-2012.10/mudflapth-link.patch b/patches/gcc/linaro-4.6-2012.10/mudflapth-link.patch
--- a/patches/gcc/linaro-4.6-2012.10/mudflapth-link.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/mudflapth-link.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,24 @@
+# DP: Link libmudflapth.so with -lpthread
+
+--- a/libmudflap/Makefile.am
++++ b/libmudflap/Makefile.am
+@@ -44,7 +44,7 @@
+ 	mf-hooks2.c \
+ 	mf-hooks3.c
+ libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH
+-libmudflapth_la_LIBADD =
++libmudflapth_la_LIBADD = -lpthread
+ libmudflapth_la_DEPENDENCIES = $(libmudflapth_la_LIBADD)
+ libmudflapth_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
+ 
+--- a/libmudflap/Makefile.in
++++ b/libmudflap/Makefile.in
+@@ -288,7 +288,7 @@
+ 	mf-hooks3.c
+ 
+ libmudflapth_la_CFLAGS = -DLIBMUDFLAPTH
+-libmudflapth_la_LIBADD = 
++libmudflapth_la_LIBADD = -lpthread
+ libmudflapth_la_DEPENDENCIES = $(libmudflapth_la_LIBADD)
+ libmudflapth_la_LDFLAGS = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
+ 
diff -Nru a/patches/gcc/linaro-4.6-2012.10/mudflap-varargs.patch b/patches/gcc/linaro-4.6-2012.10/mudflap-varargs.patch
--- a/patches/gcc/linaro-4.6-2012.10/mudflap-varargs.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/mudflap-varargs.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,19 @@
+# DP: Add mudflap support for varargs
+
+From: Michael Matz <matz@suse.de>
+Subject: Fix pass49-frag (mudflap support for varargs)
+
+	* builtins.c (build_va_arg_indirect_ref): Use
+	build_simple_mem_ref_loc.
+
+--- a/gcc/builtins.c
++++ b/gcc/builtins.c
+@@ -4772,7 +4772,7 @@
+ tree
+ build_va_arg_indirect_ref (tree addr)
+ {
+-  addr = build_fold_indirect_ref_loc (EXPR_LOCATION (addr), addr);
++  addr = build_simple_mem_ref_loc (EXPR_LOCATION (addr), addr);
+ 
+   if (flag_mudflap) /* Don't instrument va_arg INDIRECT_REF.  */
+     mf_mark (addr);
diff -Nru a/patches/gcc/linaro-4.6-2012.10/no_fpr_in_libgcc.patch b/patches/gcc/linaro-4.6-2012.10/no_fpr_in_libgcc.patch
--- a/patches/gcc/linaro-4.6-2012.10/no_fpr_in_libgcc.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/no_fpr_in_libgcc.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,49 @@
+# DP: It does not really harm by including them since nobody should use them
+# DP: but gas does not wont to assmebly hard float since they are not
+# DP: available on this cpu. Upstream did not respond.
+
+--- a/gcc/config/rs6000/crtresfpr.asm
++++ b/gcc/config/rs6000/crtresfpr.asm
+@@ -33,6 +33,7 @@
+ 
+ /* On PowerPC64 Linux, these functions are provided by the linker.  */
+ #ifndef __powerpc64__
++#ifndef __NO_FPRS__
+ 
+ /* Routines for restoring floating point registers, called by the compiler.  */
+ /* Called with r11 pointing to the stack header word of the caller of the */
+@@ -79,3 +80,4 @@
+ CFI_ENDPROC
+ 
+ #endif
++#endif
+--- a/gcc/config/rs6000/crtresxfpr.asm
++++ b/gcc/config/rs6000/crtresxfpr.asm
+@@ -33,6 +33,7 @@
+ 
+ /* On PowerPC64 Linux, these functions are provided by the linker.  */
+ #ifndef __powerpc64__
++#ifndef __NO_FPRS__
+ 
+ /* Routines for restoring floating point registers, called by the compiler.  */
+ /* Called with r11 pointing to the stack header word of the caller of the */
+@@ -124,3 +125,4 @@
+ CFI_ENDPROC
+ 
+ #endif
++#endif
+--- a/gcc/config/rs6000/crtsavfpr.asm
++++ b/gcc/config/rs6000/crtsavfpr.asm
+@@ -33,6 +33,7 @@
+ 
+ /* On PowerPC64 Linux, these functions are provided by the linker.  */
+ #ifndef __powerpc64__
++#ifndef __NO_FPRS__
+ 
+ /* Routines for saving floating point registers, called by the compiler.  */
+ /* Called with r11 pointing to the stack header word of the caller of the */
+@@ -79,3 +80,4 @@
+ CFI_ENDPROC
+ 
+ #endif
++#endif
diff -Nru a/patches/gcc/linaro-4.6-2012.10/note-gnu-stack.patch b/patches/gcc/linaro-4.6-2012.10/note-gnu-stack.patch
--- a/patches/gcc/linaro-4.6-2012.10/note-gnu-stack.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/note-gnu-stack.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,170 @@
+# DP: Add .note.GNU-stack sections for gcc's crt files, libffi and boehm-gc
+# DP: Taken from FC.
+
+gcc/
+
+2004-09-20  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/rs6000/ppc-asm.h: Add .note.GNU-stack section also
+	on ppc64-linux.
+
+	* config/ia64/lib1funcs.asm: Add .note.GNU-stack section on
+	ia64-linux.
+	* config/ia64/crtbegin.asm: Likewise.
+	* config/ia64/crtend.asm: Likewise.
+	* config/ia64/crti.asm: Likewise.
+	* config/ia64/crtn.asm: Likewise.
+
+2004-05-14  Jakub Jelinek  <jakub@redhat.com>
+
+	* config/ia64/linux.h (TARGET_ASM_FILE_END): Define.
+
+boehm-gc/
+
+2005-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* ia64_save_regs_in_stack.s: Moved to...
+	* ia64_save_regs_in_stack.S: ... this.  Add .note.GNU-stack
+	on Linux.
+
+libffi/
+
+2007-05-11  Daniel Jacobowitz  <dan@debian.org>
+
+	* src/arm/sysv.S: Fix ARM comment marker.
+
+2005-02-08  Jakub Jelinek  <jakub@redhat.com>
+
+	* src/alpha/osf.S: Add .note.GNU-stack on Linux.
+	* src/s390/sysv.S: Likewise.
+	* src/powerpc/linux64.S: Likewise.
+	* src/powerpc/linux64_closure.S: Likewise.
+	* src/powerpc/ppc_closure.S: Likewise.
+	* src/powerpc/sysv.S: Likewise.
+	* src/x86/unix64.S: Likewise.
+	* src/x86/sysv.S: Likewise.
+	* src/sparc/v8.S: Likewise.
+	* src/sparc/v9.S: Likewise.
+	* src/m68k/sysv.S: Likewise.
+	* src/ia64/unix.S: Likewise.
+	* src/arm/sysv.S: Likewise.
+
+---
+ boehm-gc/ia64_save_regs_in_stack.s   |   12 ------------
+ gcc/config/ia64/crtbegin.asm         |    4 ++++
+ gcc/config/ia64/crtend.asm           |    4 ++++
+ gcc/config/ia64/crti.asm             |    4 ++++
+ gcc/config/ia64/crtn.asm             |    4 ++++
+ gcc/config/ia64/lib1funcs.asm        |    4 ++++
+ gcc/config/ia64/linux.h              |    2 ++
+ gcc/config/rs6000/ppc-asm.h          |    2 +-
+ libffi/ia64/unix.S               |    4 ++++
+ libffi/powerpc/linux64.S         |    4 ++++
+ libffi/powerpc/linux64_closure.S |    4 ++++
+ 11 files changed, 35 insertions(+), 13 deletions(-)
+
+--- a/boehm-gc/ia64_save_regs_in_stack.s
++++ /dev/null
+@@ -1,12 +0,0 @@
+-        .text
+-        .align 16
+-        .global GC_save_regs_in_stack
+-        .proc GC_save_regs_in_stack
+-GC_save_regs_in_stack:
+-        .body
+-        flushrs
+-        ;;
+-        mov r8=ar.bsp
+-        br.ret.sptk.few rp
+-        .endp GC_save_regs_in_stack
+-
+--- /dev/null
++++ b/boehm-gc/ia64_save_regs_in_stack.S
+@@ -0,0 +1,15 @@
++        .text
++        .align 16
++        .global GC_save_regs_in_stack
++        .proc GC_save_regs_in_stack
++GC_save_regs_in_stack:
++        .body
++        flushrs
++        ;;
++        mov r8=ar.bsp
++        br.ret.sptk.few rp
++        .endp GC_save_regs_in_stack
++
++#ifdef __linux__
++	.section .note.GNU-stack,"",@progbits
++#endif
+--- a/gcc/config/ia64/crtbegin.asm
++++ b/gcc/config/ia64/crtbegin.asm
+@@ -252,3 +252,7 @@
+ .weak __cxa_finalize
+ #endif
+ .weak _Jv_RegisterClasses
++
++#ifdef __linux__
++.section .note.GNU-stack; .previous
++#endif
+--- a/gcc/config/ia64/crtend.asm
++++ b/gcc/config/ia64/crtend.asm
+@@ -119,3 +119,7 @@
+ 
+ 	br.ret.sptk.many rp
+ 	.endp __do_global_ctors_aux
++
++#ifdef __linux__
++.section .note.GNU-stack; .previous
++#endif
+--- a/gcc/config/ia64/crti.asm
++++ b/gcc/config/ia64/crti.asm
+@@ -51,3 +51,7 @@
+ 	.body
+ 
+ # end of crti.asm
++
++#ifdef __linux__
++.section .note.GNU-stack; .previous
++#endif
+--- a/gcc/config/ia64/crtn.asm
++++ b/gcc/config/ia64/crtn.asm
+@@ -41,3 +41,7 @@
+ 	br.ret.sptk.many b0
+ 
+ # end of crtn.asm
++
++#ifdef __linux__
++.section .note.GNU-stack; .previous
++#endif
+--- a/gcc/config/ia64/lib1funcs.asm
++++ b/gcc/config/ia64/lib1funcs.asm
+@@ -793,3 +793,7 @@
+ 	.endp __floattitf
+ #endif
+ #endif
++
++#ifdef __linux__
++.section .note.GNU-stack; .previous
++#endif
+--- a/gcc/config/ia64/linux.h
++++ b/gcc/config/ia64/linux.h
+@@ -29,6 +29,8 @@
+ 
+ #define TARGET_VERSION fprintf (stderr, " (IA-64) Linux");
+ 
++#define TARGET_ASM_FILE_END file_end_indicate_exec_stack
++
+ /* This is for -profile to use -lc_p instead of -lc.  */
+ #undef CC1_SPEC
+ #define CC1_SPEC "%{profile:-p} %{G*}"
+--- a/gcc/config/rs6000/ppc-asm.h
++++ b/gcc/config/rs6000/ppc-asm.h
+@@ -352,7 +352,7 @@
+ #endif
+ #endif
+ 
+-#if defined __linux__ && !defined __powerpc64__
++#if defined __linux__
+ 	.section .note.GNU-stack
+ 	.previous
+ #endif
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr24619.patch b/patches/gcc/linaro-4.6-2012.10/pr24619.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr24619.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr24619.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,17 @@
+# DP: Proposed patch for PR mudflap/24619 (instrumentation of dlopen)
+
+--- a/libmudflap/mf-hooks2.c
++++ b/libmudflap/mf-hooks2.c
+@@ -1674,8 +1674,10 @@
+   size_t n;
+   TRACE ("%s\n", __PRETTY_FUNCTION__);
+   n = strlen (path);
+-  MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, "dlopen path");
+-  p = dlopen (path, flags);
++  if (NULL != path) {
++    MF_VALIDATE_EXTENT (path, CLAMPADD(n, 1), __MF_CHECK_READ, "dlopen path");
++    p = dlopen (path, flags);
++  }
+   if (NULL != p) {
+ #ifdef MF_REGISTER_dlopen
+     __mf_register (p, 0, MF_REGISTER_dlopen, "dlopen result");
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr43804.patch b/patches/gcc/linaro-4.6-2012.10/pr43804.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr43804.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr43804.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,20 @@
+# DP: Fix for PR target/43804 backported from SVN
+
+2011-04-24  Richard Sandiford  <richard.sandiford@linaro.org>
+
+	PR target/43804
+	* config/m68k/constraints.md (T): Allow PIC operands that satisfy
+	LEGITIMATE_PIC_OPERAND_P.
+
+--- a/gcc/config/m68k/constraints.md
++++ b/gcc/config/m68k/constraints.md
+@@ -94,7 +94,8 @@
+ (define_constraint "T"
+   "Used for operands that satisfy 's' when -mpcrel is not in effect."
+   (and (match_code "symbol_ref,label_ref,const")
+-       (match_test "!flag_pic")))
++       (match_test "!TARGET_PCREL")
++       (match_test "!flag_pic || LEGITIMATE_PIC_OPERAND_P (op)")))
+ 
+ (define_memory_constraint "Q"
+   "Means address register indirect addressing mode."
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr45078.patch b/patches/gcc/linaro-4.6-2012.10/pr45078.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr45078.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr45078.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,41 @@
+# DP: Proposed patch for PR plugin/45078
+
+2011-06-24  Matthias Klose  <doko@ubuntu.com>
+
+	PR plugin/45078
+	* Makefile.in (PLUGIN_HEADERS): Add config/arm/arm-cores.def.
+	(install-plugin): Install c-family headers into a c-family subdir.
+	* config.gcc: Add vxworks-dummy.h to tm_file for arm, mips, sh and
+	sparc targets.
+
+--- a/gcc/Makefile.in
++++ b/gcc/Makefile.in
+@@ -4502,6 +4502,7 @@
+   $(EXCEPT_H) tree-ssa-sccvn.h real.h output.h $(IPA_UTILS_H) \
+   $(C_PRAGMA_H)  $(CPPLIB_H)  $(FUNCTION_H) \
+   cppdefault.h flags.h $(MD5_H) params.def params.h prefix.h tree-inline.h \
++  config/arm/arm-cores.def \
+   $(IPA_PROP_H) $(RTL_H) $(TM_P_H) $(CFGLOOP_H) $(EMIT_RTL_H) version.h
+ 
+ # generate the 'build fragment' b-header-vars
+@@ -4526,7 +4527,7 @@
+ 	  else continue; \
+ 	  fi; \
+ 	  case $$path in \
+-	  "$(srcdir)"/config/* | "$(srcdir)"/*.def ) \
++	  "$(srcdir)"/config/* | "$(srcdir)"/c-family/* | "$(srcdir)"/*.def ) \
+ 	    base=`echo "$$path" | sed -e "s|$$srcdirstrip/||"`;; \
+ 	  *) base=`basename $$path` ;; \
+ 	  esac; \
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -468,6 +468,9 @@
+ 	fi
+ 	tm_file="vxworks-dummy.h ${tm_file}"
+ 	;;
++arm*-*-*|mips*-*-*|sh*-*-*|sparc*-*-*)
++	tm_file="vxworks-dummy.h ${tm_file}"
++	;;
+ esac
+ 
+ # On a.out targets, we need to use collect2.
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr47487.patch b/patches/gcc/linaro-4.6-2012.10/pr47487.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr47487.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr47487.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,24 @@
+# DP: Fix PR target/47487 powerpc64 ICE building libgo
+
+
+	PR target/47487
+	* config/rs6000/rs6000.c (rs6000_output_function_epilogue): Support
+	GNU Go in traceback table.
+
+--- a/gcc/config/rs6000/rs6000.c
++++ b/gcc/config/rs6000/rs6000.c
+@@ -22053,10 +22053,11 @@
+ 	 use language_string.
+ 	 C is 0.  Fortran is 1.  Pascal is 2.  Ada is 3.  C++ is 9.
+ 	 Java is 13.  Objective-C is 14.  Objective-C++ isn't assigned
+-	 a number, so for now use 9.  LTO isn't assigned a number either,
+-	 so for now use 0.  */
++	 a number, so for now use 9.  LTO and Go aren't assigned numbers
++	 either, so for now use 0.  */
+       if (! strcmp (language_string, "GNU C")
+-	  || ! strcmp (language_string, "GNU GIMPLE"))
++	  || ! strcmp (language_string, "GNU GIMPLE")
++	  || ! strcmp (language_string, "GNU Go"))
+ 	i = 0;
+       else if (! strcmp (language_string, "GNU F77")
+ 	       || ! strcmp (language_string, "GNU Fortran"))
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr47818.patch b/patches/gcc/linaro-4.6-2012.10/pr47818.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr47818.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr47818.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,22 @@
+# DP: Fix PR ada/47818: Pragma Assert is rejected with No_Implementation_Pragmas restriction.
+
+--- a/gcc/ada/sem_prag.adb
++++ b/gcc/ada/sem_prag.adb
+@@ -6477,7 +6477,16 @@
+             --  Set True if category of assertions referenced by Name enabled
+ 
+          begin
+-            GNAT_Pragma;
++            --  This could be a rewritten pragma Assert. If it is the case
++            --  then don't check restrictions, because they are different for
++            --  pragma Assert and were already checked.
++
++            if Nkind (Original_Node (N)) /= N_Pragma
++              or else Pragma_Name (Original_Node (N)) /= Name_Assert
++            then
++               GNAT_Pragma;
++            end if;
++
+             Check_At_Least_N_Arguments (2);
+             Check_At_Most_N_Arguments (3);
+             Check_Optional_Identifier (Arg1, Name_Name);
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr47955.patch b/patches/gcc/linaro-4.6-2012.10/pr47955.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr47955.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr47955.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,17 @@
+# DP: Backport m68k bugfix from gcc-4.7/trunk
+
+Index: gcc-4.6-4.6.3/gcc/config/m68k/m68k.c
+===================================================================
+--- gcc-4.6-4.6.3.orig/gcc/config/m68k/m68k.c	2011-07-31 15:09:25.000000000 +0000
++++ gcc-4.6-4.6.3/gcc/config/m68k/m68k.c	2012-03-04 15:55:43.000000000 +0000
+@@ -1074,6 +1074,10 @@
+ 
+   m68k_compute_frame_layout ();
+ 
++  if (flag_stack_usage)
++    current_function_static_stack_size
++      = current_frame.size + current_frame.offset;
++
+   /* If the stack limit is a symbol, we can check it here,
+      before actually allocating the space.  */
+   if (crtl->limit_stack
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr48226.patch b/patches/gcc/linaro-4.6-2012.10/pr48226.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr48226.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr48226.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,33 @@
+# DP: Fix PR target/48226, Allow Iterator::vector vector on powerpc with VSX.
+
+--- /dev/null
++++ b/gcc/testsuite/gcc.target/powerpc/pr48226.c
+@@ -0,0 +1,14 @@
++/* { dg-do compile } */
++/* { dg-skip-if "" { powerpc*-*-darwin* } { "*" } { "" } } */
++/* { dg-require-effective-target powerpc_vsx_ok } */
++/* { dg-options "-O3 -mcpu=power7" } */
++
++/* The bug shows up if you compile with -maltivec or -mcpu=power7, due to one
++   of the vector's being eliminated due to rs6000_macro_to_expand being called
++   recursively.  */
++
++struct vector {
++  float v[4];
++};
++
++struct vector vector = { 1.0, 2.0, 3.0, 4.0 };
+--- a/gcc/config/rs6000/rs6000-c.c
++++ b/gcc/config/rs6000/rs6000-c.c
+@@ -182,7 +182,10 @@
+ 	  expand_this = C_CPP_HASHNODE (__vector_keyword);
+ 	  expand_bool_pixel = __bool_keyword;
+ 	}
+-      else if (ident)
++      /* The boost libraries have code with Iterator::vector vector in it.  If
++	 we allow the normal handling, this module will be called recursively,
++	 and the vector will be skipped.; */
++      else if (ident && (ident != C_CPP_HASHNODE (__vector_keyword)))
+ 	{
+ 	  enum rid rid_code = (enum rid)(ident->rid_code);
+ 	  if (ident->type == NT_MACRO)
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr49696.patch b/patches/gcc/linaro-4.6-2012.10/pr49696.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr49696.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr49696.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,72 @@
+2011-10-02  Richard Sandiford  <rdsandiford@googlemail.com>
+
+	PR target/49696
+	* config/mips/sync.md (sync_<optab>_12): Allow zero operands.
+	(sync_old_<optab>_12, sync_new_<optab>_12, sync_nand_12): Likewise.
+	(sync_old_nand_12, sync_new_nand_12, test_and_set_12): Likewise.
+
+--- a/gcc/config/mips/sync.md
++++ b/gcc/config/mips/sync.md
+@@ -136,7 +136,7 @@
+           [(match_operand:SI 1 "register_operand" "d")
+ 	   (match_operand:SI 2 "register_operand" "d")
+ 	   (atomic_hiqi_op:SI (match_dup 0)
+-			      (match_operand:SI 3 "register_operand" "dJ"))]
++			      (match_operand:SI 3 "reg_or_0_operand" "dJ"))]
+ 	  UNSPEC_SYNC_OLD_OP_12))
+    (clobber (match_scratch:SI 4 "=&d"))]
+   "GENERATE_LL_SC"
+@@ -177,7 +177,7 @@
+           [(match_operand:SI 2 "register_operand" "d")
+ 	   (match_operand:SI 3 "register_operand" "d")
+ 	   (atomic_hiqi_op:SI (match_dup 0)
+-			      (match_operand:SI 4 "register_operand" "dJ"))]
++			      (match_operand:SI 4 "reg_or_0_operand" "dJ"))]
+ 	  UNSPEC_SYNC_OLD_OP_12))
+    (clobber (match_scratch:SI 5 "=&d"))]
+   "GENERATE_LL_SC"
+@@ -218,7 +218,7 @@
+ 	   (match_operand:SI 2 "register_operand" "d")
+ 	   (match_operand:SI 3 "register_operand" "d")
+ 	   (atomic_hiqi_op:SI (match_dup 0)
+-			      (match_operand:SI 4 "register_operand" "dJ"))]
++			      (match_operand:SI 4 "reg_or_0_operand" "dJ"))]
+ 	  UNSPEC_SYNC_NEW_OP_12))
+    (set (match_dup 1)
+ 	(unspec_volatile:SI
+@@ -259,7 +259,7 @@
+           [(match_operand:SI 1 "register_operand" "d")
+ 	   (match_operand:SI 2 "register_operand" "d")
+ 	   (match_dup 0)
+-	   (match_operand:SI 3 "register_operand" "dJ")]
++	   (match_operand:SI 3 "reg_or_0_operand" "dJ")]
+ 	  UNSPEC_SYNC_OLD_OP_12))
+    (clobber (match_scratch:SI 4 "=&d"))]
+   "GENERATE_LL_SC"
+@@ -298,7 +298,7 @@
+ 	(unspec_volatile:SI
+           [(match_operand:SI 2 "register_operand" "d")
+ 	   (match_operand:SI 3 "register_operand" "d")
+-	   (match_operand:SI 4 "register_operand" "dJ")]
++	   (match_operand:SI 4 "reg_or_0_operand" "dJ")]
+ 	  UNSPEC_SYNC_OLD_OP_12))
+    (clobber (match_scratch:SI 5 "=&d"))]
+   "GENERATE_LL_SC"
+@@ -337,7 +337,7 @@
+           [(match_operand:SI 1 "memory_operand" "+R")
+ 	   (match_operand:SI 2 "register_operand" "d")
+ 	   (match_operand:SI 3 "register_operand" "d")
+-	   (match_operand:SI 4 "register_operand" "dJ")]
++	   (match_operand:SI 4 "reg_or_0_operand" "dJ")]
+ 	  UNSPEC_SYNC_NEW_OP_12))
+    (set (match_dup 1)
+ 	(unspec_volatile:SI
+@@ -546,7 +546,7 @@
+    (set (match_dup 1)
+ 	(unspec_volatile:SI [(match_operand:SI 2 "register_operand" "d")
+ 			     (match_operand:SI 3 "register_operand" "d")
+-			     (match_operand:SI 4 "arith_operand" "dJ")]
++			     (match_operand:SI 4 "reg_or_0_operand" "dJ")]
+ 	  UNSPEC_SYNC_EXCHANGE_12))]
+   "GENERATE_LL_SC"
+   { return mips_output_sync_loop (insn, operands); }
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr49756.patch b/patches/gcc/linaro-4.6-2012.10/pr49756.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr49756.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr49756.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,247 @@
+# DP: Fix PR c++/49756, backport from trunk
+
+gcc/
+
+2011-07-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49756
+	* gcc.c (main): Call stack_limit_increase (64MB).
+	* toplev.c (toplev_main): Likewise.
+
+include/
+
+2011-07-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49756
+	* libiberty.h (stack_limit_increase): New prototype.
+
+libiberty/
+
+2011-07-22  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/49756
+	* stack-limit.c: New file.
+	* Makefile.in: Regenerate deps.
+	(CFILES): Add stack-limit.c.
+	(REQUIRED_OFILES): Add ./stack-limit.$(objext).
+	* configure.ac (checkfuncs): Add getrlimit and setrlimit.
+	(AC_CHECK_FUNCS): Likewise.
+	* configure: Regenerated.
+	* config.in: Regenerated.
+
+--- a/gcc/gcc.c
++++ b/gcc/gcc.c
+@@ -6161,6 +6161,10 @@
+   signal (SIGCHLD, SIG_DFL);
+ #endif
+ 
++  /* Parsing and gimplification sometimes need quite large stack.
++     Increase stack size limits if possible.  */
++  stack_limit_increase (64 * 1024 * 1024);
++
+   /* Allocate the argument vector.  */
+   alloc_args ();
+ 
+--- a/gcc/toplev.c
++++ b/gcc/toplev.c
+@@ -1916,6 +1916,10 @@
+ int
+ toplev_main (int argc, char **argv)
+ {
++  /* Parsing and gimplification sometimes need quite large stack.
++     Increase stack size limits if possible.  */
++  stack_limit_increase (64 * 1024 * 1024);
++
+   expandargv (&argc, &argv);
+ 
+   /* Initialization of GCC's environment, and diagnostics.  */
+--- a/include/libiberty.h
++++ b/include/libiberty.h
+@@ -1,7 +1,7 @@
+ /* Function declarations for libiberty.
+ 
+    Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
+-   2006, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
++   2006, 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.
+    
+    Note - certain prototypes declared in this header file are for
+    functions whoes implementation copyright does not belong to the
+@@ -637,6 +637,9 @@
+ /* Set the title of a process */
+ extern void setproctitle (const char *name, ...);
+ 
++/* Increase stack limit if possible.  */
++extern void stack_limit_increase (unsigned long);
++
+ #define ARRAY_SIZE(a) (sizeof (a) / sizeof ((a)[0]))
+ 
+ /* Drastically simplified alloca configurator.  If we're using GCC,
+--- a/libiberty/configure.ac
++++ b/libiberty/configure.ac
+@@ -358,10 +358,10 @@
+ 
+ vars="sys_errlist sys_nerr sys_siglist"
+ 
+-checkfuncs="__fsetlocking canonicalize_file_name dup3 getrusage getsysinfo \
+- gettimeofday on_exit psignal pstat_getdynamic pstat_getstatic realpath \
+- sbrk spawnve spawnvpe strerror strsignal sysconf sysctl sysmp table \
+- times wait3 wait4"
++checkfuncs="__fsetlocking canonicalize_file_name dup3 getrlimit getrusage \
++ getsysinfo gettimeofday on_exit psignal pstat_getdynamic pstat_getstatic \
++ realpath setrlimit sbrk spawnve spawnvpe strerror strsignal sysconf sysctl \
++ sysmp table times wait3 wait4"
+ 
+ # These are neither executed nor required, but they help keep
+ # autoheader happy without adding a bunch of text to acconfig.h.
+@@ -371,13 +371,13 @@
+     calloc canonicalize_file_name clock \
+     dup3 \
+     ffs __fsetlocking \
+-    getcwd getpagesize getrusage getsysinfo gettimeofday \
++    getcwd getpagesize getrlimit getrusage getsysinfo gettimeofday \
+     index insque \
+     memchr memcmp memcpy memmem memmove memset mkstemps \
+     on_exit \
+     psignal pstat_getdynamic pstat_getstatic putenv \
+     random realpath rename rindex \
+-    sbrk setenv setproctitle sigsetmask snprintf spawnve spawnvpe \
++    sbrk setenv setproctitle setrlimit sigsetmask snprintf spawnve spawnvpe \
+      stpcpy stpncpy strcasecmp strchr strdup \
+      strerror strncasecmp strndup strrchr strsignal strstr strtod strtol \
+      strtoul strverscmp sysconf sysctl sysmp \
+--- a/libiberty/Makefile.in
++++ b/libiberty/Makefile.in
+@@ -2,7 +2,7 @@
+ # Originally written by K. Richard Pixley <rich@cygnus.com>.
+ #
+ # Copyright (C) 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
+-# 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
++# 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
+ # Free Software Foundation
+ #
+ # This file is part of the libiberty library.
+@@ -148,10 +148,10 @@
+ 	 simple-object.c simple-object-coff.c simple-object-elf.c	\
+ 	 simple-object-mach-o.c						\
+          snprintf.c sort.c						\
+-	 spaces.c splay-tree.c stpcpy.c stpncpy.c strcasecmp.c		\
+-	 strchr.c strdup.c strerror.c strncasecmp.c strncmp.c		\
+-	 strrchr.c strsignal.c strstr.c strtod.c strtol.c strtoul.c	\
+-	 strndup.c strverscmp.c						\
++	 spaces.c splay-tree.c stack-limit.c stpcpy.c stpncpy.c		\
++	 strcasecmp.c strchr.c strdup.c strerror.c strncasecmp.c	\
++	 strncmp.c strrchr.c strsignal.c strstr.c strtod.c strtol.c	\
++	 strtoul.c strndup.c strverscmp.c				\
+ 	tmpnam.c							\
+ 	unlink-if-ordinary.c						\
+ 	vasprintf.c vfork.c vfprintf.c vprintf.c vsnprintf.c vsprintf.c	\
+@@ -183,7 +183,8 @@
+ 	./simple-object.$(objext) ./simple-object-coff.$(objext)	\
+ 	./simple-object-elf.$(objext) ./simple-object-mach-o.$(objext)	\
+ 	./sort.$(objext) ./spaces.$(objext)				\
+-	./splay-tree.$(objext) ./strerror.$(objext)			\
++	./splay-tree.$(objext) ./stack-limit.$(objext)			\
++	./strerror.$(objext)						\
+ 	./strsignal.$(objext) ./unlink-if-ordinary.$(objext)		\
+ 	./xatexit.$(objext) ./xexit.$(objext) ./xmalloc.$(objext)	\
+ 	./xmemdup.$(objext) ./xstrdup.$(objext) ./xstrerror.$(objext)	\
+@@ -1033,6 +1034,12 @@
+ 	else true; fi
+ 	$(COMPILE.c) $(srcdir)/splay-tree.c $(OUTPUT_OPTION)
+ 
++./stack-limit.$(objext): $(srcdir)/stack-limit.c config.h
++	if [ x"$(PICFLAG)" != x ]; then \
++	  $(COMPILE.c) $(PICFLAG) $(srcdir)/stack-limit.c -o pic/$@; \
++	else true; fi
++	$(COMPILE.c) $(srcdir)/stack-limit.c $(OUTPUT_OPTION)
++
+ ./stpcpy.$(objext): $(srcdir)/stpcpy.c $(INCDIR)/ansidecl.h
+ 	if [ x"$(PICFLAG)" != x ]; then \
+ 	  $(COMPILE.c) $(PICFLAG) $(srcdir)/stpcpy.c -o pic/$@; \
+--- a/libiberty/config.in
++++ b/libiberty/config.in
+@@ -109,6 +109,9 @@
+ /* Define to 1 if you have the `getpagesize' function. */
+ #undef HAVE_GETPAGESIZE
+ 
++/* Define to 1 if you have the `getrlimit' function. */
++#undef HAVE_GETRLIMIT
++
+ /* Define to 1 if you have the `getrusage' function. */
+ #undef HAVE_GETRUSAGE
+ 
+@@ -205,6 +208,9 @@
+ /* Define to 1 if you have the `setproctitle' function. */
+ #undef HAVE_SETPROCTITLE
+ 
++/* Define to 1 if you have the `setrlimit' function. */
++#undef HAVE_SETRLIMIT
++
+ /* Define to 1 if you have the `sigsetmask' function. */
+ #undef HAVE_SIGSETMASK
+ 
+--- /dev/null
++++ b/libiberty/stack-limit.c
+@@ -0,0 +1,62 @@
++/* Increase stack size limit if possible.
++   Copyright (C) 2011 Free Software Foundation, Inc.
++
++This file is part of the libiberty library.  This library is free
++software; you can redistribute it and/or modify it under the
++terms of the GNU General Public License as published by the
++Free Software Foundation; either version 2, or (at your option)
++any later version.
++
++This library is distributed in the hope that it will be useful,
++but WITHOUT ANY WARRANTY; without even the implied warranty of
++MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
++GNU General Public License for more details.
++
++You should have received a copy of the GNU General Public License
++along with GNU CC; see the file COPYING.  If not, write to
++the Free Software Foundation, 51 Franklin Street - Fifth Floor,
++Boston, MA 02110-1301, USA.
++
++As a special exception, if you link this library with files
++compiled with a GNU compiler to produce an executable, this does not cause
++the resulting executable to be covered by the GNU General Public License.
++This exception does not however invalidate any other reasons why
++the executable file might be covered by the GNU General Public License. */
++
++/*
++
++@deftypefn Extension void stack_limit_increase (unsigned long @var{pref})
++
++Attempt to increase stack size limit to @var{pref} bytes if possible.
++
++@end deftypefn
++
++*/
++
++#include "config.h"
++
++#ifdef HAVE_STDINT_H
++#include <stdint.h>
++#endif
++#ifdef HAVE_SYS_RESOURCE_H
++#include <sys/resource.h>
++#endif
++
++void
++stack_limit_increase (unsigned long pref)
++{
++#if defined(HAVE_SETRLIMIT) && defined(HAVE_GETRLIMIT) \
++    && defined(RLIMIT_STACK) && defined(RLIM_INFINITY)
++  struct rlimit rlim;
++  if (getrlimit (RLIMIT_STACK, &rlim) == 0
++      && rlim.rlim_cur != RLIM_INFINITY
++      && rlim.rlim_cur < pref
++      && (rlim.rlim_max == RLIM_INFINITY || rlim.rlim_cur < rlim.rlim_max))
++    {
++      rlim.rlim_cur = pref;
++      if (rlim.rlim_max != RLIM_INFINITY && rlim.rlim_cur > rlim.rlim_max)
++	rlim.rlim_cur = rlim.rlim_max;
++      setrlimit (RLIMIT_STACK, &rlim);
++    }
++#endif
++}
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr49940.patch b/patches/gcc/linaro-4.6-2012.10/pr49940.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr49940.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr49940.patch	2013-01-31 17:59:11.899972992 -0300
@@ -0,0 +1,24 @@
+# DP: Apply proposed patch for PR ada/49940.
+
+# This patch consists in copying the declaration (and import) of lwp_self from
+# s-osint-freebsd.ads to s-osint-kfreebsd-gnu.ads.
+
+--- a/gcc/ada/s-osinte-kfreebsd-gnu.ads
++++ b/gcc/ada/s-osinte-kfreebsd-gnu.ads
+@@ -238,6 +238,16 @@
+    function getpid return pid_t;
+    pragma Import (C, getpid, "getpid");
+ 
++   ---------
++   -- LWP --
++   ---------
++
++   function lwp_self return System.Address;
++   --  lwp_self does not exist on this thread library, revert to pthread_self
++   --  which is the closest approximation (with getpid). This function is
++   --  needed to share 7staprop.adb across POSIX-like targets.
++   pragma Import (C, lwp_self, "pthread_self");
++
+    -------------
+    -- Threads --
+    -------------
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr49944.patch b/patches/gcc/linaro-4.6-2012.10/pr49944.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr49944.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr49944.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,244 @@
+# DP: apply proposed patch for PR ada/49444.
+# Status: submitted upstream
+
+2011-08-05  Ludovic Brenta <ludovic@ludovic-brenta.org>
+
+	PR ada/49944
+	* s-osinte-freebsd.ads: Update copyright years. Minor reformatting.
+	(Stack_Base_Available): Correct comments.
+	* s-osinte-kfreebsd-gnu.ads (Time_Slice_Supported, nanosleep,
+	clock_id_t, clock_gettime, Stack_Base_Available, Get_Page_Size,
+	mprotect, pthread_mutexattr_setprotocol, pthread_mutexattr_getprotocol,
+	pthread_mutexattr_setprioceiling, pthread_mutexattr_getprioceiling,
+	pthread_attr_setscope, pthread_attr_getscope,
+	pthread_attr_setinheritsched, pthread_attr_getinheritsched,
+	Time_Slice_Supported): Copy from s-osinte-freebsd.ads.
+
+--- a/gcc/ada/s-osinte-kfreebsd-gnu.ads
++++ b/gcc/ada/s-osinte-kfreebsd-gnu.ads
+@@ -7,7 +7,7 @@
+ --                                  S p e c                                 --
+ --                                                                          --
+ --             Copyright (C) 1991-1994, Florida State University            --
+---             Copyright (C) 1995-2005,2008 Free Software Foundation, Inc.  --
++--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+ --                                                                          --
+ -- GNARL is free software; you can  redistribute it  and/or modify it under --
+ -- terms of the  GNU General Public License as published  by the Free Soft- --
+@@ -32,7 +32,7 @@
+ --                                                                          --
+ ------------------------------------------------------------------------------
+ 
+---  This is the GNU/kFreeBSD (GNU/LinuxThreads) version of this package
++--  This is the GNU/kFreeBSD (POSIX Threads) version of this package
+ 
+ --  This package encapsulates all direct interfaces to OS services
+ --  that are needed by children of System.
+@@ -200,8 +200,24 @@
+    -- Time --
+    ----------
+ 
++   Time_Slice_Supported : constant Boolean := True;
++   --  Indicates whether time slicing is supported (i.e SCHED_RR is supported)
++
+    type timespec is private;
+ 
++   function nanosleep (rqtp, rmtp : access timespec) return int;
++   pragma Import (C, nanosleep, "nanosleep");
++
++   type clockid_t is private;
++
++   CLOCK_REALTIME : constant clockid_t;
++
++   function clock_gettime
++     (clock_id : clockid_t;
++      tp       : access timespec)
++      return int;
++   pragma Import (C, clock_gettime, "clock_gettime");
++
+    function To_Duration (TS : timespec) return Duration;
+    pragma Inline (To_Duration);
+ 
+@@ -273,6 +289,10 @@
+    type pthread_key_t       is private;
+ 
+    PTHREAD_CREATE_DETACHED : constant := 1;
++   PTHREAD_CREATE_JOINABLE : constant := 0;
++
++   PTHREAD_SCOPE_PROCESS : constant := 0;
++   PTHREAD_SCOPE_SYSTEM  : constant := 2;
+ 
+    -----------
+    -- Stack --
+@@ -296,9 +316,29 @@
+    Alternate_Stack_Size : constant := 0;
+    --  No alternate signal stack is used on this platform
+ 
++   Stack_Base_Available : constant Boolean := False;
++   --  Indicates whether the stack base is available on this target
++
+    function Get_Stack_Base (thread : pthread_t) return Address;
+    pragma Inline (Get_Stack_Base);
+-   --  This is a dummy procedure to share some GNULLI files
++   --  returns the stack base of the specified thread. Only call this function
++   --  when Stack_Base_Available is True.
++
++   function Get_Page_Size return size_t;
++   function Get_Page_Size return Address;
++   pragma Import (C, Get_Page_Size, "getpagesize");
++   --  Returns the size of a page
++
++   PROT_NONE  : constant := 0;
++   PROT_READ  : constant := 1;
++   PROT_WRITE : constant := 2;
++   PROT_EXEC  : constant := 4;
++   PROT_ALL   : constant := PROT_READ + PROT_WRITE + PROT_EXEC;
++   PROT_ON    : constant := PROT_NONE;
++   PROT_OFF   : constant := PROT_ALL;
++
++   function mprotect (addr : Address; len : size_t; prot : int) return int;
++   pragma Import (C, mprotect);
+ 
+    ---------------------------------------
+    -- Nonstandard Thread Initialization --
+@@ -387,6 +427,36 @@
+    -- POSIX.1c  Section 13 --
+    --------------------------
+ 
++   PTHREAD_PRIO_NONE    : constant := 0;
++   PTHREAD_PRIO_PROTECT : constant := 2;
++   PTHREAD_PRIO_INHERIT : constant := 1;
++
++   function pthread_mutexattr_setprotocol
++     (attr     : access pthread_mutexattr_t;
++      protocol : int) return int;
++   pragma Import
++      (C, pthread_mutexattr_setprotocol, "pthread_mutexattr_setprotocol");
++
++   function pthread_mutexattr_getprotocol
++     (attr     : access pthread_mutexattr_t;
++      protocol : access int) return int;
++   pragma Import
++     (C, pthread_mutexattr_getprotocol, "pthread_mutexattr_getprotocol");
++
++   function pthread_mutexattr_setprioceiling
++     (attr     : access pthread_mutexattr_t;
++      prioceiling : int) return int;
++   pragma Import
++     (C, pthread_mutexattr_setprioceiling,
++      "pthread_mutexattr_setprioceiling");
++
++   function pthread_mutexattr_getprioceiling
++     (attr     : access pthread_mutexattr_t;
++      prioceiling : access int) return int;
++   pragma Import
++     (C, pthread_mutexattr_getprioceiling,
++      "pthread_mutexattr_getprioceiling");
++
+    type struct_sched_param is record
+       sched_priority : int;  --  scheduling priority
+    end record;
+@@ -398,6 +468,28 @@
+       param  : access struct_sched_param) return int;
+    pragma Import (C, pthread_setschedparam, "pthread_setschedparam");
+ 
++   function pthread_attr_setscope
++     (attr            : access pthread_attr_t;
++      contentionscope : int) return int;
++   pragma Import (C, pthread_attr_setscope, "pthread_attr_setscope");
++
++   function pthread_attr_getscope
++     (attr            : access pthread_attr_t;
++      contentionscope : access int) return int;
++   pragma Import (C, pthread_attr_getscope, "pthread_attr_getscope");
++
++   function pthread_attr_setinheritsched
++     (attr            : access pthread_attr_t;
++      inheritsched : int) return int;
++   pragma Import
++     (C, pthread_attr_setinheritsched, "pthread_attr_setinheritsched");
++
++   function pthread_attr_getinheritsched
++     (attr         : access pthread_attr_t;
++      inheritsched : access int) return int;
++   pragma Import
++     (C, pthread_attr_getinheritsched, "pthread_attr_getinheritsched");
++
+    function pthread_attr_setschedpolicy
+      (attr   : access pthread_attr_t;
+       policy : int) return int;
+@@ -508,6 +600,9 @@
+    end record;
+    pragma Convention (C, timespec);
+ 
++   type clockid_t is new int;
++   CLOCK_REALTIME : constant clockid_t := 0;
++
+    type pthread_attr_t is record
+       detachstate   : int;
+       schedpolicy   : int;
+--- a/gcc/ada/gcc-interface/Makefile.in
++++ b/gcc/ada/gcc-interface/Makefile.in
+@@ -1125,9 +1125,7 @@
+   s-osinte.adb<s-osinte-posix.adb \
+   s-osinte.ads<s-osinte-kfreebsd-gnu.ads \
+   s-osprim.adb<s-osprim-posix.adb \
+-  s-taprop.adb<s-taprop-linux.adb \
+-  s-tasinf.ads<s-tasinf-linux.ads \
+-  s-tasinf.adb<s-tasinf-linux.adb \
++  s-taprop.adb<s-taprop-posix.adb \
+   s-taspri.ads<s-taspri-posix.ads \
+   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
+   system.ads<system-freebsd-x86.ads
+@@ -1153,9 +1151,7 @@
+   s-osinte.adb<s-osinte-posix.adb \
+   s-osinte.ads<s-osinte-kfreebsd-gnu.ads \
+   s-osprim.adb<s-osprim-posix.adb \
+-  s-taprop.adb<s-taprop-linux.adb \
+-  s-tasinf.ads<s-tasinf-linux.ads \
+-  s-tasinf.adb<s-tasinf-linux.adb \
++  s-taprop.adb<s-taprop-posix.adb \
+   s-taspri.ads<s-taspri-posix.ads \
+   s-tpopsp.adb<s-tpopsp-posix-foreign.adb \
+   system.ads<system-freebsd-x86_64.ads
+--- a/gcc/ada/s-osinte-freebsd.ads
++++ b/gcc/ada/s-osinte-freebsd.ads
+@@ -7,7 +7,7 @@
+ --                                   S p e c                                --
+ --                                                                          --
+ --             Copyright (C) 1991-1994, Florida State University            --
+---          Copyright (C) 1995-2009, Free Software Foundation, Inc.         --
++--          Copyright (C) 1995-2011, Free Software Foundation, Inc.         --
+ --                                                                          --
+ -- GNARL is free software; you can  redistribute it  and/or modify it under --
+ -- terms of the  GNU General Public License as published  by the Free Soft- --
+@@ -33,7 +33,7 @@
+ --                                                                          --
+ ------------------------------------------------------------------------------
+ 
+---  This is the FreeBSD PTHREADS version of this package
++--  This is the FreeBSD (POSIX Threads) version of this package
+ 
+ --  This package encapsulates all direct interfaces to OS services
+ --  that are needed by the tasking run-time (libgnarl).
+@@ -199,7 +199,7 @@
+ 
+    type timespec is private;
+ 
+-   function nanosleep (rqtp, rmtp : access timespec)  return int;
++   function nanosleep (rqtp, rmtp : access timespec) return int;
+    pragma Import (C, nanosleep, "nanosleep");
+ 
+    type clockid_t is private;
+@@ -313,10 +313,7 @@
+    --  No alternate signal stack is used on this platform
+ 
+    Stack_Base_Available : constant Boolean := False;
+-   --  Indicates whether the stack base is available on this target. This
+-   --  allows us to share s-osinte.adb between all the FSU run time. Note that
+-   --  this value can only be true if pthread_t has a complete definition that
+-   --  corresponds exactly to the C header files.
++   --  Indicates whether the stack base is available on this target
+ 
+    function Get_Stack_Base (thread : pthread_t) return Address;
+    pragma Inline (Get_Stack_Base);
diff -Nru a/patches/gcc/linaro-4.6-2012.10/pr50114.patch b/patches/gcc/linaro-4.6-2012.10/pr50114.patch
--- a/patches/gcc/linaro-4.6-2012.10/pr50114.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/pr50114.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,53 @@
+# DP: Fix PR c++/50114, backport from trunk.
+
+gcc/testsuite/
+
+2011-08-30  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50114
+	* g++.dg/cpp0x/lambda/lambda-for.C: New.
+
+cp/
+
+2011-08-30  Jason Merrill  <jason@redhat.com>
+
+	PR c++/50114
+	* decl.c (poplevel): Disable for scope compatibility hack
+	in C++11 mode.
+
+--- a/gcc/testsuite/g++.dg/ext/forscope2.C
++++ b/gcc/testsuite/g++.dg/ext/forscope2.C
+@@ -1,5 +1,5 @@
+ // { dg-do compile }
+-// { dg-options -fpermissive }
++// { dg-options "-fpermissive -std=c++98" }
+ 
+ // Copyright (C) 2001 Free Software Foundation, Inc.
+ // Contributed by Nathan Sidwell 4 Sept 2001 <nathan@codesourcery.com>
+--- /dev/null
++++ b/gcc/testsuite/g++.dg/cpp0x/lambda/lambda-for.C
+@@ -0,0 +1,12 @@
++// PR c++/50114
++// { dg-options "-std=c++0x -w" }
++
++int open()
++{
++  int *x2feed_i = 0;
++  auto insert_feed = [&](unsigned char venue, int* newfeed)
++  {
++     for(int x2feed_i = 1; 0; ) ;
++     x2feed_i = newfeed;
++  };
++}
+--- a/gcc/cp/decl.c
++++ b/gcc/cp/decl.c
+@@ -642,6 +642,9 @@
+   for (link = decls; link; link = TREE_CHAIN (link))
+     {
+       if (leaving_for_scope && TREE_CODE (link) == VAR_DECL
++	  /* It's hard to make this ARM compatibility hack play nicely with
++	     lambdas, and it really isn't necessary in C++11 mode.  */
++	  && cxx_dialect < cxx0x
+ 	  && DECL_NAME (link))
+ 	{
+ 	  tree name = DECL_NAME (link);
diff -Nru a/patches/gcc/linaro-4.6-2012.10/s390-biarch.patch b/patches/gcc/linaro-4.6-2012.10/s390-biarch.patch
--- a/patches/gcc/linaro-4.6-2012.10/s390-biarch.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/s390-biarch.patch	2013-01-31 17:59:11.943972993 -0300
@@ -0,0 +1,24 @@
+# DP: Build a bi-arch compiler on s390-linux-gnu.
+# DP: http://gcc.gnu.org/ml/gcc-patches/2009-03/msg01044.html
+
+2009-03-23  Arthur Loiret  <aloiret@debian.org>
+
+	* config.gcc (s390-*-linux*): If 'enabled_targets' is 'all', build
+	a bi-arch compiler defaulting to 31-bit. In this case:
+	(tmake_file): Add s390/t-linux64.
+---
+ gcc/config.gcc |    3 +++
+ 1 files changed, 3 insertions(+), 0 deletions(-)
+
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -2304,6 +2304,9 @@
+ 	;;
+ s390-*-linux*)
+ 	tm_file="s390/s390.h dbxelf.h elfos.h gnu-user.h linux.h glibc-stdint.h s390/linux.h"
++	if test x$enable_targets = xall; then
++		tmake_file="${tmake_file} s390/t-linux64"
++	fi
+ 	;;
+ s390x-*-linux*)
+ 	tm_file="s390/s390x.h s390/s390.h dbxelf.h elfos.h gnu-user.h linux.h glibc-stdint.h s390/linux.h"
diff -Nru a/patches/gcc/linaro-4.6-2012.10/sparc-force-cpu.patch b/patches/gcc/linaro-4.6-2012.10/sparc-force-cpu.patch
--- a/patches/gcc/linaro-4.6-2012.10/sparc-force-cpu.patch	1969-12-31 21:00:00.000000000 -0300
+++ b/patches/gcc/linaro-4.6-2012.10/sparc-force-cpu.patch	2013-01-31 17:59:11.939972993 -0300
@@ -0,0 +1,18 @@
+# DP: On sparc default to ultrasparc (v9a) in 32bit mode
+
+--- a/gcc/config.gcc
++++ b/gcc/config.gcc
+@@ -3766,6 +3766,13 @@
+ 			;;
+ 		esac
+ 
++		# setting this directly fails to build a biarch defaulting to 32bit
++		case "$target" in sparc*-*-linux*)
++			if test "$option" = cpu; then
++				val=ultrasparc
++			fi
++		esac
++
+ 		if test "x$t" = x
+ 		then
+ 			t="{ \"$option\", \"$val\" }"
